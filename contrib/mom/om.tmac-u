.\" -*- nroff -*-      om.tmac
.ig
Mom -- a typesetting/document-processing macro set for groff.

Copyright (C) 2002-2014  Free Software Foundation, Inc.
 Written by Peter Schaffter <peter@schaffter.ca>
 PDF integration contributed by Deri James <deri.james@chuzzlewit.co.uk>

This file is part of groff.

groff is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

groff is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.

Version 2.1-c_1
---------------
Antoine de St-Exupéry asserted that elegance in engineering is
achieved not when there is nothing left to add, but when there is
nothing left to take away.

By those standards, mom is a Rube Goldberg contraption.  She was
created over the years while groff, and my understanding of it,
changed and evolved.  However, I'm a firm believer in "if it ain't
broke, don't fix it."  Version 2.0 removes some of the redundancies
and cruft, but mom still needs some nip and tuck.

"<anything>" in the description of arguments that can be passed
to a macro means that any argument turns the feature off.

Thanks to everyone who has contributed suggestions and patches,
and to those whose GPL'd work has been plundered.  Special thanks
to Werner Lemberg (margin notes), Tadziu Hoffman (underlining),
Deri James (pdf integration), Robin Haberkorn (tbl integration, eqn
extentions, and float management).
..
.\" %beginstrip%
\#
\# ====================================================================
\#
\# Check which version of groff is being run
.if (\n[.x]\n[.y] < 118) \
.   ab [mom]: You need GNU troff version 1.18 or higher to run this version of mom.
\# Check that GNU troff is being run
.if !\n[.g]=1 \
.   ab [mom]: The mom macros require that you be running GNU troff.
.if \n[.C] \
.   ab [mom]: The groff mom macros do not work in compatibility mode.
\# Add supplementary styles
.sty \n[.fp] UL      \"  Ultra Light
.sty \n[.fp] ULI     \"  Ultra Light Italic
.sty \n[.fp] ULCD    \"  Ultra Light Condensed
.sty \n[.fp] ULCDI   \"  Ultra Light Condensed Italic
.sty \n[.fp] ULEX    \"  Ultra Light Extended
.sty \n[.fp] ULEXI   \"  Ultra Light Extended Italic
\#
.sty \n[.fp] XL      \"  Extra Light
.sty \n[.fp] XLI     \"  Extra Light Italic
.sty \n[.fp] XLCD    \"  Extra Light Condensed
.sty \n[.fp] XLCDI   \"  Extra Light Condensed Italic
.sty \n[.fp] XLEX    \"  Extra Light Extended
.sty \n[.fp] XLEXI   \"  Extra Light Extended Italic
\#
.sty \n[.fp] TH      \"  Thin
.sty \n[.fp] THI     \"  Thin Italic
.sty \n[.fp] THCD    \"  Thin Condensed
.sty \n[.fp] THCDI   \"  Thin Condensed Italic
.sty \n[.fp] THEX    \"  Thin Extended
.sty \n[.fp] THEXI   \"  Thin Extended Italic
\#
.sty \n[.fp] L       \"  Light Roman
.sty \n[.fp] LI      \"  Light Italic
.sty \n[.fp] LCD     \"  Light Condensed
.sty \n[.fp] LCDI    \"  Light Condensed Italic
.sty \n[.fp] LEX     \"  Light Extended
.sty \n[.fp] LEXI    \"  Light Extended Italic
\#
.sty \n[.fp] BK      \"  Book Roman
.sty \n[.fp] BKI     \"  Book Italic
.sty \n[.fp] BKCD    \"  Book Condensed
.sty \n[.fp] BKCDI   \"  Book Condensed Italic
.sty \n[.fp] BKEX    \"  Book Extended
.sty \n[.fp] BKEXI   \"  Book Extended Italic
\#
.sty \n[.fp] CD      \"  Medium Condensed
.sty \n[.fp] CDI     \"  Medium Condensed Italic
.sty \n[.fp] EX      \"  Medium Extended
.sty \n[.fp] EXI     \"  Medium Extended Italic
\#
.sty \n[.fp] DB      \"  DemiBold Roman
.sty \n[.fp] DBI     \"  DemiBold Italic
.sty \n[.fp] DBCD    \"  DemiBold Condensed
.sty \n[.fp] DBCDI   \"  DemiBold Condensed Italic
.sty \n[.fp] DBEX    \"  DemiBold Extended
.sty \n[.fp] DBEXI   \"  DemiBold Extended Italic
\#
.sty \n[.fp] SB      \"  SemiBold Roman
.sty \n[.fp] SBI     \"  SemiBold Italic
.sty \n[.fp] SBCD    \"  SemiBold Condensed
.sty \n[.fp] SBCDI   \"  SemiBold Condensed Italic
.sty \n[.fp] SBEX    \"  SemiBold Extended
.sty \n[.fp] SBEXI   \"  SemiBold Extended Italic
\#
.sty \n[.fp] BCD     \"  Bold Condensed
.sty \n[.fp] BCDI    \"  Bold Condensed Italic
.sty \n[.fp] BEX     \"  Bold Extended
.sty \n[.fp] BEXI    \"  Bold Extended Italic
.sty \n[.fp] BO      \"  Bold Outline
\#
.sty \n[.fp] XB      \"  Extra Bold
.sty \n[.fp] XBI     \"  Extra Bold Italic
.sty \n[.fp] XBCD    \"  Extra Bold Condensed
.sty \n[.fp] XBCDI   \"  Extra Bold Condensed Italic
.sty \n[.fp] XBEX    \"  Extra Bold Extended
.sty \n[.fp] XBEXI   \"  Extra Bold Extended Italic
\#
.sty \n[.fp] UB      \"  Ultra Bold
.sty \n[.fp] UBI     \"  Ultra Bold Italic
.sty \n[.fp] UBCD    \"  Ultra Bold Condensed
.sty \n[.fp] UBCDI   \"  Ultra Bold Condensed Italic
.sty \n[.fp] UBEX    \"  Ultra Bold Extended
.sty \n[.fp] UBEXI   \"  Ultra Bold Extended Italic
\#
.sty \n[.fp] HV      \"  Heavy
.sty \n[.fp] HVI     \"  Heavy Italic
.sty \n[.fp] HVCD    \"  Heavy Condensed
.sty \n[.fp] HVCDI   \"  Heavy Condensed Italic
.sty \n[.fp] HVEX    \"  Heavy Extended
.sty \n[.fp] HVEXI   \"  Heavy Extended Italic
\#
.sty \n[.fp] BL      \"  Black
.sty \n[.fp] BLI     \"  Black Italic
.sty \n[.fp] BLCD    \"  Black Condensed
.sty \n[.fp] BLCDI   \"  Black Condensed Italic
.sty \n[.fp] BLEX    \"  Black Extended
.sty \n[.fp] BLEXI   \"  Black Extended Italic
.sty \n[.fp] BLO     \"  Black Outline
\#
.sty \n[.fp] XBL     \"  Extra Black
.sty \n[.fp] XBLI    \"  Extra Black Italic
.sty \n[.fp] XBLCD   \"  Extra Black
.sty \n[.fp] XBLCDI  \"  Extra Black
.sty \n[.fp] XBLEX   \"  Extra Black Italic
.sty \n[.fp] XBLEXI  \"  Extra Black Italic
\#
.sty \n[.fp] UBL     \"  Ultra Black
.sty \n[.fp] UBLI    \"  Ultra Black Italic
.sty \n[.fp] UBLCD   \"  Ultra Black Condensed
.sty \n[.fp] UBLCDI  \"  Ultra Black Condensed Italic
.sty \n[.fp] UBLEX   \"  Ultra Black Exteneded
.sty \n[.fp] UBLEXI  \"  Ultra Black Extended Italic
\#
.sty \n[.fp] SC      \"  Small Caps Roman
.sty \n[.fp] SCI     \"  Small Caps Italic
.sty \n[.fp] SCDB    \"  Small Caps Demibold
.sty \n[.fp] SCDBI   \"  Small Caps Demibold Italic
.sty \n[.fp] SCSB    \"  Small Caps Semibold
.sty \n[.fp] SCSBI   \"  Small Caps Semibold Italic
\#
\# Instruct grops to use square linecaps and joins.
\# This instruction is also executed in DO_B_MARGIN, NEWPAGE, and HEADER
\#
.if !n \X'ps: exec 0 setlinejoin'\X'ps: exec 0 setlinecap'
\#
\# The following PostScript, provided by Tadziu Hoffmann, permits
\# no-fail underlining
\#
.de ul*ps
ps: def
grops begin
/decornone { grops begin /X { } def /Y { } def /y2 -1 def end } def
/decorline { grops begin u neg /uld exch def u /ulw exch def
             /X { currentpoint /y0 exch def /x0 exch def } def
             /Y { currentpoint /y1 exch def /x1 exch def
                  drawline /x2 x1 def /y2 y1 def } def end } def
/drawline { gsave ulw setlinewidth 0 setlinecap x1 y1 uld sub moveto
            y2 y0 eq { x2 y2 } { x0 y0 } ifelse uld sub lineto stroke
            grestore } def
decornone
/uld 0 def
/ulw 0 def
/A { X show Y } def
/B { 0 SC 3 -1 roll X widthshow Y } def
/C { 0 exch X ashow Y } def
/D { 0 exch 0 SC 5 2 roll X awidthshow Y } def
/E { 0 rmoveto X show Y } def
/F { 0 rmoveto 0 SC 3 -1 roll X widthshow Y } def
/G { 0 rmoveto 0 exch X ashow Y } def
/H { 0 rmoveto 0 exch 0 SC 5 2 roll X awidthshow Y } def
/I { 0 exch rmoveto X show Y } def
/J { 0 exch rmoveto 0 SC 3 -1 roll X widthshow Y } def
/K { 0 exch rmoveto 0 exch X ashow Y } def
/L { 0 exch rmoveto 0 exch 0 SC 5 2 roll X awidthshow Y } def
/M { rmoveto X show Y } def
/N { rmoveto 0 SC 3 -1 roll X widthshow Y } def
/O { rmoveto 0 exch X ashow Y } def
/P { rmoveto 0 exch 0 SC 5 2 roll X awidthshow Y } def
/Q { moveto X show Y } def
/R { moveto 0 SC 3 -1 roll X widthshow Y } def
/S { moveto 0 exch X ashow Y } def
/T { moveto 0 exch 0 SC 5 2 roll X awidthshow Y } def
end
..
\#
.if !n \Y[ul*ps]
.if n .color 0
.nr TOC.RELOCATE 0 \" TOC.RELOCATE is off by default
.ds PDFHREF.TEXTCOL.DEFAULT 0.0 0.3 0.9
\#
\# ====================================================================
\#
\# TYPESETTING MACROS, STRINGS, AND ALIASES
\# ========================================
\#
\# +++ALIASES+++
\#
\# Alias .als as ALIAS, and .aln (number registers) as ALIASN
\#
.als      ALIAS           als
.als      ALIASN          aln
\#
\# ALIASES FOR GROFF REQUESTS
\# --------------------------
\#
.ALIAS    MAC             de
.ALIAS    BR              br
.ALIAS    SPREAD          brp
.ALIAS    ESC_CHAR        ec
.ALIAS    STRING          ds
.ALIAS    INCLUDE         so
\#
\# ALIASES FOR NUMBER REGISTERS
\# ----------------------------
\#
.ALIASN  #PT_SIZE        .ps    \"fractional point size in units
.ALIASN  #DIVER_DEPTH     dn    \"diversion depth
.ALIASN  #DIVER_WIDTH     dl    \"diversion width
.ALIASN  #TRAP_DISTANCE  .t     \"distance to next trap
.ALIASN  #LEAD           .v     \"line space
.ALIASN  #PAGE_LENGTH    .p     \"page length
.ALIASN  #NUM_ARGS       .$     \"number of arguments passed to a macro
.ALIASN  #INDENT         .i     \"value of current indent
\#
\# ====================================================================
\#
\# MISCELLANEOUS
\# =============
.nr #L_MARGIN \n[.o]  \" Tabs, etc require #L_MARGIN
.cflags 4 /\[en]      \" So slash and en-dashes get broken
\#
\# ====================================================================
\#
\# +++PAGE LAYOUT+++
\#
\# Macros that control the physical layout of the page: paper size
\# and margins.
\#
\# PAGE WIDTH
\# ----------
\# *Argument:
\#   <width of printer sheet>
\# *Function:
\#   Stores user supplied page width in register #PAGE_WIDTH.
\# *Notes:
\#   #PAGE_WIDTH is used to establish the default LL (and right margin).
\#   Requires unit of measure.
\#
.MAC PAGEWIDTH END
.    br
.    nr #PAGE_WIDTH \\$1
.    if !r#L_MARGIN .L_MARGIN \\n[.o]
.    if !r#R_MARGIN .R_MARGIN 1i
.    if '\\*[.T]'pdf' \X'papersize=\\n[#PAGE_WIDTH]z,\\n[#PAGE_LENGTH]z'\c
.END
\#
\# L_MARGIN
\# --------
\# *Argument:
\#   <offset from page left>
\# *Function:
\#   Stores user supplied page offset in register #L_MARGIN.
\#   Sets .po to user supplied offset.
\# *Notes:
\#   Requires unit of measure.
\#
.MAC L_MARGIN END
.    br
.    nr #L_MARGIN (\\$1)
.    po \\n[#L_MARGIN]u
.END
\#
\# R_MARGIN
\# --------
\# *Argument:
\#   <width of right margin>
\# *Function:
\#   Stores user supplied right margin in register #R_MARGIN.
\# *Notes:
\#   This is a pseudo-margin.  Right margin is actually a function of
\#   line length.  The macro calculates line length from the page offset
\#   and the value plugged into #R_MARGIN.
\#
\#   N.B. -- PAGEWIDTH and L_MARGIN have to be defined before R_MARGIN.
\#
\#   Requires unit of measure.
\#
.MAC R_MARGIN END
.    br
.    nr #R_MARGIN (\\$1)
.    ll \\n[#PAGE_WIDTH]u-\\n[#L_MARGIN]u-\\n[#R_MARGIN]u
.    ta \\n[.l]u
.    nr #L_LENGTH \\n[.l]
.END
\#
\# T_MARGIN
\# --------
\# *Argument:
\#   <distance to advance from top of page>
\# *Function:
\#   Stores the user supplied top margin in register #T_MARGIN.
\#   Advances user supplied depth from the top of the page.
\# *Notes:
\#   Requires unit of measure.
\#
.MAC T_MARGIN END
.    nr #T_MARGIN (\\$1)
.    nr #TOP 1
.    if !\\n[#DOCS] .sp |\\n[#T_MARGIN]u-1v
.    wh 0i DO_T_MARGIN
.END
\#
\# B_MARGIN
\# --------
\# *Argument:
\#   <space to leave at the bottom of the page>
\# *Function:
\#   Stores the user supplied bottom margin in register #B_MARGIN.
\# *Notes:
\#   Requires unit of measure.
\#
.MAC B_MARGIN END
.    br
.    nr #B_MARGIN (\\$1)
.    nr #ORIGINAL_B_MARGIN \\n[#B_MARGIN]
.    nr #B_MARGIN_SET 1
.    wh -\\n[#B_MARGIN]u DO_B_MARGIN
.END
\#
\# PAGE
\# ----
\# *Arguments:
\#   <pagewidth>  [pagelength [leftmargin [rightmargin [topmargin [bottommargin]]]]]
\# *Function:
\#   Page set-up.  Collects arguments and passes them to the appropriate
\#   macros.
\# *Notes:
\#   All arguments after pagewidth are optional, but must appear
\#   in the order given above.  (User can fill in as much or as
\#   little as desired.)
\#
\#   All arguments require a unit of measure.
\#
.MAC PAGE END
.    br
.    PAGEWIDTH   \\$1
.    PAGELENGTH  \\$2
.    ie '\\$3''  .L_MARGIN \\n[.o]
.    el          .L_MARGIN \\$3
.    ie '\\$4''  .R_MARGIN 1i
.    el          .R_MARGIN \\$4
.    if !'\\$5'' .T_MARGIN \\$5
.    if !'\\$6'' .B_MARGIN \\$6
.END
\#
\# gropdf: pass pagelength to postprocessor; no need for -P-p
\#
.MAC PAGELENGTH END
.    pl \\$*
.    if '\\*[.T]'pdf' \X'papersize=\\n[#PAGE_WIDTH]z,\\n[#PAGE_LENGTH]z'\c
.END
\#
\# =====================================================================
\#
\# +++PAGE CONTROL+++
\#
\# Generic macros for breaking pages.
\#
\# DO_T_MARGIN
\# -----------
\# *Argument:
\#   <none>
\# *Function:
\#   Plants the top margin at the top of each page.
\# *Notes:
\#   The trap is set in .T_MARGIN or .PAGE
\#
.MAC DO_T_MARGIN END
.    ev T_MARGIN
.    nr #TOP 1
.    sp |\\n[#T_MARGIN]u-1v
.    ev
.    sp -\\n[#T_MARGIN_LEAD_ADJ]u
.END
\#
\# DO_B_MARGIN
\# -----------
\# *Argument:
\#   <none>
\# *Function:
\#   Plants the bottom margin at the bottom of each page.
\# *Notes:
\#   The trap is set in .B_MARGIN or .PAGE.
\#
.MAC DO_B_MARGIN END
.    nr #T_MARGIN_LEAD_ADJ \\n[#LEAD]-12000
'    bp
.    if !n .nop \X'ps: exec 0 setlinejoin'\X'ps: exec 0 setlinecap'
.END
\#
\# NEWPAGE
\# -------
\# *Argument:
\#   <none>
\# *Function:
\#   Breaks to a new page.
\# *Notes:
\#   If a B_MARGIN has been set, processes that, otherwise, just
\#   breaks to a new page.
\#
.MAC NEWPAGE END
.    if \\n[.vpt]=0 .vpt
.    ie \\n[#NO_BREAK] \{\
'       br
.       rr #NO_BREAK
.    \}
.    el .br
.    nr #NEWPAGE 1
.    nr @TOP 1
.    ie \\n[#B_MARGIN_SET]=1 \{\
.       ie !\\n[#DOCS]=1 \{\
.          ev NP
.          DO_B_MARGIN
.          ev
.       \}
.       el \{\
.          if \\n[#COLUMNS]=1 .nr #COL_NUM \\n[#NUM_COLS]
.          ie !\\n[#FN_DEPTH] \{\
.             ch FN_OVERFLOW_TRAP
.             DO_FOOTER
.             wh -(\\n[#FN_OVERFLOW_TRAP_POS]u) FN_OVERFLOW_TRAP
.          \}
.          el .DO_B_MARGIN
.       \}
.    \}
.    el 'bp
.END
\#
\# =====================================================================
\#
\# +++GENERAL STYLE MACROS+++
\#
\# LINE LENGTH
\# -----------
\# *Argument:
\#   <line length>
\# *Function:
\#   Stores user supplied line length in register #L_LENGTH.
\#   Sets .ll to #L_LENGTHu
\# *Notes:
\#   Requires unit of measure.
\#
.MAC LL END
.    nr #USER_SET_L_LENGTH 1
.    ll \\$1
.    nr #L_LENGTH \\n[.l]
.    ta \\n[.l]u
.END
\#
\# +++FAMILY AND FONT+++
\#
\# FALLBACK FONT
\# -------------
\# *Argument:
\#   <fallback font> [ ABORT | WARN ] | ABORT | WARN
\# *Function:
\#   Sets register #ABORT_FT_ERRORS to 1, or defines a fallback font
\#   called "dummy" at font position 0.
\# *Notes:
\#   Calls to non-existent families cause mom to continue processing
\#   files using the fallback font until a valid family is entered.
\#
\#   Calls to non-existent fonts generate warnings.  If ABORT is passed
\#   to FALLBACK_FONT, mom stops processing files after the warning.
\#   Otherwise, she continues to process files using the fallback font
\#   after the warning is issued.  The default fallback font is CR; the
\#   default for font warnings is to abort.
\#
.MAC FALLBACK_FONT END
.    if \\n[#NUM_ARGS]=1 \{\
.       if '\\$1'ABORT' .nr #ABORT_FT_ERRORS 1
.       if '\\$1'WARN' \
.          if r #ABORT_FT_ERRORS .nr #ABORT_FT_ERRORS 0
.       if !'\\$1'ABORT' \
.          if !'\\$1'WARN' .fp 0 dummy \\$1
.    \}
.    if \\n[#NUM_ARGS]=2 \{\
.       fp 0 dummy \\$1
.       if '\\$2'ABORT' .nr #ABORT_FT_ERRORS 1
.       if '\\$2'WARN'  .nr #ABORT_FT_ERRORS 0
.    \}
.END
\#
.FALLBACK_FONT CR ABORT
\#
\# FAMILY
\# ------
\# *Argument:
\#   <font family>
\# *Function:
\#   Stores user supplied font family in string $FAMILY.  Sets .fam
\#   to $FAMILY.
\#
.MAC FAMILY END
.    ds $FAMILY \\$1
.    if \\n[#PRINT_STYLE]=1 \{\
.       fam \\*[$TYPEWRITER_FAM]
.       return
.    \}
.    if \\n[#IGNORE] \{\
.       fam \\*[$TYPEWRITER_FAM]
.       return
.    \}
.    if (\\n[.x]\\n[.y]\\n[.Y] >= 1192) .ds $SAVED_STYLE \\n[.sty]
.    ft 0
.    fam \\*[$FAMILY]
.    if (\\n[.x]\\n[.y]\\n[.Y] >= 1192) \{\
.       ft \\*[$SAVED_STYLE]
.       if !F\\n[.fn] .ft 0
.    \}
.    ie \\n[#PRE_COLLATE]=1 .
.    el \{\
.       if \\n[#COLLATE]=1 \
.          if !r#START .ds $DOC_FAM \\*[$FAMILY]
.    \}
.END
\#
\# FONT
\# ----
\# *Argument:
\#   R | I | B | BI | <other style extension>
\# *Function:
\#  Stores user supplied font in $FONT and sets .ft to $FONT.
\#
.MAC FT END
.    ds $FONT \\$1
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie '\\$1'I' \{\
.          if \\n[#UNDERLINE_ITALIC]=1 \{\
.             UNDERLINE
.             return
.          \}
.          if \\n[#ITALIC_MEANS_ITALIC]=1 \{\
.             ds $FONT \\$1
.             ft \\*[$FONT]
.             return
.          \}
.       \}
.       el .UNDERLINE OFF
.       return
.    \}
.    ft 0
.    ft \\*[$FONT]
.    if (\\n[.x]\\n[.y]\\n[.Y] >= 1192) \{\
.       if '\\n[.sty]'' \{\
.          if !F\\n[.fn] \{\
.             if !S\\*[$FONT] \{\
.                tm1 "[mom]: Font style "\\*[$FONT]" at line \\n[.c] has not been registered.
.                ie \\n[#ABORT_FT_ERRORS]=0 \
.                   tm1 "       Continuing to process using fallback font.
.                el .ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.             \}
.             if \\n[.f]=0 \{\
.                tm1 "[mom]: Either font style "\\*[$FONT]" at line \\n[.c] does not exist in family "\\n[.fam]",
.                tm1 "       or family "\\n[.fam]" has not been installed.
.                ie \\n[#ABORT_FT_ERRORS]=0 \
.                   tm1 "       Continuing to process using fallback font.
.                el .ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.             \}
.          \}
.       \}
.    \}
.END
\#
\# POINT SIZE
\# ----------
\# *Arguments:
\#   <point size of type>
\# *Function:
\#   Sets point size to user supplied value in scaled points.
\#   If #AUTO_LEAD is on, resets lead accordingly.
\# *Notes:
\#   Must NOT use a unit of measure.
\#
.MAC PT_SIZE END
.    if \\n[#PRINT_STYLE]=1 .return
.    if \\n[#IGNORE] .return
.    ps \\$1
.    nr #PT_SIZE_IN_UNITS \\n[.ps]
.    ie '\\$0'DOC_PT_SIZE' \{\
.       if !\\n[#DOCS] .DOC_MACRO_ERROR \\$0
.       br
.       nr #NEW_DOC_PT_SIZE \\n[.ps]
.       if \\n[#DOC_AUTOLEAD] \{\
.          ie !\\n[#DOC_AUTOLEAD_FACTOR] .nr #AUTOLEADING \\n[#DOC_AUTOLEAD]
.          el .nr #AUTOLEADING \\n[.ps]*\\n[#DOC_AUTOLEAD]/1000-\\n[.ps]
.          nr #DOC_LEAD \\n[.ps]+\\n[#AUTOLEADING]
.          nr #RESET_TRAPS 1
.       \}
.    \}
.    el .if \\n[#AUTO_LEAD] .vs \\n[.ps]u+\\n[#AUTOLEADING]u
.END
\#
\# SIZE (inline)
\# -------------
\# *Arguments:
\#   <point size of type>
\# *Function:
\#   Sets point size to user supplied value in scaled points.
\#   Intended to be called inline with \*[SIZE <n><unit>]
\# *Notes:
\#   Can be used with a unit of measure or not.
\#
.MAC SIZE END
\c
.ps \\$1
.END
\#
\# LEADING
\# -------
\# *Argument:
\#   <leading between lines of text>
\# *Function:
\#   Turns off #AUTOLEAD if it's on.
\#   Sets .vs to user supplied value.
\# *Notes:
\#   Does not require unit of measure.  LS automatically turns off AUTOLEAD.
\#
.MAC LS END
.    br
.    nr #OLD_LEAD \\n[.v]
.    if \\n[#PRINT_STYLE]=1 .return
.    if \\n[#IGNORE] .return
.    if \\n[#AUTO_LEAD] \{\
.       rr #AUTO_LEAD
.       rr #AUTOLEAD_VALUE
.       rr #AUTOLEADING
.    \}
.    vs \\$1
.    if \\n[.t]<\\n[.v] 'bp
.    if \\n[#TOP] \{\
.       nr #TOP_BASELINE_ADJ \\n[.v]-\\n[#OLD_LEAD]
.       sp -\\n[#TOP_BASELINE_ADJ]u
.       rr #TOP
.       rr #TOP_BASELINE_ADJ
.    \}
.END
\#
\# AUTOLEAD
\# --------
\# *Argument:
\#   <leading value to add to #PT_SIZE> [FACTOR]
\# *Function:
\#   Stores user supplied auto-lead value in register #AUTOLEAD_VALUE.
\#   Adds #AUT0LEAD_VALUE to #PT_SIZE when invoked to set leading.
\#   All subsequent PT_SIZE requests reset the leading in the same way until
\#   AUTOLEAD is turned off.
\# *Notes:
\#   With the optional FACTOR argument, the current point size is
\#   multiplied by #AUTOLEAD_VALUE/1000 instead of the two being added
\#   together.
\#
.MAC AUTOLEAD END
.    if \\n[#PRINT_STYLE]=1 .return
.    if \\n[#IGNORE] .return
.    nr #AUTO_LEAD 1 \" autolead on or off
.    nr #OLD_LEAD \\n[.v]
.    nr #AUTOLEAD_VALUE (p;\\$1) \" arg x 1000
.    ie '\\$2'FACTOR' \{\
.       if !\\n[#DOCS] .nr #DOC_AUTOLEAD_FACTOR \\n[#AUTOLEAD_VALUE] \" save for DOC_PT_SIZE
.       nr #AUTOLEADING \\n[.ps]*\\n[#AUTOLEAD_VALUE]/1000-\\n[.ps]
.    \}
.    el .nr #AUTOLEADING \\n[#AUTOLEAD_VALUE]
.    vs \\n[.ps]u+\\n[#AUTOLEADING]u
.    if \\n[#TOP] \{\
.       nr #TOP_BASELINE_ADJ \\n[.v]-\\n[#OLD_LEAD]
.       sp -\\n[#TOP_BASELINE_ADJ]u
.       rr #TOP
.       rr #TOP_BASELINE_ADJ
.    \}
.END
\#
\# STRINGS FOR INLINE CONTROL OF GENERAL TYPE STYLE
\# ------------------------------------------------
.ds ROM  \Ef[R]
.ds IT   \Ef[I]
.ds BD   \Ef[B]
.ds BDI  \Ef[BI]
.ds PREV \Ef[]
.ds S    \Es
\#
\# =====================================================================
\#
\# +++KERNING+++
\#
\# AUTOMATIC PAIRWISE KERNING
\# --------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns automatic pairwise kerning on or off.
\#
.MAC KERN END
.    ie '\\$1'' \{\
.       kern
.       nr #KERN 1
.    \}
.    el \{\
.       kern 0
.       nr #KERN 0
.    \}
.END
\#
\# INLINE KERNING AND HORIZONTAL MOVEMENT
\# --------------------------------------
\#
\# Inline kerning provides a simple way to adjust the amount of
\# space between any two letters.  It's predicated on a unit of
\# measure "U", which, by default, is 1/36 of the current point
\# size as returned by \n[.ps]; e.g., if the current point size is
\# 18, \n[.ps] returns 18000u, therefore U=500u.  Since U remains
\# proportional relative to the current point size, the amount of
\# kerning between two letters as expressed in Us remains visually
\# similar regardless of changes in point size.
\#
\# The default value for U may be changed or reset with the
\# KERN_UNIT macro.
\#
.MAC KERN_UNIT END
.    ie '\\$1'DEFAULT' .nr #KERN_UNIT 36
.    el .nr #KERN_UNIT \\$1
.END
\#
.nr #KERN_UNIT 36
.ds BU   \h'-(\En[#PT_SIZE]u/\n[#KERN_UNIT]u*\\$1u)'
.ds FU   \h'(\En[#PT_SIZE]u/\n[#KERN_UNIT]u*\\$1u)'
\#
\# Initialize strings for pre-1.1.3c-style BU and FU
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<37 \{\
.   ds BU\n[#LOOP]  \h'-(\En[#PT_SIZE]u/\n[#KERN_UNIT]u*\n[#LOOP]u)'
.\}
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<37 \{\
.   ds FU\n[#LOOP] \h'(\En[#PT_SIZE]u/\n[#KERN_UNIT]u*\n[#LOOP]u)'
.\}
.rr #LOOP
\#
\# Horizontal movements
\# --------------------
\# BP1...12.75 and FP1...12.75 move backwards or forwards inline by the
\# specified number of points.
\#
.ds BCK  \h'-\\$1'
.ds FWD  \h'\\$1'
\#
.ds BP.25    \h'-.25'
.ds BP.5     \h'-.5'
.ds BP.75    \h'-.75'
.ds BP1      \h'-1p'
.ds BP1.25   \h'-1.25p'
.ds BP1.5    \h'-1.5p'
.ds BP1.75   \h'-1.75p'
.ds BP2      \h'-2p'
.ds BP2.25   \h'-2.25p'
.ds BP2.5    \h'-2.5p'
.ds BP2.75   \h'-2.75p'
.ds BP3      \h'-3p'
.ds BP3.25   \h'-3.25p'
.ds BP3.5    \h'-3.5p'
.ds BP3.75   \h'-3.75p'
.ds BP4      \h'-4p'
.ds BP4.25   \h'-4.25p'
.ds BP4.5    \h'-4.5p'
.ds BP4.75   \h'-4.75p'
.ds BP5      \h'-5p'
.ds BP5.25   \h'-5.25p'
.ds BP5.5    \h'-5.5p'
.ds BP5.75   \h'-5.75p'
.ds BP6      \h'-6p'
.ds BP6.25   \h'-6.25p'
.ds BP6.5    \h'-6.5p'
.ds BP6.75   \h'-6.75p'
.ds BP7      \h'-7p'
.ds BP7.25   \h'-7.25p'
.ds BP7.5    \h'-7.5p'
.ds BP7.75   \h'-7.75p'
.ds BP8      \h'-8p'
.ds BP8.25   \h'-8.25p'
.ds BP8.5    \h'-8.5p'
.ds BP8.75   \h'-8.75p'
.ds BP9      \h'-9p'
.ds BP9.25   \h'-9.25p'
.ds BP9.5    \h'-9.5p'
.ds BP9.75   \h'-9.75p'
.ds BP10     \h'-10p'
.ds BP10.25  \h'-10.25p'
.ds BP10.5   \h'-10.5p'
.ds BP10.75  \h'-10.75p'
.ds BP11     \h'-11p'
.ds BP11.25  \h'-11.25p'
.ds BP11.5   \h'-11.5p'
.ds BP11.75  \h'-11.75p'
.ds BP12     \h'-12p'
.ds BP12.25  \h'-12.25p'
.ds BP12.5   \h'-12.5p'
.ds BP12.75  \h'-12.75p'
\#
.ds FP.25    \h'.25'
.ds FP.5     \h'.5'
.ds FP.75    \h'.75'
.ds FP1      \h'1p'
.ds FP1.25   \h'1.25p'
.ds FP1.5    \h'1.5p'
.ds FP1.75   \h'1.75p'
.ds FP2      \h'2p'
.ds FP2.25   \h'2.25p'
.ds FP2.5    \h'2.5p'
.ds FP2.75   \h'2.75p'
.ds FP3      \h'3p'
.ds FP3.25   \h'3.25p'
.ds FP3.5    \h'3.5p'
.ds FP3.75   \h'3.75p'
.ds FP4      \h'4p'
.ds FP4.25   \h'4.25p'
.ds FP4.5    \h'4.5p'
.ds FP4.75   \h'4.75p'
.ds FP5      \h'5p'
.ds FP5.25   \h'5.25p'
.ds FP5.5    \h'5.5p'
.ds FP5.75   \h'5.75p'
.ds FP6      \h'6p'
.ds FP6.25   \h'6.25p'
.ds FP6.5    \h'6.5p'
.ds FP6.75   \h'6.75p'
.ds FP7      \h'7p'
.ds FP7.25   \h'7.25p'
.ds FP7.5    \h'7.5p'
.ds FP7.75   \h'7.75p'
.ds FP8      \h'8p'
.ds FP8.25   \h'8.25p'
.ds FP8.5    \h'8.5p'
.ds FP8.75   \h'8.75p'
.ds FP9      \h'9p'
.ds FP9.25   \h'9.25p'
.ds FP9.5    \h'9.5p'
.ds FP9.75   \h'9.75p'
.ds FP10     \h'10p'
.ds FP10.25  \h'10.25p'
.ds FP10.5   \h'10.5p'
.ds FP10.75  \h'10.75p'
.ds FP11     \h'11p'
.ds FP11.25  \h'11.25p'
.ds FP11.5   \h'11.5p'
.ds FP11.75  \h'11.75p'
.ds FP12     \h'12p'
.ds FP12.25  \h'12.25p'
.ds FP12.5   \h'12.5p'
.ds FP12.75  \h'12.75p'
\#
\# WHOLE LINE (TRACK) KERNING
\# --------------------------
\# *Argument:
\#   <amount of track kerning>
\# *Function:
\#   Invokes .tkf (track kerning) for the current font with
\#   1 as both the upper and lower point size limits, so that
\#   the value entered by the user applies regardless of point
\#   size.  RW ("Reduce Whitespace") reduces the amount of space
\#   between all characters by an equal amount.  EW ("Extra
\#   Whitespace") increases the amount of space.
\# *Notes:
\#   Decimal values are acceptable.
\#
\# A value of 1 will produce an unacceptably tight or loose line
\# at most text point sizes; therefore, effective use of RW and
\# EW is in the fractional range below 1.
\#
\# \n[.f] holds the current font number, which is acceptable to .tkf.
\#
\# RW and EW must be reset to 0 to cancel their effect on subsequent
\# output lines.
\#
.MAC RW END
.    if \\n[#BR_AT_LINE_KERN] \{\
.       ie \\n[#JUSTIFY]=1 .brp
.       el .br
.    \}
.    rr #EW
.    rm $EW
.    nr #RW 1
.    ds $RW \\$1
.    tkf \\n[.f] 1 -\\$1 1 -\\$1
.END
\#
.MAC EW END
.    if \\n[#BR_AT_LINE_KERN] \{\
.       ie \\n[#JUSTIFY]=1 .brp
.       el .br
.    \}
.    rr #RW
.    rm $RW
.    nr #EW 1
.    ds $EW \\$1
.    tkf \\n[.f] 1 \\$1 1 \\$1
.END
\#
\# BREAK AT LINE KERN
\# ------------------
\# *Arguments:
\#   toggle
\# *Function:
\#   Enables/disables .br's before .RW and .EW
\# *Notes:
\#   Mostly, users will want .br's before any kind of line kerning, but
\#   there may be cases where they don't.  BR_AT_LINE_KERN is off by
\#   default and must be invoked explicitly.
\#
.MAC BR_AT_LINE_KERN END
.    ie '\\$1'' .nr #BR_AT_LINE_KERN  1
.    el .rr #BR_AT_LINE_KERN
.END
\#
\# =====================================================================
\#
\# +++HYPHENATION+++
\#
\# AUTO HYPHENATION
\# ----------------
\# *Arguments:
\#   <none> | <anything> | DEFAULT
\#                 or
\#   LINES <n> | MARGIN <n> | SPACE <n>
\# *Function:
\#   Turns auto hyphenation on or off, resets the hyphenation style
\#   to default, or permits the setting of various hyphenation
\#   parameters.
\# *Notes:
\#   HY, by itself, defaults to .hy 14, i.e. no hyphens after the
\#   first two or before the last two characters of a word, and no
\#   hyphenation of the last line prior to a trap (e.g., at the
\#   bottom of a page).
\#
\#   HY DEFAULT resets the hyphenation style to .hy 14 (see
\#   above) if that behaviour is desired after changes have been
\#   made to LINES, MARGIN, or SPACE.
\#
\#   HY LINES <n> sets the number of allowable consecutive hyphenated lines.
\#
\#   HY MARGIN <n> sets the amount of space (ipPcm) allowed at the end
\#   of a line in QUAD mode before hyphenation is tripped (e.g. if there's
\#   only 6 points left, groff won't try to hyphenate the next word).
\#
\#   HY SPACE sets the amount of extra interword space (ipPcm) that can
\#   be added in JUSTIFY mode to prevent a line from being hyphenated.
\#
.MAC HY END
.    ie '\\$1'' \{\
.       hy 14
.       if \\n[#LINES]  .hlm \\n[#LINES]
.       if \\n[#MARGIN] .hym \\n[#MARGIN]]
.       if \\n[#SPACE]  .hys \\n[#SPACE]
.       nr #HYPHENATE 1
.    \}
.    el \{\
.       if !'\\$1'LINES' \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if !'\\$1'MARGIN' \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if !'\\$1'SPACE' \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if !'\\$1'DEFAULT' \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if '\\$1'LINES'  \{\
.          hlm \\$2
.          nr #HY_LINES \\$2
.       \}
.       if '\\$1'MARGIN' \{\
.          hym \\$2
.          nr #HY_MARGIN \\$2
.       \}
.       if '\\$1'SPACE'  \{\
.          hys \\$2
.          nr #HY_SPACE \\$2
.       \}
.       if '\\$1'DEFAULT' \{\
.          hlm -1
.          hym 0
.          hys 0
.          rr #HY_LINES
.          rr #HY_SPACE
.          rr #HY_MARGIN
.       \}
.    \}
.END
\#
\# HYPHENATION PARAMETERS
\# ----------------------
\# *Arguments:
\#   <# of lines> | <size of margin> | <amount of interword space>
\# *Function:
\#   Allows user to specify .HY LINES, MARGIN, and SPACE with a single command.
\#
.MAC HY_SET END
.    nr #HY_SET 1
.    hlm \\$1
.    hym \\$2
.    hys \\$3
.END
\#
\# =====================================================================
\#
\# +++VERTICAL SPACING+++
\#
\# ADVANCE LEAD
\# ------------
\# *Argument:
\#   <user supplied lead to advance below current baseline>
\# *Function:
\#   Creates or modifies register #ALD.  Adds user supplied lead
\#   below current baseline.
\# *Notes:
\#   Requires a unit of measure.
\#
.MAC ALD END
.    br
.    if \\n[nl]=0 .nr #TOP 1
.    if '\\$0'ALD' \{\
.       nr #ALD (\\$1)
.       sp \\n[#ALD]u
.    \}
.    if '\\$0'ADD_SPACE' \{\
.       vpt 0
.       nr #ALD (\\$1)
.       rs
.       nop \&
.       sp |\\n[#T_MARGIN]u-1v+\\n[#ALD]u
.       rr @TOP
.       nr #SPACE_ADDED 1
.       vpt
.    \}
.    if '\\$0'SPACE' .sp \\$1
.    if '\\$0'SP'    .sp \\$1
.END
\#
\# REVERSE LEAD
\# ------------
\# *Argument:
\#   <user supplied lead to reverse above current baseline>
\# *Function:
\#   Creates or modifies register #RLD.  Reverses user supplied
\#   lead above current baseline.
\# *Notes:
\#   Requires a unit of measure.
\#
.MAC RLD END
.    br
.    nr #RLD (\\$1)
.    sp -\\n[#RLD]u
.END
\#
\# ALD/RLD STRINGS
\# ---------------
\# The strings \*[ALD.25]...\*[ALD12.75] and their corresponding
\# \*[RLD] forms have been left in for backward compatibility with
\# documents created using mom-1.1.3c or earlier.  The preferred methods
\# of advancing and reversing on the page inline are \*[UP <n><unit>]
\# and \*[DOWN <n><unit>].
\#
.ds DOWN      \v'\\$1'
.ds UP        \v'-\\$1'
\#
.ds ALD.25    \v'.25p'
.ds ALD.5     \v'.5p'
.ds ALD.75    \v'.75p'
.ds ALD1      \v'1p'
.ds ALD1.25   \v'1.25p'
.ds ALD1.5    \v'1.5p'
.ds ALD1.75   \v'1.75p'
.ds ALD2      \v'2p'
.ds ALD2.25   \v'2.25p'
.ds ALD2.5    \v'2.5p'
.ds ALD2.75   \v'2.75p'
.ds ALD3      \v'3p'
.ds ALD3.25   \v'3.25p'
.ds ALD3.5    \v'3.5p'
.ds ALD3.75   \v'3.75p'
.ds ALD4      \v'4p'
.ds ALD4.25   \v'4.25p'
.ds ALD4.5    \v'4.5p'
.ds ALD4.75   \v'4.75p'
.ds ALD5      \v'5p'
.ds ALD5.25   \v'5.25p'
.ds ALD5.5    \v'5.5p'
.ds ALD5.75   \v'5.75p'
.ds ALD6      \v'6p'
.ds ALD6.25   \v'6.25p'
.ds ALD6.5    \v'6.5p'
.ds ALD6.75   \v'6.75p'
.ds ALD7      \v'7p'
.ds ALD7.25   \v'7.25p'
.ds ALD7.5    \v'7.5p'
.ds ALD7.75   \v'7.75p'
.ds ALD8      \v'8p'
.ds ALD8.25   \v'8.25p'
.ds ALD8.5    \v'8.5p'
.ds ALD8.75   \v'8.75p'
.ds ALD9      \v'9p'
.ds ALD9.25   \v'9.25p'
.ds ALD9.5    \v'9.5p'
.ds ALD9.75   \v'9.75p'
.ds ALD10     \v'10p'
.ds ALD10.25  \v'10.25p'
.ds ALD10.5   \v'10.5p'
.ds ALD10.75  \v'10.75p'
.ds ALD11     \v'11p'
.ds ALD11.25  \v'11.25p'
.ds ALD11.5   \v'11.5p'
.ds ALD11.75  \v'11.75p'
.ds ALD12     \v'12p'
.ds ALD12.25  \v'12.5p'
.ds ALD12.5   \v'12.5p'
.ds ALD12.75  \v'12.75p'
\#
.ds RLD.25    \v'-.25p'
.ds RLD.5     \v'-.5p'
.ds RLD.75    \v'-.75p'
.ds RLD1      \v'-1p'
.ds RLD1.25   \v'-1.25p'
.ds RLD1.5    \v'-1.5p'
.ds RLD1.75   \v'-1.75p'
.ds RLD2      \v'-2p'
.ds RLD2.25   \v'-2.25p'
.ds RLD2.5    \v'-2.5p'
.ds RLD2.75   \v'-2.75p'
.ds RLD3      \v'-3p'
.ds RLD3.25   \v'-3.25p'
.ds RLD3.5    \v'-3.5p'
.ds RLD3.75   \v'-3.75p'
.ds RLD4      \v'-4p'
.ds RLD4.25   \v'-4.25p'
.ds RLD4.5    \v'-4.5p'
.ds RLD4.75   \v'-4.75p'
.ds RLD5      \v'-5p'
.ds RLD5.25   \v'-5.25p'
.ds RLD5.5    \v'-5.5p'
.ds RLD5.75   \v'-5.75p'
.ds RLD6      \v'-6p'
.ds RLD6.25   \v'-6.25p'
.ds RLD6.5    \v'-6.5p'
.ds RLD6.75   \v'-6.75p'
.ds RLD7      \v'-7p'
.ds RLD7.25   \v'-7.25p'
.ds RLD7.5    \v'-7.5p'
.ds RLD7.75   \v'-7.75p'
.ds RLD8      \v'-8p'
.ds RLD8.25   \v'-8.25p'
.ds RLD8.5    \v'-8.5p'
.ds RLD8.75   \v'-8.75p'
.ds RLD9      \v'-9p'
.ds RLD9.25   \v'-9.25p'
.ds RLD9.5    \v'-9.5p'
.ds RLD9.75   \v'-9.75p'
.ds RLD10     \v'-10p'
.ds RLD10.25  \v'-10.25p'
.ds RLD10.5   \v'-10.5p'
.ds RLD10.75  \v'-10.75p'
.ds RLD11     \v'-11p'
.ds RLD11.25  \v'-11.25p'
.ds RLD11.5   \v'-11.5p'
.ds RLD11.75  \v'-11.75p'
.ds RLD12     \v'-12p'
.ds RLD12.25  \v'-12.5p'
.ds RLD12.5   \v'-12.5p'
.ds RLD12.75  \v'-12.75p'
\#
\# =====================================================================
\#
\# +++REFINEMENTS+++
\#
\# AUTOMATIC LIGATURES
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns automatic ligature generation on or off.
\# *Notes:
\#   Ligatures may be supplied manually with \[fi], \[fl], etc.
\#
.MAC LIGATURES END
.    ie '\\$1'' \{\
.       lg
.       nr #LIGATURES 1
.    \}
.    el \{\
.       lg 0
.       nr #LIGATURES 0
.    \}
.END
\#
\# SMARTQUOTES
\# -----------
\# *Arguments:
\#   [ ,, ] | [ << ] | [ >> ] | <anything>
\#   or
\#   [ DA | DE | EN | ES | FR | IT | NL | NO | PT | SV ] | <anything>
\# *Function:
\#   Turns smartquotes on (optionally with a quoting style from the
\#   argument list, or off).
\#   If no quoting style is given, then EN (English) is used by default.
\#   If no quoting style is given and smart quotes have been turned off
\#   previously, the old quoting style will be restored.
\# *Notes:
\#   The " character is read outside the macro when mom is
\#   processed.  The strings for open/close ($QUOTE<n>) are then
\#   defined in the macro.
\#
.char " \\*[$QUOTE\\n[#OPEN_CLOSE]]\R'#OPEN_CLOSE (1-\\n[#OPEN_CLOSE])'
.nr #SQ_ON 0
\#
.MAC SMARTQUOTES END
.\" First " will be translated to $QUOTE0
.    nr #OPEN_CLOSE 0
.    if '\\$1'' \{\
.       if !'\\*[$RESTORE_SQ]'' \{\
.          SMARTQUOTES \\*[$RESTORE_SQ]
.          return
.       \}
.\" Default smart quotes (English)
.       ds $QUOTE0 \[lq]
.       ds $QUOTE1 \[rq]
.       ds $RESTORE_SQ EN
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1',,' \{\
.       ds $QUOTE0 \[Bq]
.       ds $QUOTE1 \[lq]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'<<' \{\
.       ds $QUOTE0 \[Fo]
.       ds $QUOTE1 \[Fc]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'>>' \{\
.       ds $QUOTE0 \[Fc]
.       ds $QUOTE1 \[Fo]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'DA' \{\
.       ds $QUOTE0 \[Fc]
.       ds $QUOTE1 \[Fo]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'DE' \{\
.       ds $QUOTE0 \[Bq]
.       ds $QUOTE1 \[lq]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'EN' \{\
.       ds $QUOTE0 \[lq]
.       ds $QUOTE1 \[rq]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'ES' \{\
.       ds $QUOTE0 \[lq]
.       ds $QUOTE1 \[rq]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'FR' \{\
.       ds $QUOTE0 \[Fo]\|
.       ds $QUOTE1 \|\[Fc]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'IT' \{\
.       ds $QUOTE0 \[Fo]\|
.       ds $QUOTE1 \|\[Fc]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'NL' \{\
.       ds $QUOTE0 \[rq]
.       ds $QUOTE1 \[rq]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'NO' \{\
.       ds $QUOTE0 \[Fo]
.       ds $QUOTE1 \[Fc]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'PT' \{\
.       ds $QUOTE0 \[Fo]
.       ds $QUOTE1 \[Fc]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'SV' \{\
.       ds $QUOTE0 \[Fc]
.       ds $QUOTE1 \[Fc]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.\" None of the above -> turn smartquotes off
.    ds $QUOTE0 \[dq]
.    ds $QUOTE1 \[dq]
.    nr #SQ_ON 0
.END
\#
.ds $QUOTE0 \[lq]
.ds $QUOTE1 \[rq]
\#
\# Strings for foot and inch marks
\#
.ds FOOT \[fm]
.ds INCH \[fm]\[fm]
\#
\# =====================================================================
\#
\# +++LINE BREAKS+++
\#
\# NO-SPACE BREAK
\# --------------
\# *Argument:
\#   <none>
\# *Function:
\#   Breaks a line without advancing.
\# *Notes:
\#   EL is the mnemonic used on older, dedicated typesetting machines
\#   to indicate "process the line, without advancing the galley
\#   medium."  It stands for End Line.
\#
\#   The \c inline must be appended to the end of input lines when in
\#   nofill mode; in fill modes, the \c inline must not be used.
\#
.MAC EL END
.    TRAP OFF
.    if \\n[#PSEUDO_FILL]=1 \&
.    br
.    sp -1v
.    TRAP
.END
\#
\# An inline escape to accomplish the same thing.
\# Preferable, since it works with filled and non-filled copy and
\# doesn't require the user to remember whether to use (or not use)
\# \c.
\#
.ds B \h'|0'\R'#NO_ADVANCE 1'\c
\#
\# =====================================================================
\#
\# +++FILLING/QUADDING/JUSTIFYING+++
\#
\# JUSTIFY
\# -------
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill on and sets .ad to b.
\# *Notes:
\#   Justifies text left and right.
\#
.MAC JUSTIFY END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       nr #QUAD 1
.       ds $RESTORE_QUAD_VALUE \\*[$QUAD_VALUE]
.    \}
'    ce 0
.    QUAD J
.    if \\n[#PRINT_STYLE]=1 .QUAD L
.    nr #PSEUDO_FILL 0
.END
\#
\# QUAD
\# ----
\# *Arguments:
\#   L | LEFT | R | RIGHT | C | CENTER/CENTRE
\# *Function:
\#   Turns fill on and sets .ad to l, r, or c.
\# *Notes:
\#   Terminology is a problem here.  Some people call quad left
\#   left justified, flush left, or flush left/rag right (and the
\#   reverse for quad right).  Quad center is sometimes called rag
\#   both.  For our purposes, all "quad" modes mean that groff fill
\#   mode is enabled.
\#
.MAC QUAD END
.    ds $QUAD_VALUE \\$1
.    if \\n[#TAB_ACTIVE]=0 \{\
.       nr #QUAD 1
.       ds $RESTORE_QUAD_VALUE \\*[$QUAD_VALUE]
.    \}
'    ce 0
'    fi
.    if '\\*[$QUAD_VALUE]'L' \{\
.       nr #JUSTIFY 0
.       ad l
.    \}
.    if '\\*[$QUAD_VALUE]'LEFT' \{\
.       nr #JUSTIFY 0
.       ad l
.    \}
.    if '\\*[$QUAD_VALUE]'R' \{\
.       nr #JUSTIFY 0
.       ad r
.    \}
.    if '\\*[$QUAD_VALUE]'RIGHT' \{\
.       nr #JUSTIFY 0
.       ad r
.    \}
.    if '\\*[$QUAD_VALUE]'C' \{\
.       nr #JUSTIFY 0
.       ad c
.    \}
.    if '\\*[$QUAD_VALUE]'CENTER' \{\
.       nr #JUSTIFY 0
.       ad c
.    \}
.    if '\\*[$QUAD_VALUE]'CENTRE' \{\
.       nr #JUSTIFY 0
.       ad c
.    \}
.    if '\\*[$QUAD_VALUE]'J' \{\
.       nr #JUSTIFY 1
.       ad b
.    \}
.    if '\\*[$QUAD_VALUE]'JUSTIFY' \{\
.       nr #JUSTIFY 1
.       ad b
.    \}
.    nr #PSEUDO_FILL 0
.END
\#
\# LEFT, RIGHT, AND CENTER
\# -----------------------
\# The purpose of these macros is to allow the user to enter lines
\# of text that will be quadded LRC having to stick .BR or .br
\# between lines.  For the sake of consistency, all three appear to
\# behave similarly (from the point of view of the user), although
\# the underlying primitives don't.  For this reason, LEFT, RIGHT,
\# and CENTER must be followed by .QUAD [L R C J] or .JUSTIFY to
\# restore text to fill mode.
\#
\# LEFT
\# ----
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill mode off.  Allows user to quad lines left without
\#   requiring the .BR or .br macro.
\# *Notes:
\#   LEFT simply turns fill off.  Lines that exceed the current LL
\#   will not be broken.  Note that this behaviour differs from the
\#   RIGHT and CENTER macros.
\#
.MAC LEFT END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       rr #QUAD
.       ds $RESTORE_QUAD_VALUE LEFT
.    \}
.    ce 0
.    nf
.    nr #PSEUDO_FILL 1
.\" Fix for a little conflict with DOCTYPE LETTER
.    if '\\n[.z]'LETTERHEAD1' .rr #DATE_FIRST
.END
\#
\# RIGHT
\# -----
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill on.  Allows user to quad lines right without
\#   requiring the .BR or .br macro.
\# *Notes:
\#   Lines that exceed the current LL will be broken, with the excess
\#   text quadded right.
\#
.MAC RIGHT END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       rr #QUAD
.       ds $RESTORE_QUAD_VALUE RIGHT
.    \}
.    nf
.    rj 100000
.    nr #PSEUDO_FILL 1
.END
\#
\# CENTER
\# ------
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill on.  Allows user to center lines without
\#   requiring the .BR or .br macro.
\# *Notes:
\#   Lines that exceed the current LL will be broken, with the excess
\#   text centered.
\#
.MAC CENTER END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       rr #QUAD
.       ds $RESTORE_QUAD_VALUE CENTER
.    \}
.    nf
.    ce 100000
.    nr #PSEUDO_FILL 1
.END
\#
\# =====================================================================
\#
\# +++TABS+++
\#
\# There are two different kinds of tabs: typesetting tabs and
\# string tabs.
\#
\# Typesetting tabs are set with TAB_SET, which requires a tab number,
\# an indent (offset) from the left margin and a length (optionally
\# with a quad direction and an instruction to fill lines).  After tabs
\# are set with TAB_SET, they are called with .TAB n, where "n"
\# corresponds to the number passed to TAB_SET as a valid tab number.
\#
\# String tabs allow the user to mark off tab positions inline.  Tab
\# indents and lengths are calculated from the beginning and end
\# positions of the marks.  Up to 19 string tabs may be created,
\# numbered 1-19.  Once created, they are called with .TAB n,
\# just like typesetting tabs.
\#
\# Setting up string tabs is a two-step procedure.  First, the user
\# enters an input line in which s/he wants to mark off string tabs.
\# The beginning of a tab is marked with \*[STn], where "n" is
\# the desired number of the tab.  The end of the the tab is marked
\# with \*[STnX].  All ST's must have a matching STX.  String tabs
\# may be nested.
\#
\# Next, the user invokes .ST n for every string tab defined, and
\# optionally passes quad information to it.  That done, string tabs
\# can be called just like typesetting tabs.
\#
\# Strings for string tab inlines
\# ------------------------------
\# Initialize string tab markers numbered 1 to 19.
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<20 \{\
.   ds ST\n[#LOOP] \Ek[#ST\n[#LOOP]_OFFSET]
.\}
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<20 \{\
.   ds ST\n[#LOOP]X \Ek[#ST\n[#LOOP]_MARK]
.\}
.rr #LOOP
\#
\# These are reserved ST numbers for internal use
.ds ST100  \Ek[#ST100_OFFSET]
.ds ST100X \Ek[#ST100_MARK]
.ds ST101  \Ek[#ST101_OFFSET]
.ds ST101X \Ek[#ST101_MARK]
.ds ST102  \Ek[#ST102_OFFSET]
.ds ST102X \Ek[#ST102_MARK]
.ds ST103  \Ek[#ST103_OFFSET]
.ds ST103X \Ek[#ST103_MARK]
\#
\# QUAD AND SET STRING TABS
\# ------------------------
\# *Arguments:
\#   <stringtab number>  L | R | C | J  [QUAD]
\# *Function:
\#   Creates strings $ST<#>_QUAD_DIR and $ST<#>_FILL, then sets up a
\#   tab based on the collected information.
\# *Notes:
\#   Like TAB_SET, ST invoked without a quad direction will default to LEFT.
\#   If lines should be filled and quadded, use the optional argument QUAD.
\#   N.B. -- indents *must* be turned off before setting string tabs
\#   inside .PAD
\#
.MAC ST END
.    ds $ST\\$1_QUAD_DIR \\$2
.    if \\n[#NUM_ARGS]=3 .ds $ST\\$1_FILL QUAD
.    nr #ST\\$1_LENGTH \\n[#ST\\$1_MARK]-\\n[#ST\\$1_OFFSET]
.    ie \\n[#IN_TAB] \
.       TAB_SET \\$1 \\n[#ST\\$1_OFFSET]u+\\n[#ST_OFFSET]u \
          \\n[#ST\\$1_LENGTH]u \\*[$ST\\$1_QUAD_DIR] \\*[$ST\\$1_FILL]
.    el \
.       TAB_SET \\$1 \\n[#ST\\$1_OFFSET]u \\n[#ST\\$1_LENGTH]u \
          \\*[$ST\\$1_QUAD_DIR] \\*[$ST\\$1_FILL]
.END
\#
\# TAB SET
\# -------
\# *Arguments:
\#   <n>  ident(ipPcm)  length(ipPcm)  [L | R | C | J [QUAD]]
\# *Function:
\#   Creates macros TABn and TAB n, where "n" is any arbitrary number.
\#   TABn is a typesetting tab (i.e. a tab defined as an indent
\#   from the page left offset plus a line length.)
\# *Notes:
\#   n      = arbitrary digit to identify the tab
\#   indent = indent from left margin; unit of measure required
\#   length = length of tab (unit of measure required; can be
\#            \w'<string>'u--if more than one word in string, surround
\#            with double quotes "\w'<three word string>'"
\#   LRCJ   = quad for tab (left, right, center, justified)
\#            If option QUAD afterwards is not given, quad is line for line
\#            (no fill mode), meaning that there's no need for .BR or .br
\#            between lines.
\#   QUAD   = fill tab (so it behaves as if .QUAD LRC or .JUSTIFY
\#            had been given).
\#
\#   N.B. -- indents *must* be turned off before setting tabs
\#
\# Tabs are not columnar in behaviour.  .TN and \*[TB+] permit
\# bottom-line to bottom-line tab movement.
\#
\# When resetting tabs, .TQ must be invoked before .TAB_SET.
\#
\# Indents are turned off automatically whenever a new tab is called
\# with TAB <n>.
\#
\# Generally, it's a good idea to make sure all indents are off
\# before setting tabs.
\#
.MAC TAB_SET END
.    br
.    nr #TAB_NUMBER \\$1
.    ds $CURRENT_TAB \\n[#TAB_NUMBER]
.    nr #TAB_OFFSET (\\$2)
.    nr #TAB_LENGTH (\\$3)
.    MAC TAB\\n[#TAB_NUMBER]
.        if !\\\\n[#TB+]=1 .br
.        if \\\\n[#TB+]=1 \{\
.           EL
.           vpt 0
.           rr #TB+
.        \}
.        in 0
.        nr #TAB_ACTIVE 1
.        nr #CURRENT_TAB \\n[#TAB_NUMBER]
.        ds $CURRENT_TAB \\*[$CURRENT_TAB]
.        nr #TAB_OFFSET\\*[$CURRENT_TAB] \\n[#TAB_OFFSET]
.        nr #ST_OFFSET \\n[#TAB_OFFSET]
.        ie !'\\\\n[.z]'' \
\!.         po \\\\n[#L_MARGIN]u+\\\\n[#TAB_OFFSET\\\\*[$CURRENT_TAB]]u
.        el \
.           po \\\\n[#L_MARGIN]u+\\\\n[#TAB_OFFSET\\\\*[$CURRENT_TAB]]u
.        ll \\n[#TAB_LENGTH]u
.        ta \En[.l]u
.        ie '\\$5'QUAD' \{\
.           if '\\$4'L' .QUAD L
.           if '\\$4'R' .QUAD R
.           if '\\$4'C' .QUAD C
.           if '\\$4'J' .JUSTIFY
.        \}
.        el \{\
.           if '\\$4''  .LEFT
.           if '\\$4'L' .LEFT
.           if '\\$4'R' .RIGHT
.           if '\\$4'C' .CENTER
.           if '\\$4'J' .JUSTIFY
.        \}
.        if \\\\n[#TN]=1 \{\
.           TRAP
.           rr #TN
.        \}
..
.    rr #TAB_ACTIVE
.END
\#
\# TAB
\# ---
\# *Arguments:
\#   <tab number to tab into>
\# *Function:
\#   Moves to tab number passed as an argument.
\#
.MAC TAB END
.    ds $TAB_NUMBER \\$1
.    TAB\\*[$TAB_NUMBER]
.    nr #IN_TAB 1
.END
\#
\# TAB NEXT
\# --------
\# *Argument:
\#   <none>
\# *Function:
\#   Automagically moves to TAB<n+1> on the same line as the last
\#   line of the previous tab.
\# *Notes:
\#   The \c inline must be appended to the end of input lines when in
\#   nofill mode; in fill modes, the \c inline must not be used.
\#
.MAC TN END
.    nr #TN 1
.    TRAP OFF
.    sp -1v
.    nr #NEXT_TAB \\n[#CURRENT_TAB]+1
.    TAB\\n[#NEXT_TAB]
.    TRAP
.END
\#
\# An inline escape to accomplish the same thing.  Preferable, since
\# it works with filled and non-filled copy and doesn't require the
\# user to remember to use (or not use) the \c.
\#
.ds TB+ \
"\c\R'#TB+ 1'\R'#TN 1'\R'#NEXT_TAB \\n[#CURRENT_TAB]+1'\\*[TAB\\n[#NEXT_TAB]]\c
\#
\# TAB QUIT
\# --------
\# *Argument:
\#   <none>
\# *Function:
\#   Sets #TAB_ACTIVE to "0" (off).
\#   Resets left margin to value in effect prior to tabs.
\#   Resets line length to value in effect prior to tabs.
\#   Checks #QUAD to see if we were in flush or quad mode
\#   prior to tabs (0=off, 1=on).
\#   Resets QUAD [ L|R|C ], LEFT, RIGHT, CENTER, or JUSTIFY
\#   in effect prior to tabs.
\# *Notes:
\#   TQ must precede setting new tabs to get the tabs' indents
\#   measured from page left.  Otherwise, the tabs' indents are
\#   measured from the left margin of the currently active tab.
\#
.MAC TQ END
.    br
.    rr #TAB_ACTIVE
.    rr #IN_TAB
.    nr #LOOP 0 1
.    while \\n+[#LOOP]<20 \{\
.       rm $ST\\n[#LOOP]_FILL
.    \}
.    rr #LOOP
.    po \\n[#L_MARGIN]u
.    ll \\n[#L_LENGTH]u
.    ta \\n[.l]u
.    ie \\n[#QUAD] \{\
.       ie '\\*[$RESTORE_QUAD_VALUE]'J' .JUSTIFY
.       el .QUAD \\*[$RESTORE_QUAD_VALUE]
.    \}
.    el \{\
.       if '\\*[$RESTORE_QUAD_VALUE]'LEFT' .LEFT
.       if '\\*[$RESTORE_QUAD_VALUE]'RIGHT' .RIGHT
.       if '\\*[$RESTORE_QUAD_VALUE]'CENTER' .CENTER
.    \}
.END
\#
\# ====================================================================
\#
\# COLOR HANDLING
\# ==============
\#
\# COLOR
\# -----
\# *Arguments:
\#   <pre-defined NEWCOLOR or XCOLOR>
\# *Function:
\#   Allows the inline escape for setting color to be called
\#   as a macro.
\#
.MAC COLOR END
.    ie \\n[.u]=1 \{\
\c
\\*[\\$1]\c
.    \}
.    el \\*[\\$1]
.END
\#
\# NEWCOLOR
\# --------
\# *Arguments:
\#   <color name> [<color scheme>] <color definition>
\# *Function:
\#   Based on .defcolor, allows users to name and define colors using
\#   one of the four color schemes rgb, cmy, cmyk and grey.  The new
\#   color is then defined as a string so that it can be called inline
\#   with \*[COLORNAME] or with .COLOR.
\# *Notes:
\#   With only two args, the default color scheme is rgb.
\#
\#   It is highly recommended that users define new colors as
\#   all-cap strings, to differentiate them from x colors, which must
\#   be in lower case.
\#
.MAC NEWCOLOR END
.    if \\n[#NUM_ARGS]=2 .defcolor \\$1 rgb \\$2
.    if \\n[#NUM_ARGS]=3 \{\
.       if '\\$2'RGB' .ds $COLOR_SCHEME rgb
.       if '\\$2'CYM' .ds $COLOR_SCHEME cym
.       if '\\$2'CMYK' .ds $COLOR_SCHEME cmyk
.       if '\\$2'GRAY' .ds $COLOR_SCHEME gray
.       if '\\$2'GREY' .ds $COLOR_SCHEME gray
.       defcolor \\$1  \\*[$COLOR_SCHEME] \\$3
.    \}
.    ds \\$1 \\m[\\$1]
.END
\#
\# XCOLOR
\# ------
\# *Arguments:
\#   <x color name> [<alias>]
\# *Function:
\#   Defines a string of x color name (i.e. a predefined x
\#   color).  If <alias> is given, creates a string of <alias name>
\#   that references the x color name of the first argument.
\# *Notes:
\#   The color name must be a valid color name from rgb.txt, and
\#   must be given entirely in lower case, all one word.
\#
.MAC XCOLOR END
.    ds \\$1 \m[\\$1]
.    if \\n[#NUM_ARGS]=2 \{\
.       ds \\$2 \m[\\$1]
.       ds $\\$2_FILL \\$1
.       ds COLAL_\\$2 \\$1
.    \}
.END
\#
\# Pre-define xcolors black and white
\#
.ds black \m[black]
.ds BLACK \m[black]
.ds white \m[white]
.ds WHITE \m[WHITE]
\#
\# =====================================================================
\#
\# +++MISCELLANEOUS USEFUL MACROS AND STRINGS+++
\#
\# UNDERLINE
\# ---------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Simulates typewriter-style underlining of italic passages.
\# *Notes:
\#   Defaults for rule weight and distance from baseline are below.
\#   UNDERLINE_SPECS lets user change them
\#
.nr _w 500
.nr _d 1250
\#
.MAC UNDERLINE_SPECS END
.    ie \B'\\$1' .nr _w (u;\\$1)
.    el \{\
.       ie '\\$1'DEFAULT' .nr _w 500
.       el \{\
.          nr _w 500
.          tm1 "[mom]: The first argument to \\$0 must be a numeric
.          tm1 "       argument with a unit of measure appended, or DEFAULT.
.          tm1 "       Setting underline weight to DEFAULT.
.       \}
.    \}
.    shift
.    ie \B'\\$1' .nr _d (u;\\$1)
.    el \{\
.       ie '\\$1'DEFAULT' .nr _d 1250
.       el \{\
.          nr _d 1250
.          tm1 "[mom]: The second argument to \\$0 must be a numeric
.          tm1 "       argument with a unit of measure appended, or DEFAULT.
.          tm1 "       Setting underline distance from baseline to DEFAULT.
.       \}
.    \}
.END
\#
.MAC UNDERLINE END
\c
.    ds $SAVED_SS_VAR \\*[$SS_VAR]
.    ie '\\$1'' \{\
.       nr #UNDERLINE_ON 1
.       ss \\n[.ss] (\\n[.ss]-\\n[.ss])
.       ie !n .nop \X'ps: exec \\n[_w] \\n[_d] decorline'\c
.       el .ul 1000
.    \}
.    el \{\
.       nr #UNDERLINE_ON 0
.       SS \\*[$SAVED_SS_VAR]
.       ie !n .nop \X'ps: exec decornone'\c
.       el .ul 0
.    \}
.END
\#
\# UL/ULX
\# ------
\# *Arguments:
\#   <none>
\# *Function:
\#   Simulates typewriter-style underlining of italic passages.
\# *Notes:
\#   Intended to be called with inline escapes \*[UL] (underline
\#   on) and \*[ULX] (underline off).
\#
.MAC UL END
\c
.    ds $SAVED_SS_VAR \\*[$SS_VAR]
.    ss \\n[.ss] (\\n[.ss]-\\n[.ss])
.    ie !'\\n[.z]'' \{\
\c
.       ie !n \{\
.          if !\\n[.k]=0 \?\h'-\w'\\n[.ss]'u'\?
\?\R'#UNDERLINE_ON 1'\X'ps: exec \\n[_w] \\n[_d] decorline'\?\c
.       \}
.       el \{\
\?\R'#UNDERLINE_ON 1'\?\c
.          ul 1000
.       \}
.    \}
.    el \{\
.       ie !n \{\
.          nr #UNDERLINE_ON 1
.          nop \X'ps: exec \\n[_w] \\n[_d] decorline'\c
.       \}
.       el \{\
\R'#UNDERLINE_ON 1'\c
.          ul 1000
.       \}
.    \}
.END
\#
.MAC ULX END
\c
.    SS \\*[$SAVED_SS_VAR]
.    rm $SAVED_SS_VAR
.    ie !'\\n[.z]'' \{\
\c
.       ie !n \{\
\?\R'#UNDERLINE_ON 0'\X'ps: exec decornone'\?\c
.       \}
.       el \{\
\?\R'#UNDERLINE_ON 0'\?\c
.          ul 0
.       \}
.    \}
.    el \{\
.       ie !n \{\
.          nr #UNDERLINE_ON 0
.          nop \X'ps: exec decornone'\c
.       \}
.       el \{\
.          nr #UNDERLINE_ON 0
.          ul 0
.       \}
.    \}
.END
\#
\# UNDERSCORE
\# ----------
\# *Arguments:
\#   [<points below baseline>] "text"
\# *Function:
\#   Places an underscore 2 points under the string if no lead given,
\#   otherwise places underscore under string by user specified amount.
\# *Notes:
\#   When using this macro, the string to be underscored must begin
\#   with double-quotes ("), regardless of whether it's the sole
\#   argument or the second.
\#   E.g.:
\#      .UNDERSCORE "Text to be underscored
\#         or
\#      .UNDERSCORE 2p "Text to be underscored
\#
\#   UNDERSCORE does not work across line breaks.  Each line of text
\#   must be entered separately.  If the UNDERSCORE begins in the
\#   middle of a line and crosses over a break, the portion before
\#   the break and the portion afterwards must be entered
\#   separately.
\#
.MAC UNDERSCORE END
.    nr #SAVED_UNDERSCORE_WEIGHT     \\n[#UNDERSCORE_WEIGHT]
.    nr #SAVED_UNDERSCORE_WEIGHT_ADJ \\n[#UNDERSCORE_WEIGHT_ADJ]
.    ds $SAVED_UNDERSCORE_GAP        \\*[$UNDERSCORE_GAP]
.    if \\n[#FROM_BIB_STRING]=1 \{\
.       nr #UNDERSCORE_WEIGHT        \\n[#BIB_STRING_UNDERLINE_WEIGHT]
.       nr #UNDERSCORE_WEIGHT_ADJ    \\n[#BIB_STRING_UNDERLINE_WEIGHT_ADJ]
.       ds $UNDERSCORE_GAP           \\*[$BIB_STRING_UNDERLINE_GAP]
.    \}
.    if \\n[#FROM_COVER]=1 \{\
.       nr #UNDERSCORE_WEIGHT        \\n[#COVER_UNDERLINE_WEIGHT]
.       nr #UNDERSCORE_WEIGHT_ADJ    \\n[#COVER_UNDERLINE_WEIGHT_ADJ]
.       ds $UNDERSCORE_GAP           \\*[$COVER_UNDERLINE_GAP]
.    \}
.    if \\n[#FROM_DOC_COVER]=1 \{\
.       nr #UNDERSCORE_WEIGHT        \\n[#DOC_COVER_UNDERLINE_WEIGHT]
.       nr #UNDERSCORE_WEIGHT_ADJ    \\n[#DOC_COVER_UNDERLINE_WEIGHT_ADJ]
.       ds $UNDERSCORE_GAP           \\*[$DOC_COVER_UNDERLINE_GAP]
.    \}
.    if \\n[#FROM_DOCTYPE]=1 \{\
.       nr #UNDERSCORE_WEIGHT        \\n[#DOCTYPE_UNDERLINE_WEIGHT]
.       nr #UNDERSCORE_WEIGHT_ADJ    \\n[#DOCTYPE_UNDERLINE_WEIGHT_ADJ]
.       ds $UNDERSCORE_GAP           \\*[$DOCTYPE_UNDERLINE_GAP]
.    \}
.    if \\n[#FROM_EN_STRING]=1 \{\
.       nr #UNDERSCORE_WEIGHT        \\n[#EN_STRING_UNDERLINE_WEIGHT]
.       nr #UNDERSCORE_WEIGHT_ADJ    \\n[#EN_STRING_UNDERLINE_WEIGHT_ADJ]
.       ds $UNDERSCORE_GAP           \\*[$EN_STRING_UNDERLINE_GAP]
.    \}
.    if \\n[#FROM_EN_TITLE]=1 \{\
.       nr #UNDERSCORE_WEIGHT        \\n[#EN_TITLE_UNDERLINE_WEIGHT]
.       nr #UNDERSCORE_WEIGHT_ADJ    \\n[#EN_TITLE_UNDERLINE_WEIGHT_ADJ]
.       ds $UNDERSCORE_GAP           \\*[$EN_TITLE_UNDERLINE_GAP]
.    \}
.    ie \\n[#NUM_ARGS]=1 \{\
.       nr #TEXT_WIDTH \w'\\$1'
\\$1\
\D't \\n[#UNDERSCORE_WEIGHT]'\
\h'-\\n[#TEXT_WIDTH]u-\\n[#UNDERSCORE_WEIGHT]u'\
\v'+(\\*[$UNDERSCORE_GAP])+\\n[#UNDERSCORE_WEIGHT_ADJ]u'\
\D'l \\n[#TEXT_WIDTH]u 0'\
\D't \\n[#RULE_WEIGHT]'\
\h'-\\n[#RULE_WEIGHT]u'\
\v'-(\\*[$UNDERSCORE_GAP])-\\n[#UNDERSCORE_WEIGHT_ADJ]u'
.    \}
.    el \{\
.       nr #TEXT_WIDTH \w'\\$2'
\\$2\
\h'-\\n[#TEXT_WIDTH]u-\\n[#UNDERSCORE_WEIGHT]u'\
\v'+(\\$1)+\\n[#UNDERSCORE_WEIGHT_ADJ]u'\
\D't \\n[#UNDERSCORE_WEIGHT]'\
\D'l \\n[#TEXT_WIDTH]u 0'\
\D't \\n[#RULE_WEIGHT]'\
\h'-\\n[#RULE_WEIGHT]u'\
\v'-(\\$1)-\\n[#UNDERSCORE_WEIGHT_ADJ]u'
.    \}
.    nr #UNDERSCORE_WEIGHT     \\n[#SAVED_UNDERSCORE_WEIGHT]
.    nr #UNDERSCORE_WEIGHT_ADJ \\n[#SAVED_UNDERSCORE_WEIGHT_ADJ]
.    ds $UNDERSCORE_GAP        \\*[$SAVED_UNDERSCORE_GAP]
.    rr #SAVED_UNDERSCORE_WEIGHT
.    rr #SAVED_UNDERSCORE_WEIGHT_ADJ
.    rm $SAVED_UNDERSCORE_GAP
.END
\#
\# DOUBLE UNDERSCORE
\# -----------------
\# *Arguments:
\#   [points below baseline] [points distance between rules] "text"
\# *Function:
\#   Same as UNDERSCORE, except it produces a double underscore.  The default
\#   distance between the rules is 2 points.
\# *Notes:
\#   The same double-quote requirement as UNDERSCORE.
\#
.MAC UNDERSCORE2 END
.    nr #SAVED_UNDERSCORE_WEIGHT     \\n[#UNDERSCORE_WEIGHT]
.    nr #SAVED_UNDERSCORE_WEIGHT_ADJ \\n[#UNDERSCORE_WEIGHT_ADJ]
.    ds $SAVED_UNDERSCORE_GAP        \\*[$UNDERSCORE_GAP]
.    ds $SAVED_RULE_GAP              \\*[$RULE_GAP]
.    if \\n[#NUM_ARGS]=2 \{\
.       ds $UNDERSCORE_GAP \\$1
.    \}
.    if \\n[#NUM_ARGS]=3 \{\
.       ds $UNDERSCORE_GAP \\$1
.       ds $RULE_GAP \\$2
.    \}
.    if \\n[#FROM_BIB_STRING] \{\
.       nr #UNDERSCORE_WEIGHT        \\n[#BIB_STRING_UNDERLINE_WEIGHT]
.       nr #UNDERSCORE_WEIGHT_ADJ    \\n[#BIB_STRING_UNDERLINE_WEIGHT_ADJ]
.       ds $UNDERSCORE_GAP           \\*[$BIB_STRING_UNDERLINE_GAP]
.       ds $RULE_GAP                 \\*[$BIB_STRING_RULE_GAP]
.    \}
.    if \\n[#FROM_EN_STRING] \{\
.       nr #UNDERSCORE_WEIGHT        \\n[#EN_STRING_UNDERLINE_WEIGHT]
.       nr #UNDERSCORE_WEIGHT_ADJ    \\n[#EN_STRING_UNDERLINE_WEIGHT_ADJ]
.       ds $UNDERSCORE_GAP           \\*[$EN_STRING_UNDERLINE_GAP]
.       ds $RULE_GAP                 \\*[$EN_STRING_RULE_GAP]
.    \}
.    if \\n[#NUM_ARGS]=1 \{\
.       nr #TEXT_WIDTH \w'\\$1'
\\$1\
\D't \\n[#UNDERSCORE_WEIGHT]'\
\v'+\\*[$UNDERSCORE_GAP]+\\n[#UNDERSCORE_WEIGHT_ADJ]u'\
\h'-\\n[#TEXT_WIDTH]u-\\n[#UNDERSCORE_WEIGHT]u'\
\D'l \\n[#TEXT_WIDTH]u 0'\
\v'+\\*[$RULE_GAP]+\\n[#UNDERSCORE_WEIGHT]u'\
\h'-\\n[#TEXT_WIDTH]u'\
\D'l \\n[#TEXT_WIDTH]u 0'\
\D't \\n[#RULE_WEIGHT]'\
\h'-\\n[#RULE_WEIGHT]u'\
\v'-(\\*[$UNDERSCORE_GAP]+\\*[$RULE_GAP])-(\\n[#UNDERSCORE_WEIGHT]u*2u)'
.    \}
.    if \\n[#NUM_ARGS]=2 \{\
.       nr #TEXT_WIDTH \w'\\$2'
\\$2\
\D't \\n[#UNDERSCORE_WEIGHT]'\
\v'+\\*[$UNDERSCORE_GAP]+\\n[#UNDERSCORE_WEIGHT_ADJ]u'\
\h'-\\n[#TEXT_WIDTH]u-\\n[#UNDERSCORE_WEIGHT]u'\
\D'l \\n[#TEXT_WIDTH]u 0'\
\v'+(\\*[$RULE_GAP])+\\n[#UNDERSCORE_WEIGHT]u'\
\h'-\\n[#TEXT_WIDTH]u'\
\D'l \\n[#TEXT_WIDTH]u 0'\
\D't \\n[#RULE_WEIGHT]'\
\h'-\\n[#RULE_WEIGHT]u'\
\v'-(\\*[$UNDERSCORE_GAP]+\\*[$RULE_GAP])+(\\n[#UNDERSCORE_WEIGHT]u*2u)'
.    \}
.    if \\n[#NUM_ARGS]=3 \{\
.       nr #TEXT_WIDTH \w'\\$3'
\\$3\
\D't \\n[#UNDERSCORE_WEIGHT]'\
\v'+\\*[$UNDERSCORE_GAP]+\\n[#UNDERSCORE_WEIGHT_ADJ]u'\
\h'-\\n[#TEXT_WIDTH]u-\\n[#UNDERSCORE_WEIGHT]u'\
\D'l \\n[#TEXT_WIDTH]u 0'\
\v'+\\*[$RULE_GAP]+\\n[#UNDERSCORE_WEIGHT]u'\
\h'-\\n[#TEXT_WIDTH]u'\
\D'l \\n[#TEXT_WIDTH]u 0'\
\D't \\n[#RULE_WEIGHT]'\
\h'-\\n[#RULE_WEIGHT]u'\
\v'-(\\*[$UNDERSCORE_GAP]+\\*[$RULE_GAP])-(\\n[#UNDERSCORE_WEIGHT]u*2u)'
.    \}
.    nr #UNDERSCORE_WEIGHT     \\n[#SAVED_UNDERSCORE_WEIGHT]
.    nr #UNDERSCORE_WEIGHT_ADJ \\n[#SAVED_UNDERSCORE_WEIGHT_ADJ]
.    ds $UNDERSCORE_GAP        \\*[$SAVED_UNDERSCORE_GAP]
.    rr #SAVED_UNDERSCORE_WEIGHT
.    rr #SAVED_UNDERSCORE_WEIGHT_ADJ
.    rm $SAVED_UNDERSCORE_GAP
.    rm $SAVED_RULE_GAP
.END
\#
\# Default underscoring rule gaps
\#
.ds $BIB_STRING_UNDERLINE_GAP 2p
.ds $BIB_STRING_RULE_GAP      2p
.ds $COVER_UNDERLINE_GAP      2p
.ds $DOC_COVER_UNDERLINE_GAP  2p
.ds $DOCTYPE_UNDERLINE_GAP    2p
.ds $EN_STRING_UNDERLINE_GAP  2p
.ds $EN_STRING_RULE_GAP       2p
.ds $EN_TITLE_UNDERLINE_GAP   2p
.ds $RULE_GAP                 2p
.ds $UNDERSCORE_GAP           2p
\#
\# SUPERSCRIPT
\# -----------
\# *Function:
\#   Prints everything after inline invocation as superscript.
\# *Notes:
\#   \*[SUP] and \*[SUPX] turn superscript on and off respectively.
\#   If running type is pseudo-condensed/expanded, invoke the superscript
\#   strings as \*[CONDSUP] or \*[EXTSUP] and turn off with \*[CONDSUPX]
\#   and \*[EXTSUPX] respectively.
\#
\# Default raise/lower amount
.ds $SUP_RAISE \v'-.3m'
.ds $SUP_LOWER \v'.3m'
\#
\# SUPERSCRIPT RAISE
\# -----------------
\# *Argument:
\#   <amount to raise superscript>
\# *Function:
\#   Defines strings $SUP_RAISE and $SUP_LOWER for use with \*[SUP],
\#   \*[CONDSUP] and \*[EXTSUP].
\#
.MAC SUPERSCRIPT_RAISE_AMOUNT END
.    ds $SUP_RAISE_AMOUNT \\$1
.    ds $SUP_RAISE \v'-\\*[$SUP_RAISE_AMOUNT]'
.    ds $SUP_LOWER \v'\\*[$SUP_RAISE_AMOUNT]'
.END
\#
.ds SUP \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#SUP_PT_SIZE \En[#PT_SIZE_IN_UNITS]u*6u/10u'\
\s[\En[#PT_SIZE_IN_UNITS]u]\E*[$SUP_RAISE]\s[\En[#SUP_PT_SIZE]u]
\#
.ds SUPX \s[\En[#PT_SIZE_IN_UNITS]u]\E*[$SUP_LOWER]
\#
.ds CONDSUP \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#SUP_PT_SIZE \En[#PT_SIZE_IN_UNITS]u*6u/10u'\
\s[\En[#PT_SIZE_IN_UNITS]u]\E*[$SUP_RAISE]\s[\En[#SUP_PT_SIZE]u]\E*[COND_FOR_SUP]
\#
.ds CONDSUPX \s[\En[#PT_SIZE_IN_UNITS]u]\E*[$SUP_LOWER]\E*[COND]
\#
.ds EXTSUP \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#SUP_PT_SIZE \En[#PT_SIZE_IN_UNITS]u*6u/10u'\
\s[\En[#PT_SIZE_IN_UNITS]u]\E*[$SUP_RAISE]\s[\En[#SUP_PT_SIZE]u]\E*[EXT_FOR_SUP]
\#
.ds EXTSUPX \s[\En[#PT_SIZE_IN_UNITS]u]\E*[$SUP_LOWER]\E*[EXT]
\#
\# SLANT
\# -----
\#
\# SETSLANT
\# --------
\# *Arguments:
\#   <number of degrees> | RESET
\# *Function:
\#   Modifies register #DEGREES for use with \*[SLANT], or resets
\#   it to the default.  Defines string \*[SLANTX]
\# *Notes:
\#   \*[SLANT] permits pseudo-italicizing of a font in cases where
\#   no italic font exists in a particular family.
\#
\#   Default # of degrees is 15.
\#
\#   Do not use unit of measure with arg to SETSLANT.
\#
\#   It may be necessary to adjust the spacing on either side of
\#   [SLANT] and [SLANTX].
\#
\#   In docs, SLANT carries over from para to para.
\#
.nr #DEGREES 15
.ds SLANT \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.ds SLANTX \ER'#SLANT_ON 0'\ES'0'
\#
.MAC SETSLANT END
.    ie '\\$1'RESET' \{\
.       nr #DEGREES 15
.       if \\n[#PRINT_STYLE]=1 \
.          if \\n[#UNDERLINE_SLANT] .return
.       ds SLANT \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.    \}
.    el \{\
.       nr #DEGREES \\$1
.       if \\n[#PRINT_STYLE]=1 \
.          if \\n[#UNDERLINE_SLANT] .return
.       ds SLANT \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.    \}
.    ds SLANTX \ER'#SLANT_ON 0'\ES'0'
.END
\#
\# BOLDER
\# ------
\#
\# SETBOLDER
\# ---------
\# *Arguments:
\#   <amount of emboldening> | RESET
\# *Function:
\#   Modifies register #BOLDER_UNITS for use with \*[BOLDER], or resets
\#   it to the default 700 units.
\# *Notes:
\#   \*[BOLDER] allows pseudo-emboldening of a font where no bold
\#   font exists in a particular family.
\#
\#   Default for SETBOLDER is 700 units.  Do not use unit of measure
\#   with arg to SETBOLDER.
\#
.nr #BOLDER_UNITS 700
\#
.MAC SETBOLDER END
.    if \\n[#IGNORE]=1 .return
.    ie '\\$1'RESET' .nr #BOLDER_UNITS 700
.    el              .nr #BOLDER_UNITS \\$1
.END
\#
.MAC BOLDER END
\c
.bd \\n[.f] \\n[#BOLDER_UNITS]
.END
\#
.MAC BOLDERX END
\c
.bd \\n[.f]
.END
\#
\# +++CONDENSE/EXTEND+++
\#
\# CONDENSE/EXTEND
\# ---------------
\# *Arguments:
\#   <percentage to condense/expand type size>
\# *Function:
\#   Stores current point size in z's in #PT_SIZE_IN_UNITS, figures out
\#   new point size (for character width) from arg, and defines string
\#   COND or EXT, which set the type size to the new character width,
\#   and sets the height of type to the value stored in CURRENT_PT_SIZE
\# *Notes:
\#   CONDENSE_OR_EXTEND is invoked from the aliases
\#   CONDENSE and EXTEND.  CONDENSE implies <100, EXTEND
\#   implies >100.  Do not use a percent sign in the argument.
\#
\#   There is no default setting for CONDENSE or EXTEND.
\#   80 is a good approximation of condensed type, 120 is okay
\#   for extended.
\#
\#   The value set by CONDENSE or EXTEND applies to all
\#   subsequent \*[COND] or \*[EXT] escapes until a new value is set.
\#
\#  \*[COND] or \*[EXT] must be turned off before all changes of point
\#  size, and reinvoked afterwards (if so desired).  This refers to
\#  changes of point size via control lines AND via inlines.
\#
.MAC CONDENSE_OR_EXTEND END
.    if '\\$0'CONDENSE' \{\
.       ds $COND_PERCENT \\$1
.       if \\n[#PRINT_STYLE]=1 \{\
.          rm $COND_PERCENT
.          ds $COND_PERCENT 100
.       \}
.       ds COND \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#CONDENSE 1'\
\R'#COND_WIDTH (\En[#PT_SIZE_IN_UNITS]u*\E*[$COND_PERCENT]u)/100'\
\Es[\En[#COND_WIDTH]u]\EH'\En[#PT_SIZE_IN_UNITS]u'
.       ds COND_FOR_SUP \
\R'#COND_WIDTH (\En[#SUP_PT_SIZE]u*\E*[$COND_PERCENT]u)/100'\
\Es[\En[#COND_WIDTH]u]\H'\En[#SUP_PT_SIZE]u'
.    \}
.    if '\\$0'EXTEND' \{\
.       ds $EXT_PERCENT \\$1
.       if \\n[#PRINT_STYLE]=1 \{\
.          rm $EXT_PERCENT
.          ds $EXT_PERCENT 100
.       \}
.       ds EXT \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#EXTEND 1'\
\R'#EXT_WIDTH (\En[#PT_SIZE_IN_UNITS]u*\E*[$EXT_PERCENT]u)/100'\
\Es[\En[#EXT_WIDTH]u]\EH'\En[#PT_SIZE_IN_UNITS]u'
.       ds EXT_FOR_SUP \
\R'#EXT_WIDTH (\En[#SUP_PT_SIZE]u*\E*[$EXT_PERCENT]u)/100'\
\Es[\En[#EXT_WIDTH]u]\H'\En[#EXT_PT_SIZE]u'
.    \}
.END
\#
.ds CONDX \
\ER'#CONDENSE 0'\Es[0]\R'#PT_SIZE_IN_UNITS \En[.ps]'\H'\En[#PT_SIZE_IN_UNITS]u'
.ds EXTX  \
\ER'#EXTEND   0'\Es[0]\R'#PT_SIZE_IN_UNITS \En[.ps]'\H'\En[#PT_SIZE_IN_UNITS]u'
\#
\# +++PAD LINES+++ (insert space)
\#
\# PAD MARKER
\# ----------
\# *Arguments:
\#   <character to use for marking pad points>
\# *Function:
\#   Defines string $PAD_MARKER, used in PAD
\# *Notes:
\#   $PAD_MARKER is normally # (the pound sign).
\#
.MAC PAD_MARKER END
.    ds $PAD_MARKER \\$1
.END
\#
\# PAD
\# ---
\# *Argments:
\#   "<string of text with padding markers inserted>"
\#   "<id of bookmark created by .PDF_BOOKMARK>"
\# *Function:
\#   Defines and redefines padding character (default=pound sign
\#   unless padding character has been set with PAD_MARKER)
\#   several times so that when the string is output at the end
\#   of the macro, every # has been converted to an equal-sized
\#   amount of padding (blank space) on a line.
\# *Notes:
\#   String tabs may be marked off during PAD.
\#
.MAC PAD END
.    if \\n[.u]=1 .nr fill 1
.    nf
.    if !d$PAD_MARKER .ds $PAD_MARKER #
.    char \\*[$PAD_MARKER] \R'#PAD_COUNT \En[#PAD_COUNT]+1'
.    ds $FAMILY_FOR_PAD \\n[.fam]
.\" .if !n .fp \\n[.fp] \\n[.sty]
.    ds $FONT_FOR_PAD   \\n[.sty]
.    nr #SIZE_FOR_PAD   \\n[.ps]
.    ds $PAD_STRING \\$1
.    as $PAD_STRING \Ekp
.    di PAD_STRING
.    fam \\*[$FAMILY_FOR_PAD]
\\f[\\*[$FONT_FOR_PAD]]\\s[\\n[#SIZE_FOR_PAD]u]\\*[$PAD_STRING]
.    br
.    di
.    char \\*[$PAD_MARKER] \
\R'#SPACE_TO_END \En[.l]-\En[p]'\R'#PAD_SPACE \En[#SPACE_TO_END]/\En[#PAD_COUNT]'
.    di PAD_STRING
.    fam \\*[$FAMILY_FOR_PAD]
\\f[\\*[$FONT_FOR_PAD]]\\s[\\n[#SIZE_FOR_PAD]u]\\*[$PAD_STRING]
.    br
.    di
.    char \\*[$PAD_MARKER] \h'\En[#PAD_SPACE]u'
.    if \\n[#SILENT] .SILENT
.    fam \\*[$FAMILY_FOR_PAD]
\\f[\\*[$FONT_FOR_PAD]]\\s[\\n[#SIZE_FOR_PAD]u]
.    ie '\\$2'' .nop \\*[$PAD_STRING]
.    el \{\
.       ie !'\\$2'NOBREAK' .pdfhref L -D "\\$2" -E -- \&\\*[$PAD_STRING]
.       el .nop \\*[$PAD_STRING]
.    \}
.    if \\n[#SILENT] .SILENT OFF
.    br
.    if \\n[fill] \{\
.       fi
.       rr fill
.    \}
.    rr #PAD_COUNT
.    rr #SPACE_TO_END
.    rr #PAD_SPACE
.    rm $PAD_STRING
.    rm PAD_STRING
.    rchar #
.    if '\\$2'NOBREAK' \{\
.       TRAP OFF
.       EOL
.       TRAP
.    \}
.END
\#
\# +++LEADERS+++
\#
\# The leader mechanism is primitive, but it works.  Basically, every
\# macro in this set that includes a line length also sets a single
\# groff tab stop at the right hand end of the line.  That way,
\# whenever Ctrl-A is invoked (always at the end of an input line),
\# leader of the correct length gets deposited.  Ctrl-A is accessed by
\# the string LEADER (i.e. inline, as \*[LEADER]).  Leaders within tabs
\# get their length from the tab line length.
\#
\# SET LEADER CHARACTER
\# --------------------
\# *Arguments:
\#   <character to use whenever \*[LEADER] is invoked>
\# *Function:
\#   Set leader character.
\#
.MAC LEADER_CHARACTER END
.    lc \\$1
.END
\#
.ds LEADER 
\#
\# +++DROP CAPS+++
\#
\# DROP CAP FAMILY
\# ---------------
\# *Argument:
\#   <family of drop cap>
\# *Function:
\#   Creates or modifies string $DC_FAM.
\#
.MAC DROPCAP_FAMILY END
.    ds $DC_FAM \\$1
.END
\#
\# DROP CAP FONT
\# -------------
\# *Argument:
\#   <font of drop cap>
\# *Function:
\#   Creates or modifies string $DC_FT.
\#
.MAC DROPCAP_FONT END
.    ds $DC_FT \\$1
.END
\#
\# DROPCAP COLOR
\# -------------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Defines string $DC_COLOR to argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   DC_COLOR.
\#
.MAC DROPCAP_COLOR END
.    if \\n[#PRINT_STYLE]=1 .return
.    nr #DC_COLOR 1
.    ds $DC_COLOR \\$1
.END
\#
\# DROP CAP GUTTER
\# ---------------
\# *Argument:
\#   <width of gutter between drop cap and indented text>
\# *Function:
\#   Creates or modifies register #DC_GUT.
\# *Notes:
\#   Requires unit of measure.  Default is 3p.
\#
.MAC DROPCAP_GUTTER END
.    nr #DC_GUT (\\$1)
.END
\#
\# DROP CAP ADJUST
\# ---------------
\# *Argument:
\#   <+|- # of points to in/decrease point size of drop cap letter>
\# *Function:
\#   Creates or modifies string $DC_ADJUST.
\# *Notes:
\#   Despite its best efforts, DROPCAP doesn't always get the point
\#   size of the drop cap critically perfect.  DROPCAP_ADJUST lets
\#   the user add or subtract points (or fractions of points) to
\#   get the size right.
\#
\#   Requires the + or - sign.
\#
.MAC DROPCAP_ADJUST END
.    ds $DC_ADJUST \\$1
.END
\#
\# DROP CAP
\# --------
\# *Arguments:
\#   <dropcap letter> <# of lines> [COND <% to condense> | EXT <% to extend>]
\# *Function:
\#   Calculates point size of dropcap based on # of lines passed as
\#   arg 2.  Sets indent for text based on dropcap width+gutter.
\#   Advances and prints dropcap; reverses and prints indented text
\#   to bottom of dropcap, then resets indent to left margin (plus
\#   any indent that was in effect prior to invoking DROPCAP).
\# *Notes:
\#   Drop caps when using the doc processing macro PP only work with
\#   initial paragraphs (i.e. at doc start, or after heads), only when
\#   DROPCAPS comes immediately after PP, and only when the PRINTSTYLE
\#   is TYPESET.  If these conditions aren't met, DROPCAPS is silently
\#   ignored.
\#
\#   The COND or EXT argument are processed separately from all
\#   other COND or EXT inlines or macros, hence passing COND or
\#   EXT has no effect on running type.
\#
.MAC DROPCAP END
.    if \\n[#IGNORE]=1 \{\
.       PRINT \\$1\c
.       return
.    \}
.    br
.    if n \{\
.       PRINT \\$1\c
.       return
.    \}
.    if \\n[#DOCS] \{\
.       if \\n[#PRINT_STYLE]=1 \{\
.          PRINT \\$1\c
.          return
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          if \\n[#PP_STYLE]=2 \{\
.             PRINT \\$1\c
.             return
.          \}
.          if \\n[#PP]>1 \{\
.             PRINT \\$1\c
.             return
.          \}
.          ti 0
.       \}
.    \}
.    ds $DROPCAP         \\$1
.    nr #DC_LINES        \\$2-1
.    if \\n[#CONDENSE]=1 \{\
.       ds $RESTORE_COND \\*[$COND_PERCENT]
\\*[CONDX]
.       nr #CONDENSE_WAS_ON 1
.    \}
.    if \\n[#EXTEND]=1 \{\
.       ds $RESTORE_EXT \\*[$EXT_PERCENT]
\\*[EXTX]
.       nr #EXTEND_WAS_ON 1
.    \}
.    if '\\$3'COND' .CONDENSE \\$4
.    if '\\$3'EXT' .EXTEND \\$4
.    if !r#DC_GUT .nr #DC_GUT (3p)
.    ie \\n[#DOCS] .ds $RESTORE_FAM \\*[$DOC_FAM]
.    el .ds $RESTORE_FAM \\n[.fam]
.    ie \\n[#DOCS] .ds $RESTORE_FT  \\*[$PP_FT]
.    el .ds $RESTORE_FT  \\*[$FONT]
.    nr #RESTORE_PT_SIZE \\n[#PT_SIZE]
.    nr #RESTORE_INDENT  \\n[.i]
.    SIZESPECS
.    nr #DC_HEIGHT \\n[#DC_LINES]*\\n[#LEAD]+\\n[#CAP_HEIGHT]
.    ie !d$DC_FAM .FAM \\n[.fam]
.    el .FAM \\*[$DC_FAM]
.    ie !d$DC_FT .FT \\*[$FONT]
.    el .FT \\*[$DC_FT]
.    while \\n[#GET_DC_HEIGHT]<\\n[#DC_HEIGHT] \{\
.       ps \\n[#PT_SIZE]u+100u
.       SIZESPECS
.       nr #GET_DC_HEIGHT \\n[#CAP_HEIGHT]
.    \}
.    if d$DC_ADJUST .ps \\*[$DC_ADJUST]p
.    nr #DC_LINES +1
.    if \\n[#DC_LINES]v>\\n[.t] \{\
.       nr pgnum \\n%+\\n[#PAGE_NUM_ADJ] 1
.       tm1 "[mom]: Dropcap at line \\n[.c] does not fit on page \\n[pgnum].
.       tm1 "       Shifting paragraph to page \\n+[pgnum].
.       bp
.    \}
.    ie \\n[#DC_COLOR]=1 \{\
.       ie !'\\$3'' \{\
.          ie '\\$3'COND' \
.             PRINT \
\\*[DOWN \\n[#DC_LINES]v]\
\m[\\*[$DC_COLOR]]\\*[COND]\\*[$DROPCAP]\\*[CONDX]\m[]\\*[UP \\n[#DC_LINES]v]
.          el \
.             PRINT \
\\*[DOWN \\n[#DC_LINES]v]\
\m[\\*[$DC_COLOR]]\\*[EXT]\\*[$DROPCAP]\\*[EXTX]\m[]\\*[UP \\n[#DC_LINES]v]
.       \}
.       el .PRINT \
\\*[DOWN \\n[#DC_LINES]v]\
\m[\\*[$DC_COLOR]]\\*[$DROPCAP]\m[]\\*[UP \\n[#DC_LINES]v]
.    \}
.    el \{\
.       ie !'\\$3'' \{\
.          ie '\\$3'COND' \
.             PRINT \
\\*[DOWN \\n[#DC_LINES]v]\
\\*[COND]\\*[$DROPCAP]\\*[CONDX]\\*[UP \\n[#DC_LINES]v]
.          el \
.             PRINT \
\\*[DOWN \\n[#DC_LINES]v]\
\\*[EXT]\\*[$DROPCAP]\\*[EXTX]\\*[UP \\n[#DC_LINES]v]
.       \}
.       el .PRINT \
\\*[DOWN \\n[#DC_LINES]v]\
\m[\\*[$DC_COLOR]]\\*[$DROPCAP]\m[]\\*[UP \\n[#DC_LINES]v]
.    \}
.    if '\\$3'COND' \E*[COND]
.    if '\\$3'EXT' \E*[EXT]
.    ie \\n[.i] \{\
.       vs 0
.       br
.       in +\w'\\*[$DROPCAP]'u+\\n[#DC_GUT]u
.       vs
.    \}
.    el \{\
.       vs 0
.       br
.       in \w'\\*[$DROPCAP]'u+\\n[#DC_GUT]u
.       vs
.    \}
.    if '\\$3'COND' \E*[CONDX]\c
.    if '\\$3'EXT' \E*[EXTX]\c
.    FAM \\*[$RESTORE_FAM]
.    FT  \\*[$RESTORE_FT]
.    ps \\n[#RESTORE_PT_SIZE]u
.    if \\n[#CONDENSE_WAS_ON] \{\
.       CONDENSE \\*[$RESTORE_COND]
\\*[COND]\c
.    \}
.    if \\n[#EXTEND_WAS_ON] \{\
.       EXTEND \\*[$RESTORE_EXT]
\\*[EXT]\c
.    \}
.    ie \\n[.u] .wh \\n[.d]u+\\n[#DC_HEIGHT]u-1v DROPCAP_OFF
.    el .wh \\n[.d]u+\\n[#DC_HEIGHT]u DROPCAP_OFF
.    rr #CONDENSE_WAS_ON
.    rr #EXTEND_WAS_ON
.    rm $DROPCAP
.    rr #DC_LINES
.    rm $RESTORE_COND
.    rm $RESTORE_EXT
.    rm $RESTORE_FAM
.    rm $RESTORE_FT
.    rr #RESTORE_PT_SIZE
.    rr #RESTORE_INDENT
.    rr #DC_HEIGHT
.    rr #GET_DC_HEIGHT
.    rr x
.END
\#
.MAC DROPCAP_OFF END
'    in \\n[#RESTORE_INDENT]u
.    ch DROPCAP_OFF
.END
\#
\# =====================================================================
\#
\# +++GRAPHICAL OBJECTS+++
\#
\# HORIZONTAL RULE - DRH
\# ---------------------
\# *Arguments:
\#   <none> | <rule weight> <indent> <length> [ <color> ]
\# *Function:
\#   With no arg, draws a full measure rule.  With args, draws
\#   described horizontal rule.
\# *Notes:
\#   Rules are drawn left-to-right, from the baseline down, and
\#   return to their point of origin.  Color must be set in the
\#   macro; otherwise the color will be black, regardless of current
\#   .gcolor.  If no arg given, the rule weight is the one set by
\#   RULE_WEIGHT.
\#
.MAC DRH END
.    if \\n[.vpt]=1 \{\
.       vpt 0
.       nr #RESTORE_TRAP 1
.    \}
.    ie !\\n[#NO_ADVANCE]=1 .br
.    el \{\
.       sp -1v
.       rr #NO_ADVANCE
.    \}
.    ie \\n[.u]=1 \{\
.       nr #FILLED 1
.       nr #FILL_MODE \\n[.j]
.    \}
.    el \{\
.       nr #NOFILL 1
.       if \\n[.ce]>0 .nr #NOFILL_MODE 3
.       if \\n[.rj]>0 .nr #NOFILL_MODE 5
.       ce 0
.       rj 0
.    \}
.    nf
.    ds $RL_WEIGHT \\$1
.    ds $RL_INDENT \\$2
.    ds $RL_LENGTH \\$3
.    ie !'\\$4'' .ds $RL_COLOR  \\$4
.    el          .ds $RL_COLOR default
.    nr #SAVED_WEIGHT     \\n[#RULE_WEIGHT]
.    nr #SAVED_WEIGHT_ADJ \\n[#RULE_WEIGHT_ADJ]
.    di NULL
.       if \\n[#NUM_ARGS]>=1 .RULE_WEIGHT \\*[$RL_WEIGHT]
.    di
.    gcolor \\*[$RL_COLOR]
.    ie \\n[#NUM_ARGS]=0 \{\
.       ie \\n[#INDENT_ACTIVE] \{\
.          nr #RESTORE_L_LENGTH \\n[.l]
.          if \\n[#INDENT_BOTH_ACTIVE] .ll \\n[.l]u-\\n[#BL_INDENT]u
.          if \\n[#INDENT_LEFT_ACTIVE] .ll \\n[.l]u-\\n[#L_INDENT]u
\D't \\n[#RULE_WEIGHT]'\
\h'\\*[$RL_INDENT]-\\n[#RULE_WEIGHT]u'\
\v'\\n[#RULE_WEIGHT_ADJ]u'\
\D'l \En[.l]u 0'\v'-\\n[#RULE_WEIGHT_ADJ]u'\
\v'-\\n[#RULE_WEIGHT_ADJ]u'\
\D't \\n[#SAVED_RULE_WEIGHT]'
.          ll \\n[#RESTORE_L_LENGTH]u
.          rr #RESTORE_L_LENGTH
.       \}
.       el \{\
\D't \\n[#RULE_WEIGHT]'\
\h'\\*[$RL_INDENT]-\\n[#RULE_WEIGHT]u'\
\v'\\n[#RULE_WEIGHT_ADJ]u'\
\D'l \En[.l]u 0'\v'-\\n[#RULE_WEIGHT_ADJ]u'\
\v'-\\n[#RULE_WEIGHT_ADJ]u'\
\D't \\n[#SAVED_RULE_WEIGHT]'
.       \}
.    \}
.    el \{\
\D't \\n[#RULE_WEIGHT]'\
\h'\\*[$RL_INDENT]-\\n[#RULE_WEIGHT]u'\
\v'\\n[#RULE_WEIGHT_ADJ]u'\
\D'l \\*[$RL_LENGTH] 0'\
\v'-\\n[#RULE_WEIGHT_ADJ]u'\
\D't \\n[#SAVED_RULE_WEIGHT]'
.    \}
.    if \\n[#FILLED]=1 \{\
.       if \\n[#FILL_MODE]=0 .QUAD LEFT
.       if \\n[#FILL_MODE]=1 .JUSTIFY
.       if \\n[#FILL_MODE]=3 .QUAD CENTER
.       if \\n[#FILL_MODE]=5 .QUAD RIGHT
.       rr #FILLED
.    \}
.    sp -1v
.    if \\n[#NOFILL]=1 \{\
.       if \\n[#NOFILL_MODE]=3 .CENTER
.       if \\n[#NOFILL_MODE]=5 .RIGHT
.    \}
.    gcolor
.    nr #RULE_WEIGHT     \\n[#SAVED_WEIGHT]
.    nr #RULE_WEIGHT_ADJ \\n[#SAVED_WEIGHT_ADJ]
.    rr #SAVED_WEIGHT
.    rr #SAVED_WEIGHT_ADJ
.    if \\n[#RESTORE_TRAP]=1 \{\
.       vpt 1
.       rr #RESTORE_TRAP
.    \}
.    if '\\n[.z]'FLOAT*DIV' \
.       if !(\\n[.d]+\\n[#WEIGHT])<\\n[D-float] .nr D-float \\n[.d]+\\n[#WEIGHT]
.END
\#
\# RULE
\# ----
\# *Argument:
\#   <none>
\# *Function:
\#   Draws a rule the length of the current measure.
\# *Notes:
\#   A convenience macro.  DRH with no argument does the same thing.
\#   Kept in for backward compatibility.
\#
.MAC RULE END
.    if \\n[.u]=1 \{\
.       nr fill 1
.       ds $CURRENT_QUAD \\*[$QUAD_VALUE]
.       nf
.    \}
.    ie \\n[#INDENT_ACTIVE] \{\
.       if \\n[#INDENT_BOTH_ACTIVE] .ll \\n[.l]u-\\n[#BL_INDENT]u
.       if \\n[#INDENT_LEFT_ACTIVE] .ll \\n[.l]u-\\n[#L_INDENT]u
.       PRINT \
\D't \\n[#RULE_WEIGHT]'\v'\\n[#RULE_WEIGHT_ADJ]u'\
\h'-\\n[#RULE_WEIGHT]u'\
\D'l \En[.l]u 0'\v'-\\n[#RULE_WEIGHT_ADJ]u'\h'|0'\c
.       ll
.       rr #RESTORE_L_LENGTH
.    \}
.    el \{\
.       PRINT \
\D't \\n[#RULE_WEIGHT]'\v'\\n[#RULE_WEIGHT_ADJ]u'\
\h'-\\n[#RULE_WEIGHT]u'\
\D'l \En[.l]u 0'\v'-\\n[#RULE_WEIGHT_ADJ]u'\h'|0'\c
.    \}
.    if \\n[fill] \{\
.       fi
.       rr fill
.       QUAD \\*[$CURRENT_QUAD]
.       rm $CURRENT_QUAD
.    \}
.    EOL
.END
\#
\# VERTICAL RULE - DRV
\# -------------------
\# *Arguments:
\#   <rule weight> <indent> <depth> [ <color> ]
\# *Function:
\#   Draws described vertical rule.
\# *Notes:
\#   Rules are drawn left-to-right, from the baseline down, and
\#   return to their point of origin.  Color must be set in the
\#   macro; otherwise the color will be black, regardless of current
\#   .gcolor.
\#
.MAC DRV END
.    if \\n[.vpt]=1 \{\
.       vpt 0
.       nr #RESTORE_TRAP 1
.    \}
.    ie !\\n[#NO_ADVANCE]=1 .br
.    el \{\
.       sp -1v
.       rr #NO_ADVANCE
.    \}
.    ie \\n[.u]=1 \{\
.       nr #FILLED 1
.       nr #FILL_MODE \\n[.j]
.    \}
.    el \{\
.       nr #NOFILL 1
.       if \\n[.ce]>0 .nr #NOFILL_MODE 3
.       if \\n[.rj]>0 .nr #NOFILL_MODE 5
.       ce 0
.       rj 0
.    \}
.    nf
.    ds $RL_WEIGHT \\$1
.    ds $RL_INDENT \\$2
.    ds $RL_DEPTH  \\$3
.    ie !'\\$4'' \{\
.       ds $RL_COLOR  \\$4
.    \}
.    el .ds $RL_COLOR default
.    nr #SAVED_WEIGHT     \\n[#RULE_WEIGHT]
.    nr #SAVED_WEIGHT_ADJ \\n[#RULE_WEIGHT_ADJ]
.    RULE_WEIGHT \\*[$RL_WEIGHT]
.    gcolor \\*[$RL_COLOR]
\D't \\n[#RULE_WEIGHT]'\
\h'\\*[$RL_INDENT]-\\n[#RULE_WEIGHT_ADJ]u'\
\D'l 0 \\*[$RL_DEPTH]'\
\D't \\n[#SAVED_RULE_WEIGHT]'
.    if \\n[#FILLED]=1 \{\
.       if \\n[#FILL_MODE]=0 .QUAD LEFT
.       if \\n[#FILL_MODE]=1 .JUSTIFY
.       if \\n[#FILL_MODE]=3 .QUAD CENTER
.       if \\n[#FILL_MODE]=5 .QUAD RIGHT
.       rr #FILLED
.    \}
.    sp -1v
.    if \\n[#NOFILL]=1 \{\
.       if \\n[#NOFILL_MODE]=3 .CENTER
.       if \\n[#NOFILL_MODE]=5 .RIGHT
.    \}
.    gcolor
.    nr #RULE_WEIGHT     \\n[#SAVED_WEIGHT]
.    nr #RULE_WEIGHT_ADJ \\n[#SAVED_WEIGHT_ADJ]
.    if \\n[#RESTORE_TRAP]=1 \{\
.       vpt 1
.       rr #RESTORE_TRAP
.    \}
.    if '\\n[.z]'FLOAT*DIV' \{\
.       if !(\\n[.d]+\\*[$RL_DEPTH])<\\n[D-float] .nr D-float \\n[.d]+\\*[$RL_DEPTH]
.    \}
.END
\#
\# BOXES - DBX
\# -----------
\# *Arguments:
\#   <rule weight | SOLID> <indent> <length> <depth> [ <color> ]
\# *Function:
\#   Draws described box.
\# *Notes:
\#   Boxes are drawn left-to-right, from the baseline down, and
\#   return to their point of origin.  Box rules are drawn from the
\#   perimeter inwards.  Color must be set in the macro; otherwise
\#   the color will be black, regardless of current .gcolor.  If no
\#   arg given, the rule weight is the one set by RULE_WEIGHT.
\#
.MAC DBX END
.    if \\n[.vpt]=1 \{\
.       vpt 0
.       nr #RESTORE_TRAP 1
.    \}
.    ie !\\n[#NO_ADVANCE]=1 .br
.    el \{\
.       sp -1v
.       rr #NO_ADVANCE
.    \}
.    ie \\n[.u]=1 \{\
.       nr #FILLED 1
.       nr #FILL_MODE \\n[.j]
.    \}
.    el \{\
.       nr #NOFILL 1
.       if \\n[.ce]>0 .nr #NOFILL_MODE 3
.       if \\n[.rj]>0 .nr #NOFILL_MODE 5
.       ce 0
.       rj 0
.    \}
.    nf
.    ie '\\$1'SOLID' .nr #BX_SOLID 1
.    el              .ds $BX_WEIGHT \\$1
.    ds $BX_INDENT \\$2
.    ds $BX_WIDTH  \\$3
.    ds $BX_DEPTH  \\$4
.    ie !'\\$5'' \{\
.       ie d$\\$5_FILL .ds $BX_COLOR \\*[$\\$5_FILL]
.       el             .ds $BX_COLOR \\$5
.    \}
.    el .ds $BX_COLOR default
.    nr #SAVED_WEIGHT     \\n[#RULE_WEIGHT]
.    nr #SAVED_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.    if !'\\$1'SOLID' .RULE_WEIGHT \\*[$BX_WEIGHT]
.    ds $BX_INDENT \\*[$BX_INDENT]-\\n[#WEIGHT_ADJ]u
.    ie \\n[#BX_SOLID]=1 \{\
.       fcolor \\*[$BX_COLOR]
\h'\\*[$BX_INDENT]'\
\D'P \\*[$BX_WIDTH] 0 0 \\*[$BX_DEPTH] -\\*[$BX_WIDTH] 0 0 -\\*[$BX_DEPTH]'
.       fcolor
.       rr #BX_SOLID
.    \}
.    el \{\
.       gcolor \\*[$BX_COLOR]
\D't \\n[#RULE_WEIGHT]'\
\h'\\*[$BX_INDENT]'\
\v'\\n[#WEIGHT_ADJ]u'\
\D'p \\*[$BX_WIDTH]-\\n[#RULE_WEIGHT]u 0 0 \\*[$BX_DEPTH]-\\n[#RULE_WEIGHT]u -\\*[$BX_WIDTH]+\\n[#RULE_WEIGHT]u 0 0 -\\*[$BX_DEPTH]+\\n[#RULE_WEIGHT]u'\
\v'-\\n[#WEIGHT_ADJ]u'\
\D't \\n[#SAVED_RULE_WEIGHT]'
.       gcolor
.    \}
.    sp -1v
.    if \\n[#FILLED]=1 \{\
.       if \\n[#FILL_MODE]=0 .QUAD LEFT
.       if \\n[#FILL_MODE]=1 .JUSTIFY
.       if \\n[#FILL_MODE]=3 .QUAD CENTER
.       if \\n[#FILL_MODE]=5 .QUAD RIGHT
.       rr #FILLED
.    \}
.    if \\n[#NOFILL]=1 \{\
.       if \\n[#NOFILL_MODE]=3 .CENTER
.       if \\n[#NOFILL_MODE]=5 .RIGHT
.    \}
.    nr #RULE_WEIGHT \\n[#SAVED_WEIGHT]
.    nr #WEIGHT_ADJ  \\n[#SAVED_WEIGHT_ADJ]
.    rr #SAVED_WEIGHT
.    rr #SAVED_WEIGHT_ADJ
.    if \\n[#RESTORE_TRAP]=1 \{\
.       vpt 1
.       rr #RESTORE_TRAP
.    \}
.    if '\\n[.z]'FLOAT*DIV' \
.       if !(\\n[.d]+\\*[$BX_DEPTH])<\\n[D-float] .nr D-float \\n[.d]+\\*[$BX_DEPTH]
.END
\#
\# ELLIPSES - DCL
\# --------------
\# *Arguments:
\#   <rule weight | SOLID> <indent> <width> <depth> [ <color> ]
\# *Function:
\#   Draws described ellipses.
\# *Notes:
\#   Ellipses (circles) are drawn left-to-right, from the baseline
\#   down, and return to their point of origin.  Ellipse rules are
\#   drawn from the perimeter inwards.  Color must be set in the
\#   macro; otherwise the color will be black, regardless of current
\#   .gcolor.  If no arg given, the rule weight is the one set by
\#   RULE_WEIGHT.
\#
.MAC DCL END
.    if \\n[.vpt]=1 \{\
.       vpt 0
.       nr #RESTORE_TRAP 1
.    \}
.    ie !\\n[#NO_ADVANCE]=1 .br
.    el \{\
.       sp -1v
.       rr #NO_ADVANCE
.    \}
.    ie \\n[.u]=1 \{\
.       nr #FILLED 1
.       nr #FILL_MODE \\n[.j]
.    \}
.    el \{\
.       nr #NOFILL 1
.       if \\n[.ce]>0 .nr #NOFILL_MODE 3
.       if \\n[.rj]>0 .nr #NOFILL_MODE 5
.       ce 0
.       rj 0
.    \}
.    nf
.    ie '\\$1'SOLID' .nr #CL_SOLID 1
.    el              .ds $CL_WEIGHT \\$1
.    ds $CL_INDENT \\$2
.    ds $CL_WIDTH  \\$3
.    ds $CL_DEPTH  \\$4
.    ie !'\\$5'' \{\
.       ie d$\\$5_FILL .ds $CL_COLOR \\*[$\\$5_FILL]
.       el             .ds $CL_COLOR \\$5
.    \}
.    el .ds $CL_COLOR default
.    nr #SAVED_WEIGHT     \\n[#RULE_WEIGHT]
.    nr #SAVED_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.    if !'\\$1'SOLID' .RULE_WEIGHT \\*[$CL_WEIGHT]
.    ds $CL_INDENT \\*[$CL_INDENT]-\\n[#WEIGHT_ADJ]u
.    ie \\n[#CL_SOLID]=1 \{\
.       fcolor \\*[$CL_COLOR]
\h'\\*[$CL_INDENT]'\
\v'\\*[$CL_DEPTH]/2u'\
\D'E \\*[$CL_WIDTH]-\\n[#RULE_WEIGHT]u \\*[$CL_DEPTH]-\\n[#RULE_WEIGHT]u'\
\v'-\\*[$CL_DEPTH]/2u'
.       fcolor
.       rr #CL_SOLID
.    \}
.    el \{\
.       gcolor \\*[$CL_COLOR]
\D't \\n[#RULE_WEIGHT]'\
\h'\\*[$CL_INDENT]'\
\v'\\*[$CL_DEPTH]/2u'\
\D'e \\*[$CL_WIDTH]-\\n[#RULE_WEIGHT]u \\*[$CL_DEPTH]-\\n[#RULE_WEIGHT]u'\
\v'-(\\*[$CL_DEPTH]/2u)'\
\D't \\n[#SAVED_RULE_WEIGHT]'
.       gcolor
.    \}
.    sp -1v
.    if \\n[#FILLED]=1 \{\
.       if \\n[#FILL_MODE]=0 .QUAD LEFT
.       if \\n[#FILL_MODE]=1 .JUSTIFY
.       if \\n[#FILL_MODE]=3 .QUAD CENTER
.       if \\n[#FILL_MODE]=5 .QUAD RIGHT
.       rr #FILLED
.    \}
.    if \\n[#NOFILL]=1 \{\
.       if \\n[#NOFILL_MODE]=3 .CENTER
.       if \\n[#NOFILL_MODE]=5 .RIGHT
.    \}
.    nr #RULE_WEIGHT \\n[#SAVED_WEIGHT]
.    nr #WEIGHT_ADJ  \\n[#SAVED_WEIGHT_ADJ]
.    rr #SAVED_WEIGHT
.    rr #SAVED_WEIGHT_ADJ
.    if \\n[#RESTORE_TRAP]=1 \{\
.       vpt 1
.       rr #RESTORE_TRAP
.    \}
.    if '\\n[.z]'FLOAT*DIV' \
.       if !(\\n[.d]+\\*[$CL_DEPTH])<\\n[D-float] .nr D-float \\n[.d]+\\*[$CL_DEPTH]
.END
\#
\# RULE WEIGHT
\# -----------
\# *Argument:
\#   <weight of rules in points>
\# *Function:
\#   Sets \D't <n>' to the correct number of machine units for the
\#   argument given in points.
\# *Notes:
\#   Decimal fractions are allowed.  Rule weight must be < 100.
\#
.MAC RULE_WEIGHT END
.    di NULL \" Diverted so there's no problem with breaks, spacing, etc.
.       ds $ARG \\$1
.       substring $ARG -1
.       if !\B'\\*[$ARG]' \{\
.          tm1 "[mom]: The argument to \\$0 must not have a unit of measure appended.
.          ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.       \}
.       length #STR_LENGTH \\$1
.       ds $ARG \\$1
.       substring $ARG 0 0
.       ie '\\*[$ARG]'.' \{\
.          ds $ARG \\$1
.          substring $ARG 1 \\n[#STR_LENGTH]-1
.          nr #WEIGHT \\*[$ARG]*100
.          if (\\n[#WEIGHT]>=1000) \{\
.              while (\\n[#WEIGHT]>=1000) \{\
.                  nr #WEIGHT \\n[#WEIGHT]/10
.              \}
.          \}
.       \}
.       el \{\
.          ds $ARG \\$1
.          substring $ARG 1 1
.          ie '\\*[$ARG]'.' \{\
.             ds $LHS \\$1
.             substring $LHS 0 0
.             ds $RHS \\$1
.             substring $RHS 2
.             nr #WEIGHT \\*[$LHS]\\*[$RHS]*100
.             if (\\n[#WEIGHT]>=10000) \{\
.                while (\\n[#WEIGHT]>=10000) \{\
.                   nr #WEIGHT \\n[#WEIGHT]/10
.                \}
.             \}
.          \}
.          el \{\
.             ie \\n[#STR_LENGTH]<=2 .nr #WEIGHT \\$1*1000
.             el \{\
.                ds $ARG \\$1
.                substring $ARG 2 2
.                ie !'\\*[$ARG]'.' \{\
.                   tm1 "[mom]: Invalid argument given to macro \\$0 at line \\n[.c].
.                   tm1 "       Rule weight must be < 100 points.
.                   tm1 "       Falling back to default weight .5 points.
.                   nr #WEIGHT 500
.                \}
.                el \{\
.                   ds $LHS \\$1
.                   substring $LHS 0 1
.                   ds $RHS \\$1
.                   substring $RHS 3
.                   nr #WEIGHT \\*[$LHS]\\*[$RHS]*1000
.                   if (\\n[#WEIGHT]>=100000) \{\
.                      while (\\n[#WEIGHT]>=100000) \{\
.                         nr #WEIGHT \\n[#WEIGHT]/10
.                      \}
.                   \}
.                \}
.             \}
.          \}
.       \}
.       nr #WEIGHT_ADJ \\n[#WEIGHT]/2
.       if '\\$0'BIBLIOGRAPHY_STRING_UNDERLINE_WEIGHT' \{\
.          nr #BIB_STRING_UNDERLINE_WEIGHT     \\n[#WEIGHT]
.          nr #BIB_STRING_UNDERLINE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.       if '\\$0'COVER_UNDERLINE_WEIGHT' \{\
.          nr #COVER_UNDERLINE_WEIGHT     \\n[#WEIGHT]
.          nr #COVER_UNDERLINE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.       if '\\$0'DOC_COVER_UNDERLINE_WEIGHT' \{\
.          nr #DOC_COVER_UNDERLINE_WEIGHT     \\n[#WEIGHT]
.          nr #DOC_COVER_UNDERLINE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.       if '\\$0'DOCTYPE_UNDERLINE_WEIGHT' \{\
.          nr #DOCTYPE_UNDERLINE_WEIGHT     \\n[#WEIGHT]
.          nr #DOCTYPE_UNDERLINE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.       if '\\$0'ENDNOTE_STRING_UNDERLINE_WEIGHT' \{\
.          nr #EN_STRING_UNDERLINE_WEIGHT     \\n[#WEIGHT]
.          nr #EN_STRING_UNDERLINE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.       if '\\$0'ENDNOTE_TITLE_UNDERLINE_WEIGHT' \{\
.          nr #EN_TITLE_UNDERLINE_WEIGHT     \\n[#WEIGHT]
.          nr #EN_TITLE_UNDERLINE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.       if '\\$0'FOOTER_RULE_WEIGHT' \{\
.          nr #FOOTER_RULE_WEIGHT     \\n[#WEIGHT]
.          nr #FOOTER_RULE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.       if '\\$0'FOOTNOTE_RULE_WEIGHT' \{\
.          nr #FN_RULE_WEIGHT     \\n[#WEIGHT]
.          nr #FN_RULE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.       if '\\$0'HEADER_RULE_WEIGHT' \{\
.          nr #HEADER_RULE_WEIGHT     \\n[#WEIGHT]
.          nr #HEADER_RULE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.       if '\\$0'RULE_WEIGHT' \{\
.          nr #RULE_WEIGHT     \\n[#WEIGHT]
.          nr #RULE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.       if '\\$0'UNDERSCORE_WEIGHT' \{\
.          nr #UNDERSCORE_WEIGHT     \\n[#WEIGHT]
.          nr #UNDERSCORE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.    di
.END
\#
\# Aliases
\# 
.ALIAS BIBLIOGRAPHY_STRING_UNDERLINE_WEIGHT RULE_WEIGHT
.ALIAS COVER_UNDERLINE_WEIGHT               RULE_WEIGHT
.ALIAS DOC_COVER_UNDERLINE_WEIGHT           RULE_WEIGHT
.ALIAS DOCTYPE_UNDERLINE_WEIGHT             RULE_WEIGHT
.ALIAS ENDNOTE_STRING_UNDERLINE_WEIGHT      RULE_WEIGHT
.ALIAS ENDNOTE_TITLE_UNDERLINE_WEIGHT       RULE_WEIGHT
.ALIAS FOOTER_RULE_WEIGHT                   RULE_WEIGHT
.ALIAS FOOTNOTE_RULE_WEIGHT                 RULE_WEIGHT
.ALIAS HEADER_RULE_WEIGHT                   RULE_WEIGHT
.ALIAS UNDERSCORE_WEIGHT                    RULE_WEIGHT
\#
\# Default rule weights
\# ~~~~~~~~~~~~~~~~~~~~
.nr #BIB_STRING_UNDERLINE_WEIGHT 500
.nr #COVER_UNDERLINE_WEIGHT      500
.nr #DOC_COVER_UNDERLINE_WEIGHT  500
.nr #DOCTYPE_UNDERLINE_WEIGHT    500
.nr #EN_STRING_UNDERLINE_WEIGHT  500
.nr #EN_TITLE_UNDERLINE_WEIGHT   500
.nr #FN_RULE_WEIGHT              500
.nr #FOOTER_RULE_WEIGHT          500
.nr #HEADER_RULE_WEIGHT          500
.nr #RULE_WEIGHT                 500
.nr #UNDERSCORE_WEIGHT           500
\#
.nr #BIB_STRING_UNDERLINE_WEIGHT_ADJ \n[#BIB_STRING_UNDERLINE_WEIGHT]/2
.nr #COVER_UNDERLINE_WEIGHT_ADJ      \n[#DOCTYPE_UNDERLINE_WEIGHT]/2
.nr #DOC_COVER_UNDERLINE_WEIGHT_ADJ  \n[#DOCTYPE_RULE_WEIGHT]/2
.nr #DOCTYPE_UNDERLINE_WEIGHT_ADJ    \n[#DOCTYPE_RULE_WEIGHT]/2
.nr #EN_STRING_UNDERLINE_WEIGHT_ADJ  \n[#EN_STRING_UNDERLINE_WEIGHT]/2
.nr #EN_TITLE_UNDERLINE_WEIGHT_ADJ   \n[#EN_STRING_UNDERLINE_WEIGHT]/2
.nr #FOOTER_RULE_WEIGHT_ADJ          \n[#FOOTER_RULE_WEIGHT]/2
.nr #FN_RULE_WEIGHT_ADJ              \n[#FN_RULE_WEIGHT]/2
.nr #HEADER_RULE_WEIGHT_ADJ          \n[#HEADER_RULE_WEIGHT]/2
.nr #RULE_WEIGHT_ADJ                 \n[#RULE_WEIGHT]/2
.nr #UNDERSCORE_WEIGHT_ADJ           \n[#UNDERSCORE_WEIGHT]/2
\#
\# Set default rule weight
\#
.di NULL
\D't 500'
.di
\#
\# =====================================================================
\#
\# +++WORD AND SENTENCE SPACING+++
\#
\# WORD SPACE CONTROL
\# ------------------
\# *Argument:
\#   <+|->wordspace | DEFAULT
\# *Function:
\#   Increases or decreases interword space by user supplied amount.
\#   If DEFAULT, value is set to 12 (groff default).
\# *Notes:
\#   $WS_CONSTANT is the groff default word space.
\#   $WS_VAR is the user supplied amount by which to in/decrease word space.
\#   $WS is a concatenation of WS_CONSTANT and WS_VAR.
\#
\#   \n[.sss] holds the current sentence space value.
\#
.MAC WS END
.    ds $WS_CURR \\n[.ss]
.    ds $WS_VAR  \\$1
.    ie '\\$1'DEFAULT' .ss 12 \\n[.sss]
.    el \{\
.       ds $WS (\\*[$WS_CURR]\\*[$WS_VAR])
.       ie \\n[.sss]=12 .ss \\*[$WS] 12
.       el \{\
.          ss \\*[$WS] (\\*[$WS]\\*[$SS_VAR])
.          SS \\*[$SS_VAR]
.      \}
.    \}
.END
\#
\# SENTENCE SPACE CONTROL
\# ----------------------
\# *Argument:
\#   <+-sentencespace> | 0 | DEFAULT
\# *Function:
\#   Increases or decreases sentence space by user supplied amount.
\#   If 0, sentence spaces are ignored.  If DEFAULT, value is
\#   set to 12 (groff default).
\# *Notes:
\#   Because the user supplied value requires a literal + or - sign,
\#   the macro argument is stored in a string.
\#
\#   Sentence space applies only to input where sentences are separated
\#   by two spaces (and/or, in fill mode [FLUSH L|R|C or JUSTIFY], an EOL).
\#   Changing .SS when sentences are separated by only one space has
\#   no effect on the space between sentences.
\#
\#   \n[.ss] holds the current wordspace value.
\#   \n[.sss] holds the current sentence space value.
\#
.MAC SS END
.    ds $SS_VAR \\$1
.    ie '\\$1'0' .ss \\n[.ss] (\\n[.ss]-\\n[.ss])
.    el \{\
.       ie '\\$1'DEFAULT' .ss \\n[.ss]
.       el                .ss \\n[.ss] (0\\*[$SS_VAR])
.    \}
.END
\#
\# =====================================================================
\#
\# INDENTS
\# -------
\#
\# +++INDENT LEFT+++
\#
.MAC IL END
.    if \\n[#INDENT_STYLE_BOTH] .IBX
.    nr #INDENT_STYLE_LEFT  1
.    nr #INDENT_ACTIVE      1
.    nr #INDENT_LEFT_ACTIVE 1
.    ie '\\$1'' \{\
.       br
.       in \\n[#L_INDENT]u
.       ta \\n[.l]u-\\n[#L_INDENT]u
.    \}
.    el \{\
.       br
.       nr #L_INDENT +(\\$1)
.       in \\n[#L_INDENT]u
.       ta \\n[.l]u-\\n[#L_INDENT]u
.    \}
.    if \\n[#IN_ITEM] .nr #IN_ITEM_L_INDENT +(\\$1)
.END
\#
\# +++INDENT RIGHT+++
\#
.MAC IR END
.    if \\n[#INDENT_STYLE_BOTH] .IBX
.    nr #INDENT_STYLE_RIGHT   1
.    nr #INDENT_ACTIVE        1
.    nr #INDENT_RIGHT_ACTIVE  1
.    ie '\\$1'' \{\
.       br
.       ie \\n[#TAB_ACTIVE] \{\
.          ll \\n[.l]u-\\n[#R_INDENT]u
.          ta \\n[.l]u-\\n[#L_INDENT]u
.       \}
.       el \{\
.          ll \\n[.l]u-\\n[#R_INDENT]u
.          ta \\n[.l]u-\\n[#L_INDENT]u
.       \}
.    \}
.    el \{\
.       br
.       nr #R_INDENT +(\\$1)
.       ie \\n[#TAB_ACTIVE] \{\
.          ll \\n[.l]u-\\n[#R_INDENT]u
.          ta \\n[.l]u-\\n[#L_INDENT]u
.       \}
.       el \{\
.          ll \\n[.l]u-\\n[#R_INDENT]u
.          ta \\n[.l]u-\\n[#L_INDENT]u
.       \}
.    \}
.END
\#
\# +++INDENT BOTH+++
\#
.MAC IB END
.    if \\n[#INDENT_STYLE_LEFT] .ILX
.    if \\n[#INDENT_STYLE_RIGHT] .IRX
.    nr #INDENT_STYLE_BOTH  1
.    nr #INDENT_ACTIVE      1
.    nr #INDENT_BOTH_ACTIVE 1
.    ie '\\$1'' \{\
.       br
.       in \\n[#BL_INDENT]u
.       ie \\n[#TAB_ACTIVE] \{\
.          ll \\n[.l]u-\\n[#BR_INDENT]u
.          ta \\n[.l]u-\\n[#BR_INDENT]u
.       \}
.       el \{\
.          ll \\n[.l]u-\\n[#BR_INDENT]u
.          ta \\n[.l]u-\\n[#BR_INDENT]u
.       \}
.    \}
.    el \{\
.       br
.       nr #BL_INDENT (\\n[#INDENT]+\\$1)
.       ie \\n[#NUM_ARGS]=2 .nr #BR_INDENT +(\\$2)
.       el .nr #BR_INDENT \\n[#BL_INDENT]
.       ie \\n[#TAB_ACTIVE] \{\
.          in \\n[#BL_INDENT]u
.          ll \\n[.l]u-\\n[#BR_INDENT]u
.          ta \\n[.l]u-\\n[#BL_INDENT]u
.       \}
.       el \{\
.          in \\n[#BL_INDENT]u
.          ll \\n[.l]u-\\n[#BR_INDENT]u
.          ta \\n[.l]u-\\n[#BR_INDENT]u
.       \}
.    \}
.END
\#
\# +++TEMPORARY INDENT+++
\#
.MAC TI END
.    br
.    ie '\\$1'' \{\
.       ti \\n[#T_INDENT]u
.       if \\n[#INDENT_LEFT_ACTIVE] .ti \\n[#T_INDENT]u+\\n[#L_INDENT]u
.       if \\n[#INDENT_BOTH_ACTIVE] .ti \\n[#T_INDENT]u+\\n[#BL_INDENT]u
.    \}
.    el \{\
.       nr #T_INDENT (\\$1)
.       ti \\n[#T_INDENT]u
.    \}
.END
\#
\# +++HANGING INDENT+++
\#
.MAC HI END
.    ie '\\$1'' .ti -\\n[#HL_INDENT]u
.    el \{\
.       nr #HL_INDENT (\\$1)
.       ti -\\n[#HL_INDENT]u
.    \}
.END
\#
\# +++INDENTS OFF+++
\#
.MAC ILX END
.    ie \\n[#IN_ITEM] .nr #L_INDENT -\\n[#IN_ITEM_L_INDENT]
.    el \{\
.       br
.       in 0
.       rr #INDENT_LEFT_ACTIVE
.    \}
.    if '\\$1'CLEAR' \{\
.       rr #L_INDENT
.       rr #INDENT_STYLE_LEFT
.    \}
.END
\#
.MAC IRX END
.    br
.    rr #INDENT_RIGHT_ACTIVE
.    ie \\n[#TAB_ACTIVE] .TAB\\n[#CURRENT_TAB]
.    el \{\
.       ie \\n[#COLUMNS] \{\
.          ll \\n[#COL_L_LENGTH]u
.          ta \\n[.l]u
.       \}
.       el \{\
.          ll \\n[#L_LENGTH]u
.          ta \\n[.l]u
.       \}
.    \}
.    if '\\$1'CLEAR' \{\
.       rr #R_INDENT
.       rr #INDENT_STYLE_RIGHT
.    \}
.END
\#
.MAC IBX END
.    br
.    in 0
.    rr #INDENT_BOTH_ACTIVE
.    ie \\n[#TAB_ACTIVE] .TAB\\n[#CURRENT_TAB]
.    el \{\
.       ie \\n[#COLUMNS] \{\
.          ll \\n[#COL_L_LENGTH]u
.          ta \\n[.l]u
.       \}
.       el \{\
.          ll \\n[#L_LENGTH]u
.          ta \\n[.l]u
.       \}
.    \}
.    if '\\$1'CLEAR' \{\
.       rr #BL_INDENT
.       rr #BR_INDENT
.       rr #INDENT_STYLE_BOTH
.    \}
.END
\#
.MAC IX END
.    if '\\$0'IX' \{\
.       if !\\n[#IX_WARN] \{\
.          tm1 "[mom]: Use of .IX is deprecated.  Use .IQ instead.
.          tm1 "      .IX will continue to behave as before, but to
.          tm1 "       avoid this message, please update your document.
.          nr #IX_WARN 1
.       \}
.    \}
.    br
.    in 0
.    rr #INDENT_LEFT_ACTIVE
.    rr #INDENT_RIGHT_ACTIVE
.    rr #INDENT_BOTH_ACTIVE
.    if \\n[#INDENT_STYLE_RIGHT] \{\
.       ie \\n[#TAB_ACTIVE] .TAB\\n[#CURRENT_TAB]
.       el \{\
.          ie \\n[#COLUMNS] \{\
.             ll \\n[#COL_L_LENGTH]u
.             ta \\n[.l]u
.          \}
.          el \{\
.             ll \\n[#L_LENGTH]u
.             ta \\n[.l]u
.          \}
.       \}
.    \}
.    if \\n[#INDENT_STYLE_BOTH] \{\
.       ie \\n[#TAB_ACTIVE] .TAB\\n[#CURRENT_TAB]
.       el \{\
.          ie \\n[#COLUMNS] \{\
.             ll \\n[#COL_L_LENGTH]u
.             ta \\n[.l]u
.          \}
.          el \{\
.             ll \\n[#L_LENGTH]u
.             ta \\n[.l]u
.          \}
.       \}
.    \}
.    if '\\$1'CLEAR' \{\
.       if \\n[#INDENT_STYLE_RIGHT] \{\
.          ie \\n[#TAB_ACTIVE] .TAB\\n[#CURRENT_TAB]
.          el \{\
.             ie \\n[#COLUMNS] \{\
.                ll \\n[#COL_L_LENGTH]u
.                ta \\n[.l]u
.             \}
.             el \{\
.                ll \\n[#L_LENGTH]u
.                ta \\n[.l]u
.             \}
.          \}
.       \}
.       if \\n[#INDENT_STYLE_BOTH] \{\
.          ie \\n[#TAB_ACTIVE] .TAB\\n[#CURRENT_TAB]
.          el \{\
.             ie \\n[#COLUMNS] \{\
.                ll \\n[#COL_L_LENGTH]u
.                ta \\n[.l]u
.             \}
.             el \{\
.                ll \\n[#L_LENGTH]u
.                ta \\n[.l]u
.             \}
.          \}
.       \}
.       rr #L_INDENT
.       rr #R_INDENT
.       rr #BL_INDENT
.       rr #BR_INDENT
.       rr #T_INDENT
.       rr #H_INDENT
.       rr #INDENT_STYLE_LEFT
.       rr #INDENT_STYLE_RIGHT
.       rr #INDENT_STYLE_BOTH
.    \}
.    rr #INDENT_ACTIVE
.END
\#
\# =====================================================================
\#
\# +++MULTIPLE COLUMNS+++
\#
\# MULTIPLE COLUMNS ON
\# -------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Marks the top of a column set
\#
.MAC MCO END
.    mk c
.END
\#
\# MULTIPLE COLUMN RETURN
\# ----------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Returns to the top of a column set
\#
.MAC MCR END
.    TRAP OFF
.    sp |\\n[c]u
.    TRAP
.END
\#
\# MULTIPLE COLUMNS OFF
\# --------------------
\# *Arguments:
\#   <none> | <lead to advance beneath bottom of deepest column>
\# *Function:
\#   Advances to the end of a column set
\# *Notes:
\#   With no argument, advances to the next baseline (at the current
\#   leading value) beneath the longest column.  With an argument
\#   (which requires a unit of measure), advances arg distance
\#   beneath the baseline of the deepest column.  If the argument
\#   is zero, advances to the baseline of the deepest column.
\#
.MAC MCX END
.    TRAP OFF
.    ie '\\$1'' \{\
.       TQ
.       sp |\\n[.h]u
.    \}
.    el \{\
.       nr #MCX_ALD (\\$1)
.       TQ
.       ie \\n[#MCX_ALD]=0 .sp |\\n[.h]u-1v
.       el .sp |\\n[.h]u+\\n[#MCX_ALD]u
.       rr #MCX_ALD
.    \}
.    TRAP
.END
\#
\# =====================================================================
\#
\# +++TYPESETTING SUPPORT MACROS+++
\#
\# TRAP
\# ----
\# *Arguments:
\#   toggle
\# *Function:
\#   Enables/disables traps.
\# *Notes:
\#   EL and TN don't function as advertised on the last line before
\#   a trap (when they break the preceding line, they spring the
\#   trap, and groff won't back up to the line preceding the trap).
\#   TRAP is a kludge to get EL and TN work properly on last lines.
\#   The user simply enloses the offending lines in TRAP OFF/TRAP.
\#
.MAC TRAP END
.    ie '\\$1'' .vpt 1
.    el         .vpt 0
.END
\#
\# SILENT
\# ------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Diverts text so that it doesn't print, or turns the function off.
\# *Notes:
\#   Useful for setting up autotabs where you don't want the line with
\#   the tab marks to print.
\#
\#   Also aliased as COMMENT, in case user wants to input a batch of
\#   text that doesn't print.
\#
.MAC SILENT END
.    nr #SILENT 1
.    if \\n[#QUAD] .br
.    ie '\\$1'' .di NO_FLASH
.    el \{\
.       br
.       di
.       rm NO_FLASH
.       rr #SILENT
.    \}
.END
\#
\# PRINT
\# -----
\# *Function:
\#   Prints anything.  A macro that helps keep my code nicely indented.
\#
.MAC PRINT END
.    nop \\$*
.END
\#
\# CAPS
\# ----
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Converts text to caps, or, if OFF, reverts to normal caps/lc.
\# *Notes:
\#   For inline control of capitalization style, use \*[UC] and
\#   \*[LC].
\#
.MAC CAPS END
.    ie '\\$1'' \{\
.       tr aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
.       tr \[`a]\[`A]
.       tr \[^a]\[^A]
.       tr \['a]\['A]
.       tr \[:a]\[:A]
.       tr \[oa]\[oA]
.       tr \[~a]\[~A]
.       tr \[ae]\[AE]
.       tr \[`e]\[`E]
.       tr \[^e]\[^E]
.       tr \['e]\['E]
.       tr \[:e]\[:E]
.       tr \[`i]\[`I]
.       tr \[^i]\[^I]
.       tr \['i]\['I]
.       tr \[:i]\[:I]
.       tr \[`o]\[`O]
.       tr \[^o]\[^O]
.       tr \['o]\['O]
.       tr \[:o]\[:O]
.       tr \[~o]\[~O]
.       tr \[/o]\[/O]
.       tr \[`u]\[`U]
.       tr \[^u]\[^U]
.       tr \['u]\['U]
.       tr \[:u]\[:U]
.       tr \[,c]\[,C]
.       tr \[-d]\[-D]
.       tr \[~n]\[~N]
.       tr \[Sd]\[-D]
.       tr \[Tp]\[TP]
.       tr \['y]\['Y]
.       tr \[:y]\[:Y]
.       nr #CAPS_ON 1
.    \}
.    el \{\
.       tr aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz
.       tr \[`a]\[`a]
.       tr \[^a]\[^a]
.       tr \['a]\['a]
.       tr \[:a]\[:a]
.       tr \[oa]\[oa]
.       tr \[~a]\[~a]
.       tr \[ae]\[ae]
.       tr \[`e]\[`e]
.       tr \[^e]\[^e]
.       tr \['e]\['e]
.       tr \[:e]\[:e]
.       tr \[`i]\[`i]
.       tr \[^i]\[^i]
.       tr \['i]\['i]
.       tr \[:i]\[:i]
.       tr \[`o]\[`o]
.       tr \[^o]\[^o]
.       tr \['o]\['o]
.       tr \[:o]\[:o]
.       tr \[~o]\[~o]
.       tr \[/o]\[/o]
.       tr \[`u]\[`u]
.       tr \[^u]\[^u]
.       tr \['u]\['u]
.       tr \[:u]\[:u]
.       tr \[,c]\[,c]
.       tr \[Sd]\[Sd]
.       tr \[~n]\[~n]
.       tr \[Tp]\[Tp]
.       tr \['y]\['y]
.       tr \[:y]\[:y]
.       rr #CAPS_ON
.    \}
.END
\#
.MAC UC END
\c
.    tr aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
.    tr \[`a]\[`A]
.    tr \[^a]\[^A]
.    tr \['a]\['A]
.    tr \[:a]\[:A]
.    tr \[oa]\[oA]
.    tr \[~a]\[~A]
.    tr \[ae]\[AE]
.    tr \[`e]\[`E]
.    tr \[^e]\[^E]
.    tr \['e]\['E]
.    tr \[:e]\[:E]
.    tr \[`i]\[`I]
.    tr \[^i]\[^I]
.    tr \['i]\['I]
.    tr \[:i]\[:I]
.    tr \[`o]\[`O]
.    tr \[^o]\[^O]
.    tr \['o]\['O]
.    tr \[:o]\[:O]
.    tr \[~o]\[~O]
.    tr \[/o]\[/O]
.    tr \[`u]\[`U]
.    tr \[^u]\[^U]
.    tr \['u]\['U]
.    tr \[:u]\[:U]
.    tr \[,c]\[,C]
.    tr \[Sd]\[-D]
.    tr \[~n]\[~N]
.    tr \[Tp]\[TP]
.    tr \['y]\['Y]
.    tr \[:y]\[:Y]
.    nr #CAPS_ON 1
.END
\#
.MAC LC END
\c
.    tr aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz
.    tr \[`a]\[`a]
.    tr \[^a]\[^a]
.    tr \['a]\['a]
.    tr \[:a]\[:a]
.    tr \[oa]\[oa]
.    tr \[~a]\[~a]
.    tr \[ae]\[ae]
.    tr \[`e]\[`e]
.    tr \[^e]\[^e]
.    tr \['e]\['e]
.    tr \[:e]\[:e]
.    tr \[`i]\[`i]
.    tr \[^i]\[^i]
.    tr \['i]\['i]
.    tr \[:i]\[:i]
.    tr \[`o]\[`o]
.    tr \[^o]\[^o]
.    tr \['o]\['o]
.    tr \[:o]\[:o]
.    tr \[~o]\[~o]
.    tr \[/o]\[/o]
.    tr \[`u]\[`u]
.    tr \[^u]\[^u]
.    tr \['u]\['u]
.    tr \[:u]\[:u]
.    tr \[,c]\[,c]
.    tr \[Sd]\[Sd]
.    tr \[~n]\[~n]
.    tr \[Tp]\[Tp]
.    tr \['y]\['y]
.    tr \[:y]\[:y]
.    rr #CAPS_ON
.END
\#
\# SIZESPECS
\# ---------
\# Argument:
\#   <none>
\# Function:
\#   Gets cap-height, x-height, and descender depth of the
\#   current font at the current point size.
\# *Notes:
\#   The routine is diverted so it remains invisible to output.
\#
.MAC SIZESPECS END
.    if '\\n[.z]'FLOAT*DIV' \
.       if \\n[dn] .nr saved-dn \\n[dn]
.    di TYPESIZE
E\R'#CAP_HEIGHT \\n[.cht]'
e\R'#X_HEIGHT \\n[.cht]'
y\R'#DESCENDER \\n[.cdp]'
.    br
.    ds $CAP_HEIGHT \\n[#CAP_HEIGHT]u
.    ds $X_HEIGHT \\n[#X_HEIGHT]u
.    ds $DESCENDER \\n[#DESCENDER]u
.    di
.    if '\\n[.z]'FLOAT*DIV' \
.       nr dn \\n[saved-dn]
.END
\#
\# =====================================================================
\#
\# +++TYPESETTING ALIASES+++
\#
.ALIAS    ADD_SPACE       ALD
.ALIAS    CENTRE          CENTER
.ALIAS    COLOUR          COLOR
.ALIAS    COMMENT         SILENT
.ALIAS    CONDENSE        CONDENSE_OR_EXTEND
.ALIAS    EXTEND          CONDENSE_OR_EXTEND
.ALIAS    FAM             FAMILY
.ALIAS    FONT            FT
.ALIAS    HYPHENATE       HY
.ALIAS    HYPHENATION     HY
.ALIAS    HYSET           HY_SET
.ALIAS    IBQ             IBX
.ALIAS    ILQ             ILX
.ALIAS    IQ              IX
.ALIAS    IRQ             IRX
.ALIAS    LIG             LIGATURES
.ALIAS    NEWCOLOUR       NEWCOLOR
.ALIAS    PADMARKER       PAD_MARKER
.ALIAS    SP              ALD
.ALIAS    SPACE           ALD
.ALIAS    TABSET          TAB_SET
.ALIAS    TB              TAB
.ALIAS    UNDERSCORE_2    UNDERSCORE2
.ALIAS    XCOLOUR         XCOLOR
.ALIAS    PDF_LINK_COLOUR PDF_LINK_COLOR
.ALIAS    AUTO_TOC_RELOCATE AUTO_RELOCATE_TOC
\#
\# ====================================================================
\#
\# DOCUMENT PROCESSING MACROS, STRINGS AND ALIASES
\# ===============================================
\#
\# DOC_MACRO_ERROR
\# ----------
\# *Arguments:
\#   None.
\# *Function:
\#   Warning message if DOC_<PARAMETER> called before START.
\#
.MAC DOC_MACRO_ERROR END
.    if '\\$1'DOC_L_MARGIN'    .ds $REPLACEMENT L_MARGIN
.    if '\\$1'DOC_R_MARGIN'    .ds $REPLACEMENT R_MARGIN
.    if '\\$1'DOC_LINE_LENGTH' .ds $REPLACEMENT LL
.    if '\\$1'DOC_FAMILY'      .ds $REPLACEMENT "FAMILY or FAM
.    if '\\$1'DOC_PT_SIZE'     .ds $REPLACEMENT PT_SIZE
.    if '\\$1'DOC_LEAD'        .ds $REPLACEMENT LS
.    if '\\$1'DOC_QUAD'        .ds $REPLACEMENT QUAD
.    tm1 "[mom]: \\$1 at line \\n[.c] of '\\n[.F]' should not be used before START.
.    tm1 "       Use \\*[$REPLACEMENT] instead.
.    ab  Aborting.
.END
\#
\# +++PAGE DIMENSIONS+++
\#
\# PAPER SIZE
\# ----------
\# *Arguments:
\#   LETTER | LEGAL | STATEMENT | TABLOID | LEDGER | FOLIO | QUARTO | 10x14 | EXECUTIVE | A3 | A4 | A5 | B4 | B5
\# *Function:
\#   Sets up dimensions for different paper sizes.
\#
.MAC PAPER END
.    ds $PAPER \\$1
.    if '\\*[$PAPER]'LETTER' \{\
.       PAGEWIDTH  8.5i
.       PAGELENGTH 11i
.    \}
.    if '\\*[$PAPER]'LEGAL' \{\
.       PAGEWIDTH  8.5i
.       PAGELENGTH 14i
.    \}
.    if '\\*[$PAPER]'STATEMENT' \{\
.       PAGEWIDTH  5.5i
.       PAGELENGTH 8.5i
.    \}
.    if '\\*[$PAPER]'TABLOID' \{\
.       PAGEWIDTH  11i
.       PAGELENGTH 17i
.    \}
.    if '\\*[$PAPER]'LEDGER' \{\
.       PAGEWIDTH  17i
.       PAGELENGTH 11i
.    \}
.    if '\\*[$PAPER]'FOLIO' \{\
.       PAGEWIDTH  8.5i
.       PAGELENGTH 13i
.    \}
.    if '\\*[$PAPER]'QUARTO' \{\
.       PAGEWIDTH  610p
.       PAGELENGTH 780p
.    \}
.    if '\\*[$PAPER]'10x14' \{\
.       PAGEWIDTH  10i
.       PAGELENGTH 14i
.    \}
.    if '\\*[$PAPER]'EXECUTIVE' \{\
.       PAGEWIDTH  7.25i
.       PAGELENGTH 10.5i
.    \}
.    if '\\*[$PAPER]'A3' \{\
.       PAGEWIDTH  842p
.       PAGELENGTH 1190p
.    \}
.    if '\\*[$PAPER]'A4' \{\
.       PAGEWIDTH  595p
.       PAGELENGTH 842p
.    \}
.    if '\\*[$PAPER]'A5' \{\
.       PAGEWIDTH  421p
.       PAGELENGTH 595p
.    \}
.    if '\\*[$PAPER]'B4' \{\
.       PAGEWIDTH  709p
.       PAGELENGTH 1002p
.    \}
.    if '\\*[$PAPER]'B5' \{\
.       PAGEWIDTH  501p
.       PAGELENGTH 709p
.    \}
.    if '\\$2'LANDSCAPE' \{\
.       nr #PAGE_WIDTH_TMP \\n[#PAGE_WIDTH]
.       PAGEWIDTH \\n[#PAGE_LENGTH]u
.       PAGELENGTH \\n[#PAGE_WIDTH_TMP]u
.    \}
.    if !r#L_MARGIN .L_MARGIN \\n[.o]
.    if !r#R_MARGIN .R_MARGIN 1i
.END
\#
\# ====================================================================
\#
\# +++PRINTSTYLE -- TYPEWRITE OR TYPESET+++
\#
\# PRINTSTYLE
\# ----------
\# *Arguments:
\#   TYPESET | TYPEWRITE [SINGLESPACE]
\# *Function:
\#   Sets type specs for typewriter-style or typeset output.
\# *Notes:
\#   Number registers: TYPEWRITE=1, TYPESET=2.
\#
.MAC PRINTSTYLE END
.    if !\\n[#COLLATE]=1 \{\
.       if !d$PAPER .PAPER LETTER
.       if '\\$1'TYPEWRITE' \{\
.          nr #PRINT_STYLE 1
.          if !\\n[#DOC_TYPE]=4 .L_MARGIN 6P
.          if !\\n[#DOC_TYPE]=4 .R_MARGIN 6P
.          ds $TYPEWRITER_FAM C
.          ds $TYPEWRITER_PS  12
.          TYPEWRITER
.          color 0
.          ie '\\$2'SINGLESPACE' \{\
.             nr #SINGLE_SPACE 1
.             vs 12
.             ie \\n[#DOC_TYPE]=4 .nr #FOOTER_ADJ \\n[.v]
.             el .nr #FOOTER_ADJ \\n[.v]*2
.             nr #ORIGINAL_DOC_LEAD \\n[.v]
.          \}
.          el \{\
.             if !\\n[#DOC_TYPE]=4 \{\
.                vs 24
.                nr #FOOTER_ADJ \\n[.v]/2
.                nr #ORIGINAL_DOC_LEAD \\n[.v]
.             \}
.          \}
.          QUAD    L
.          HY      OFF
.          SMARTQUOTES OFF
.          if !\\n[#PP_INDENT] .nr #PP_INDENT 3P
.          HDRFTR_RIGHT_CAPS
.          nr #BOLDER_UNITS 0
.          nr #CONDENSE 0
.          nr #EXTEND 0
.          if !\\n[#ITALIC_MEANS_ITALIC] .rm IT
.          rm BD
.          rm BDI
.          if !\\n[#ITALIC_MEANS_ITALIC] .rm PREV
.          if !\\n[#SLANT_MEANS_SLANT]   .UNDERLINE_SLANT
.          if !\\n[#ITALIC_MEANS_ITALIC] .UNDERLINE_ITALIC
.          if !\\n[#UNDERLINE_QUOTES]    .UNDERLINE_QUOTES
.          nr #IGNORE_COLUMNS 1
.          nr #RULE_WEIGHT 500
.          char \[em] --
.          tr `'
.          tr \[lq]"
.          tr \[rq]"
.       \}
.       if '\\$1'TYPESET' \{\
.          nr #PRINT_STYLE 2
.          if !\\n[#DOC_TYPE]=4 .L_MARGIN 6P
.          if !\\n[#DOC_TYPE]=4 .R_MARGIN 6P
.          FAMILY  T
.          FT      R
.          if !\\n[#DOC_TYPE]=4 .ps 12.5
.          if !\\n[#DOC_TYPE]=4 .vs 16
.\" In DEFAULTS, TRAPS is run with this leading, so we need a register to
.\" hold it for use with the .sp in FOOTER
.          nr #FOOTER_ADJ 12000
.          JUSTIFY
.          HY
.          HY_SET 2 36p 1p
.          KERN
.          LIG
.          SS 0
.          SMARTQUOTES
.          if !\\n[#PP_INDENT] \{\
.             in 2m                 \"Set indent
.             nr #PP_INDENT \\n[.i] \"Read into #PP_INDENT
.             in 0                  \"Remove indent
.          \}
.          HDRFTR_RIGHT_CAPS
.          rr #IGNORE_COLUMNS
.       \}
.\" Set up default style for nine levels of headings
.       nr #HD_LEVEL 0 1 \" loop step
.       nr #LOOP 9       \" loop count
.       while \\n+[#HD_LEVEL]<=\\n[#LOOP] \{\
.           HEADING_STYLE \\n[#HD_LEVEL] \
            FONT   B \
            SIZE  +0 \
            QUAD   L \
            COLOR  black
.\"  Set up default style for nine levels of TOC headings
.           TOC_ENTRY_STYLE \\n[#HD_LEVEL] \
            FONT   R \
            SIZE  +0 \
            COLOR  black
.       \}
.\" Set up decreasing sizes for headings levels 1 - 3, starting at +3
.       nr #HD_LEVEL 0 1 \" loop step
.       nr #LOOP 3       \" loop count
.       nr #HD_SIZE 4 1
.       while \\n+[#HD_LEVEL]<=\\n[#LOOP] \{\
.          nr #HD_SIZE_CHANGE \\n-[#HD_SIZE]
.          ds $HEAD_\\n[#HD_LEVEL]_SIZE +\\n[#HD_SIZE_CHANGE]
.       \}
.\" Set up TOC title style
.       TOC_TITLE_STYLE FONT R SIZE +0 INDENT 0
.\" Set up captions, labels, sources
.       LABELS ALL FONT B AUTOLEAD 2
.       LABELS EQN FONT R QUAD RIGHT
.       CAPTIONS ALL AUTOLEAD 2
.       CAPTIONS EQN QUAD CENTER
.       SOURCES TBL AUTOLEAD 2
.    \}
.END
\#
\# PRINTSTYLE TYPEWRITE control.
\#
.MAC TYPEWRITER_FAMILY END
.    ds $TYPEWRITER_FAM \\$1
.END
\#
.ALIAS TYPEWRITER_FAM TYPEWRITER_FAMILY
\#
.MAC TYPEWRITER_SIZE END
.    ds $TYPEWRITER_PS \\$1
.END
\#
.MAC TYPEWRITER END
.    fam \\*[$TYPEWRITER_FAM]
.    ft  R
.    ps  \\*[$TYPEWRITER_PS]
.END
\#
\# ITALIC MEANS ITALIC
\# -------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Instructs TYPEWRITE to treat italics as italics, whether
\#   invoked via control lines or inline.
\# *Notes:
\#   ITALIC_MEANS_ITALIC and UNDERLINE_ITALIC are mututally exclusive,
\#   hence invoking the one automatically turns off the other.
\#
.MAC ITALIC_MEANS_ITALIC END
.    if \\n[#PRINT_STYLE]=1 \{\
.       nr #ITALIC_MEANS_ITALIC 1
.       rr #UNDERLINE_ITALIC
.       rm ROM
.       rm IT
.       rm PREV
.       ds ROM  \Ef[R]
.       ds IT   \Ef[I]
.       ds PREV \Ef[]
.    \}
.END
\#
\# UNDERLINE ITALIC
\# ----------------
\# *Argument:
\#   <none>
\# *Function:
\#   Instructs TYPEWRITE to underline italics, whether invoked
\#   via control lines or inline.
\# *Notes:
\#   UNDERLINE_ITALIC and ITALIC_MEANS_ITALIC are mututally exclusive,
\#   hence invoking the one automatically turns off the other.
\#
\#   UNDERLINE_ITALIC is the default for TYPEWRITE.
\#
.MAC UNDERLINE_ITALIC END
.    if \\n[#PRINT_STYLE]=1 \{\
.       nr #UNDERLINE_ITALIC 1
.       rr #ITALIC_MEANS_ITALIC
.       rm ROM
.       rm IT
.       rm PREV
.       ds ROM  \E*[ULX]
.       ds IT   \E*[UL]
.       ds PREV \E*[ULX]
.    \}
.END
\#
\# UNDERLINE SLANT
\# ---------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Instructs TYPEWRITE to underline occurrences of \*[SLANT], or
\#   turns feature off.
\# *Notes:
\#   Users may want \*[SLANT] to mean slant in TYPEWRITE, although
\#   most of the time, \*[SLANT] most likely means the user wanted
\#   italic but didn't have it, ergo the need to tell TYPEWRITE to
\#   treat \*[SLANT] as italic (i.e. underlined).
\#
\#   UNDERLINE_SLANT and SLANT_MEANS_SLANT are mututally exclusive,
\#   hence invoking the one automatically turns off the other.
\#
\#   UNDERLINE_SLANT is the default for TYPEWRITE.
\#
.MAC UNDERLINE_SLANT END
.    if \\n[#PRINT_STYLE]=1 \{\
.       rr #SLANT_MEANS_SLANT
.       nr #UNDERLINE_SLANT 1
.       rm SLANT
.       rm SLANTX
.       ds SLANT  \ER'#SLANT_ON 1'\E*[UL]
.       ds SLANTX \ER'#SLANT_ON 0'\E*[ULX]
.    \}
.END
\#
.MAC SLANT_MEANS_SLANT END
.    if \\n[#PRINT_STYLE]=1 \{\
.       rr #UNDERLINE_SLANT
.       nr #SLANT_MEANS_SLANT 1
.       rm SLANT
.       rm SLANTX
.       ds SLANT  \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.       ds SLANTX \ER'#SLANT_ON 0'\ES'0'
.    \}
.END
\#
.MAC IGNORE_COLUMNS END
.    if \\n[#PRINT_STYLE]=1 .nr #NO_COLUMNS 1
.END
\#
\# ====================================================================
\#
\# +++COPY STYLE -- DRAFT OR FINAL+++
\#
\# COPY STYLE
\# ----------
\# *Arguments:
\#   DRAFT | FINAL
\# *Function:
\#   Sets registers that are used to determine what to put
\#   in the default header, and how to number pages.
\# *Notes:
\#   DOCTYPE must come before COPYSTYLE.
\#
.MAC COPYSTYLE END
.    ds $COPY_STYLE \\$1
.    if '\\*[$COPY_STYLE]'DRAFT' \{\
.       nr #COPY_STYLE 1
.       if !d$DRAFT .DRAFT 1
.    \}
.    if '\\*[$COPY_STYLE]'FINAL' .nr #COPY_STYLE 2
.    if !d$CHAPTER_STRING  .CHAPTER_STRING "Chapter"
.    if !d$DRAFT_STRING    .DRAFT_STRING "Draft"
.    if !d$REVISION_STRING .REVISION_STRING "Rev."
.\" Default
.    if \\n[#DOC_TYPE]=1 \{\
.       ie \\n[#COPY_STYLE]=1 \{\
.          ie \\n[#PAGENUM_STYLE_SET] .PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.          el .PAGENUM_STYLE roman
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#DRAFT_WITH_PAGENUM] .ds $HDRFTR_CENTER
.             el \{\
.                ie '\\*[$REVISION]'' \{\
.                   ds $HDRFTR_CENTER \
                    \\*[$DRAFT_STRING]\\*[$DRAFT]
.                \}
.                el \{\
.                   ds $HDRFTR_CENTER \
                    \\*[$DRAFT_STRING]\\*[$DRAFT], \
                    \\*[$REVISION_STRING] \\*[$REVISION]
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          ie \\n[#PAGENUM_STYLE_SET] .PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.          el                         .PAGENUM_STYLE DIGIT
.          if \\n[#DRAFT_WITH_PAGENUM] .rr #DRAFT_WITH_PAGENUM
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ds $HDRFTR_CENTER
.             rr #USER_DEF_HDRFTR_CENTER
.          \}
.       \}
.    \}
.\" Chapter
.    if \\n[#DOC_TYPE]=2 \{\
.\" Copystyle DRAFT
.       ie \\n[#COPY_STYLE]=1 \{\
.          ie \\n[#PAGENUM_STYLE_SET] \
.             PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.          el \
.             PAGENUM_STYLE roman
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#DRAFT_WITH_PAGENUM] \{\
.                ie '\\*[$CHAPTER]'' \{\
.                   ie !'\\*[$CHAPTER_TITLE_1]'' \
.                       ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                   el .ds $HDRFTR_CENTER \\*[$CHAPTER_STRING]
.                \}
.                el \{\
.                   ie !'\\*[$CHAPTER_TITLE_1]'' \
.                       ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                   el .ds $HDRFTR_CENTER \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.                \}
.             \}
.             el \{\
.                ie '\\*[$REVISION]'' \{\
.                   ie '\\*[$CHAPTER]'' \{\
.                      ie !'\\*[$CHAPTER_TITLE_1]'' \{\
.                         ie '\\*[$DRAFT]'' \
.                            ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                   \}
.                   el \{\
.                      ie !'\\*[$CHAPTER_TITLE_1]'' \{\
.                         ie '\\*[$DRAFT]'' \
.                            ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE_1], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                   \}
.                \}
.                el \{\
.                   ie '\\*[$CHAPTER]'' \{\
.                      ie !'\\*[$CHAPTER_TITLE_1]'' \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                      \}
.                   \}
.                   el \{\
.                      ie !'\\*[$CHAPTER_TITLE_1]'' \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                      \}
.                   \}
.                \}
.             \}
.          \}
.       \}
.\" Copystyle FINAL
.       el \{\
.          if \\n[#DRAFT_WITH_PAGENUM] .rr #DRAFT_WITH_PAGENUM
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#PAGENUM_STYLE_SET] \
.                PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.             el .PAGENUM_STYLE DIGIT
.             ie '\\*[$CHAPTER]'' \{\
.                ie !'\\*[$CHAPTER_TITLE_1]'' \
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                el \
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_STRING]
.             \}
.             el \{\
.                ie !'\\*[$CHAPTER_TITLE_1]'' \
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                el \
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.             \}
.          \}
.       \}
.    \}
.\" Named
.    if \\n[#DOC_TYPE]=3 \{\
.       ie \\n[#COPY_STYLE]=1 \{\
.          ie \\n[#PAGENUM_STYLE_SET] .PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.          el                         .PAGENUM_STYLE roman
.          ie \\n[#DRAFT_WITH_PAGENUM] \
.             ds $HDRFTR_CENTER \\*[$DOC_TYPE]
.          el \{\
.             if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.                ie '\\*[$REVISION]'' \{\
.                   ie '\\*[$DRAFT]'' \
.                      ds $HDRFTR_CENTER \\*[$DOC_TYPE]
.                   el \{\
.                      ds $HDRFTR_CENTER \
                       \\*[$DOC_TYPE], \
                       \\*[$DRAFT_STRING]\\*[$DRAFT]
.                   \}
.                \}
.                el \{\
.                   ie '\\*[$DRAFT]'' \{\
.                      ds $HDRFTR_CENTER \
                       \\*[$DOC_TYPE], \
                       \\*[$REVISION_STRING] \\*[$REVISION]
.                   \}
.                   el \{\
.                      ds $HDRFTR_CENTER \
                       \\*[$DOC_TYPE], \
                       \\*[$DRAFT_STRING]\\*[$DRAFT], \
                       \\*[$REVISION_STRING] \\*[$REVISION]
.                   \}
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          if \\n[#DRAFT_WITH_PAGENUM] .rr #DRAFT_WITH_PAGENUM
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#PAGENUM_STYLE_SET] .PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.             el .PAGENUM_STYLE DIGIT
.             ds $HDRFTR_CENTER \\*[$DOC_TYPE]
.          \}
.       \}
.    \}
.END
\#
\# ====================================================================
\#
\# +++COLLECT DOC INFO -- STRINGS AND REGISTERS FOR REFERENCE MACROS+++
\#
\# *Arguments:
\#   various string/register arguments
\# *Function:
\#   Collect information about documents.
\#
.MAC DOCTITLE END
.    rr #DOCTITLE_NUM
.    nr #DOCTITLE_NUM 0 1
.    while \\n[#NUM_ARGS]>\\n[#DOCTITLE_NUM] \{\
.       ds $DOC_TITLE_\\n+[#DOCTITLE_NUM] \\$\\n[#DOCTITLE_NUM]
.    \}
.    ds $DOC_TITLE \\$*
.    PDF_TITLE \\*[$DOC_TITLE]
.END
\#
.MAC TITLE END \"Document title
.    ie \\n[#NUM_ARGS]=0 \{\
.       if \\n[#TITLE_NUM] \{\
.          nr #ITEM 0 1
.          while \\n[#TITLE_NUM]>\\n[#ITEM] \{\
.             rm $TITLE_\\n+[#ITEM]
.          \}
.          rr #TITLE_NUM
.       \}
.    \}
.    el \{\
.       nr #TITLE_NUM 0 1
.       while \\n[#NUM_ARGS]>\\n[#TITLE_NUM] \{\
.          ds $TITLE_\\n+[#TITLE_NUM] \\$\\n[#TITLE_NUM]
.       \}
.       ds $TITLE \\$*
.    \}
.END
\#
.MAC SUBTITLE END \"Document sub-title
.    ie \\n[#NUM_ARGS]=0 \{\
.       if \\n[#SUBTITLE_NUM] \{\
.          nr #ITEM 0 1
.          while \\n[#SUBTITLE_NUM]>\\n[#ITEM] \{\
.             rm $SUBTITLE_\\n+[#ITEM]
.          \}
.          rr #SUBTITLE_NUM
.          rm $SUBTITLE
.       \}
.    \}
.    el \{\
.       if '\\$1'DOC_COVER' \{\
.          shift
.          nr #SUBTITLE_DOC_COVER_NUM 0 1
.          while \\n[#NUM_ARGS]>\\n[#SUBTITLE_DOC_COVER_NUM] \{\
.              ds $SUBTITLE_DOC_COVER_\\n+[#SUBTITLE_DOC_COVER_NUM] \
\\$\\n[#SUBTITLE_DOC_COVER_NUM]
.          \}
.          return
.       \}
.       if '\\$1'COVER' \{\
.          shift
.          nr #SUBTITLE_COVER_NUM 0 1
.          while \\n[#NUM_ARGS]>\\n[#SUBTITLE_COVER_NUM] \{\
.              ds $SUBTITLE_COVER_\\n+[#SUBTITLE_COVER_NUM] \
\\$\\n[#SUBTITLE_COVER_NUM]
.          \}
.          return
.       \}
.       nr #SUBTITLE_NUM 0 1
.       while \\n[#NUM_ARGS]>\\n[#SUBTITLE_NUM] \{\
.          ds $SUBTITLE_\\n+[#SUBTITLE_NUM] \\$\\n[#SUBTITLE_NUM]
.       \}
.          ds $SUBTITLE \\$*
.    \}
.END
\#
.MAC CHAPTER END \"If document is a chapter, the chapter number
.    nr #CHAPTER_CALLED 1
.    ds $CHAPTER \\$1
.    if r #CH_NUM \
.       if \B'\\*[$CHAPTER]' .nr #CH_NUM \\*[$CHAPTER]
.END
\#
.MAC CHAPTER_TITLE END \" This defines what comes after Chapter #
.    ie \\n[#NUM_ARGS]=0 \{\
.       if \\n[#CHAPTER_TITLE_NUM] \{\
.          nr #ITEM 0 1
.          while \\n[#CHAPTER_TITLE_NUM]>\\n[#ITEM] \{\
.             rm $CHAPTER_TITLE_\\n+[#ITEM]
.          \}
.          rr #CHAPTER_TITLE_NUM
.          rm $CHAPTER_TITLE
.       \}
.    \}
.    el \{\
.       rr #CHAPTER_TITLE_NUM
.       nr #CHAPTER_TITLE_NUM 0 1
.       while \\n[#NUM_ARGS]>\\n[#CHAPTER_TITLE_NUM] \{\
.          ds $CHAPTER_TITLE_\\n+[#CHAPTER_TITLE_NUM] \
\\$\\n[#CHAPTER_TITLE_NUM]
.       \}
.       ds $CHAPTER_TITLE \\$*
.    \}
.END
\#
.MAC DRAFT END \"Draft number
.    ie '\\$1'' .ds $DRAFT
.    el .ds $DRAFT " \\$1
.END
\#
.MAC REVISION END \"Revision number
.    ds $REVISION \\$1
.END
\#
.MAC DRAFT_WITH_PAGENUMBER END \"Attach draft/revision strings to page number
.    nr #DRAFT_WITH_PAGENUM 1
.END
\#
.MAC AUTHOR END \"Author.  Enclose all args fully in double quotes.
.    if '\\$1'DOC_COVER' \{\
.       shift
.       nr #AUTHOR_DOCCOVER_NUM 0 1
.       while \\n[#NUM_ARGS]>\\n[#AUTHOR_DOCCOVER_NUM] \{\
.           ds $AUTHOR_DOCCOVER_\\n+[#AUTHOR_DOCCOVER_NUM] \
\\$\\n[#AUTHOR_DOCCOVER_NUM]
.       \}
.       return
.    \}
.    if '\\$1'COVER' \{\
.       shift
.       nr #AUTHOR_COVER_NUM 0 1
.           while \\n[#NUM_ARGS]>\\n[#AUTHOR_COVER_NUM] \{\
.              ds $AUTHOR_COVER_\\n+[#AUTHOR_COVER_NUM] \\$\\n[#AUTHOR_COVER_NUM]
.           \}
.       return
.    \}
.    nr #AUTHOR_NUM 0 1
.    rm $AUTHORS
.    while \\n[#NUM_ARGS]>\\n[#AUTHOR_NUM] \{\
.       ds $AUTHOR_\\n+[#AUTHOR_NUM] \\$\\n[#AUTHOR_NUM]
.       as $AUTHORS \\*[$AUTHOR_\\n[#AUTHOR_NUM]], \"
.    \}
.    ds $AUTHOR \\*[$AUTHOR_1]
.    substring $AUTHORS 0 -2
.    ds PDF_AUTHORS \\*[$AUTHORS]
.    pdfmomclean PDF_AUTHORS
.    nop \!x X ps:exec [/Author (\\*[PDF_AUTHORS]) /DOCINFO pdfmark
.END
\#
.ALIAS EDITOR AUTHOR
\#
.MAC COPYRIGHT END          \"For use on cover pages only
.   ie \\n[#NUM_ARGS]=1 \{\
.       ds $COPYRIGHT \[co]\\$1
.       rm $COPYRIGHT_DOCCOVER
.       rm $COPYRIGHT_COVER
.    \}
.    el \{\
.       if '\\$1'DOC_COVER' .ds $COPYRIGHT_DOCCOVER \[co]\\$2
.       if '\\$1'COVER'     .ds $COPYRIGHT_COVER \[co]\\$2
.    \}
.END
\#
.MAC MISC END \"For use on cover pages only; enclose all args in double quotes
.    ie \\n[#NUM_ARGS]=0 \{\
.       if \\n[#MISC_NUM] \{\
.          nr #ITEM 0 1
.          while \\n[#MISC_NUM]>\\n[#ITEM] \{\
.             rm $MISC_\\n+[#ITEM]
.          \}
.          rr #MISC_NUM
.          rr #NUM_MISCS
.       \}
.       if \\n[#MISC_DOC_COVER_NUM] \{\
.          nr #ITEM 0 1
.          while \\n[#MISC_DOC_COVER_NUM]>\\n[#ITEM] \{\
.             rm $MISC_DOC_COVER_\\n+[#ITEM]
.          \}
.          rr #MISC_DOC_COVER_NUM
.          rr #NUM_MISCS
.       \}
.       if \\n[#MISC_COVER_NUM] \{\
.          nr #ITEM 0 1
.          while \\n[#MISC_COVER_NUM]>\\n[#ITEM] \{\
.             rm $MISC_COVER_\\n+[#ITEM]
.          \}
.          rr #MISC_COVER_NUM
.          rr #NUM_MISCS
.       \}
.    \}
.    el \{\
.       if !'\\$1'DOC_COVER' \{\
.         if !'\\$1'COVER' .nr #NEITHER 1
.       \}
.       if !'\\$1'COVER' \{\
.          if !'\\$1'DOC_COVER' .nr #NEITHER 1
.       \}
.       if '\\$1'DOC_COVER' \{\
.          shift
.          nr #MISC_DOC_COVER_NUM 0 1
.          while \\n[#NUM_ARGS]>\\n[#MISC_DOC_COVER_NUM] \{\
.             ds $MISC_DOC_COVER_\\n+[#MISC_DOC_COVER_NUM] \
\\$[\\n[#MISC_DOC_COVER_NUM]]
.          \}
.          nr #NUM_MISCS_DOCCOVER \\n[#NUM_ARGS]
.       \}
.       if '\\$1'COVER' \{\
.          shift
.          nr #MISC_COVER_NUM 0 1
.          while \\n[#NUM_ARGS]>\\n[#MISC_COVER_NUM] \{\
.             ds $MISC_COVER_\\n+[#MISC_COVER_NUM] \\$[\\n[#MISC_COVER_NUM]]
.          \}
.          nr #NUM_MISCS_COVER \\n[#NUM_ARGS]
.       \}
.       if \\n[#NEITHER]=1 \{\
.          nr #MISC_NUM 0 1
.          while \\n[#NUM_ARGS]>\\n[#MISC_NUM] \{\
.             ds $MISC_\\n+[#MISC_NUM] \\$[\\n[#MISC_NUM]]
.          \}
.          nr #NUM_MISCS \\n[#NUM_ARGS]
.          rr #NEITHER
.       \}
.   \}
.END
\#
.MAC PAGENUMBER END \"Page # that appears on page one.
.    nr #n%_AT_PAGENUM_SET \\n%
.    nr #PAGE_NUM_ADJ \\$1-\\n[#n%_AT_PAGENUM_SET]
.    rr #n%_AT_PAGENUM_SET
.    nr #PAGE_NUM_SET 1
.END
\#
\# ====================================================================
\#
\# +++TYPE OF DOCUMENT+++
\#
\# DOCUMENT TYPE
\# -------------
\# *Argument:
\#   DEFAULT | CHAPTER | NAMED "<whatever> | LETTER
\# *Function:
\#   Creates strings and sets registers for document types.
\# *Notes:
\#   Number registers: DEFAULT=1, CHAPTER=2, NAMED=3, LETTER=4
\#
.MAC DOCTYPE END
.    if '\\$1'DEFAULT' .nr #DOC_TYPE 1
.    if '\\$1'CHAPTER' .nr #DOC_TYPE 2
.    if '\\$1'NAMED' \{\
.       ds $DOC_TYPE \\$2
.       nr #DOC_TYPE 3
.    \}
.    if '\\$1'LETTER' \{\
.       nr #DOC_TYPE 4
.       L_MARGIN 1.125i
.       R_MARGIN 1.125i
.       ps 12
.       vs 13.5
.       nr #FOOTER_ADJ \\n[.v]
.       DOCHEADER OFF
.       PARA_INDENT 3m
.       INDENT_FIRST_PARAS
.       PARA_SPACE
.       ds $SUITE \En[#SUITE]
.       HEADER_MARGIN 3P+6p
.       HEADER_GAP 3P
.       FOOTERS
.       FOOTER_RULE OFF
.       FOOTER_LEFT ""
.       FOOTER_CENTER ""
.       FOOTER_RIGHT_SIZE +0
.       FOOTER_RIGHT "\&.../\E*[$SUITE]
.       FOOTER_ON_FIRST_PAGE
.       em ALL_DONE
.    \}
.END
\#
\# +++LETTER MACROS+++
\#
\# First, create a register to hold incrementing numbers to be
\# appended to LETTERHEAD.
\#
.nr #FIELD 0 1
\#
\# DATE
\# ----
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores date (entered on the line after .DATE) in diversion
\#   LETTERHEAD<n>
\#
.MAC DATE END
.    if !'\\n[.z]'' .di
.    di LETTERHEAD\\n+[#FIELD]
.    ie \\n[#FIELD]=1 \{\
.       nr #DATE_FIRST 1
.       RIGHT
.    \}
.    el .LEFT
.END
\#
\# TO
\# --
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores addressee address (entered on the line after .TO) in
\#   diversion LETTERHEAD<n>
\#
.MAC TO END
.    if !'\\n[.z]'' .di
.    di LETTERHEAD\\n+[#FIELD]
.    LEFT
.END
\#
\# FROM
\# ----
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores addresser address (entered on the line after .FROM) in
\#   diversion LETTERHEAD<n>
\#
.MAC FROM END
.    if !'\\n[.z]'' .di
.    di LETTERHEAD\\n+[#FIELD]
.    LEFT
.END
\#
\# GREETING
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores greeting (entered on the line after .GREETING) in
\#   diversion LETTERHEAD<n>
\#
.MAC GREETING END
.    if !'\\n[.z]'' .di
.    di LETTERHEAD\\n+[#FIELD]
.    LEFT
.END
\#
\# CLOSING
\# -------
\# *Arguments:
\#   <closing string>
\# *Function:
\#   Stores greeting in diversion CLOSING.
\#
.MAC CLOSING END
.    if '\\*[$SIG_SPACE]'' .ds $SIG_SPACE 3v
.    ie ( (2v+\\*[$SIG_SPACE]) > \\n[.t] ) \{\
.       ch HEADER
.       ch FOOTER
.       br
.       tm1 "[mom]: Insufficient room for \\$0 and signature line.
.       ab Aborting '\\n[.F]'.
.    \}
.    el .br
.    nr #CLOSING 1
.    di CLOSING_TEXT
.END
\#
\# CLOSING INDENT
\# --------------
\# *Argument:
\#   <amount to indent closing from left margin>
\# *Function:
\#   Defines string $CLOSE_INDENT for use in macro, ALL_DONE.
\#
.MAC CLOSING_INDENT END
.    ds $CLOSE_INDENT \\$1
.END
\#
\# SIGNATURE_SPACE
\# ---------------
\# *Argument:
\#   <amount of space to leave for signature>
\# *Function:
\#   Defines string $SIG_SPACE for use in macro, ALL_DONE.
\#
.MAC SIGNATURE_SPACE END
.    ds $SIG_SPACE \\$1
.END
\#
\# NO SUITE
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Redefines $FOOTER_RIGHT to blank so that a suite number doesn't
\#   appear at the bottom of letter pages.
\#
.MAC NO_SUITE END
.    FOOTER_RIGHT ""
.END
\#
\# ====================================================================
\#
\# +++DEFAULTS+++
\#
\# TYPE-STYLE CONTROL MACROS
\# -------------------------
\# The control macros for family, font, size, quad and color are here
\# grouped together.  Each (e.g. _FAMILY or _FONT) tests for a calling
\# alias before performing the action(s) appropriate to the calling
\# macro.  Defaults for all these guys are set in DEFAULTS, and listed
\# in the "Control Macros" section of the documentation pertinent to
\# the macro whose style is to be changed.
\#
.MAC _FAMILY END
.    if '\\$0'AUTHOR_FAMILY' \
.       ds $AUTHOR_FAM \\$1
.    if '\\$0'BIBLIOGRAPHY_FAMILY' \
.       ds $BIB_FAM \\$1
.    if '\\$0'BIBLIOGRAPHY_STRING_FAMILY' \
.       ds $BIB_STRING_FAM \\$1
.    if '\\$0'BLOCKQUOTE_FAMILY' \
.       ds $BQUOTE_FAM \\$1
.    if '\\$0'CITATION_FAMILY' \
.       ds $BQUOTE_FAM \\$1
.    if '\\$0'CITE_FAMILY' \
.       ds $BQUOTE_FAM \\$1
.    if '\\$0'CHAPTER_TITLE_FAMILY' \
.       ds $CHAPTER_TITLE_FAM \\$1
.    if '\\$0'COVER_AUTHOR_FAMILY' \
.       ds $COVER_AUTHOR_FAM \\$1
.    if '\\$0'COVER_CHAPTER_TITLE_FAMILY' \
.       ds $COVER_CHAPTER_TITLE_FAM \\$1
.    if '\\$0'COVER_COPYRIGHT_FAMILY' \
.       ds $COVER_COPYRIGHT_FAM \\$1
.    if '\\$0'COVER_DOCTYPE_FAMILY' \
.       ds $COVER_DOCTYPE_FAM \\$1
.    if '\\$0'COVER_FAMILY' \
.       ds $COVER_FAM \\$1
.    if '\\$0'COVER_MISC_FAMILY' \
.       ds $COVER_MISC_FAM \\$1
.    if '\\$0'COVER_SUBTITLE_FAMILY' \
.       ds $COVER_SUBTITLE_FAM \\$1
.    if '\\$0'COVER_TITLE_FAMILY' \
.       ds $COVER_TITLE_FAM \\$1
.    if '\\$0'DOC_COVER_AUTHOR_FAMILY' \
.       ds $DOC_COVER_AUTHOR_FAM \\$1
.    if '\\$0'DOC_COVER_CHAPTER_TITLE_FAMILY' \
.       ds $DOC_COVER_CHAPTER_TITLE_FAM \\$1
.    if '\\$0'DOC_COVER_COPYRIGHT_FAMILY' \
.       ds $DOC_COVER_COPYRIGHT_FAM \\$1
.    if '\\$0'DOC_COVER_DOCTYPE_FAMILY' \
.       ds $DOC_COVER_DOCTYPE_FAM \\$1
.    if '\\$0'DOC_COVER_FAMILY' \
.       ds $DOC_COVER_FAM \\$1
.    if '\\$0'DOC_COVER_MISC_FAMILY' \
.       ds $DOC_COVER_MISC_FAM \\$1
.    if '\\$0'DOC_COVER_SUBTITLE_FAMILY' \
.       ds $DOC_COVER_SUBTITLE_FAM \\$1
.    if '\\$0'DOC_COVER_TITLE_FAMILY' \
.       ds $DOC_COVER_TITLE_FAM \\$1
.    if '\\$0'DOCHEADER_FAMILY' \
.       ds $DOCHEADER_FAM \\$1
.    if '\\$0'DOCTYPE_FAMILY' \
.       ds $DOCTYPE_FAM \\$1
.    if '\\$0'ENDNOTE_FAMILY' \
.       ds $EN_FAM \\$1
.    if '\\$0'ENDNOTE_NUMBER_FAMILY' \
.       ds $EN_NUMBER_FAM \\$1
.    if '\\$0'ENDNOTE_LINENUMBER_FAMILY' \
.       ds $EN_LN_FAM \\$1
.    if '\\$0'ENDNOTE_STRING_FAMILY' \
.       ds $EN_STRING_FAM \\$1
.    if '\\$0'ENDNOTE_TITLE_FAMILY' \
.       ds $EN_TITLE_FAM \\$1
.    if '\\$0'EPIGRAPH_FAMILY' \
.       ds $EPI_FAM \\$1
.    if '\\$0'FOOTNOTE_FAMILY' \
.       ds $FN_FAM \\$1
.    if '\\$0'HDRFTR_CENTER_FAMILY' \
.       ds $HDRFTR_CENTER_FAM \\$1
.    if '\\$0'HDRFTR_FAMILY' \{\
.       ds $HDRFTR_FAM        \\$1
.       ds $HDRFTR_LEFT_FAM   \\$1
.       ds $HDRFTR_CENTER_FAM \\$1
.       ds $HDRFTR_RIGHT_FAM  \\$1
.    \}
.    if '\\$0'HDRFTR_LEFT_FAMILY' \
.       ds $HDRFTR_LEFT_FAM \\$1
.    if '\\$0'HDRFTR_RIGHT_FAMILY' \
.       ds $HDRFTR_RIGHT_FAM \\$1
.    if '\\$0'LINENUMBER_FAMILY' \
.       ds $LN_FAM \\$1
.    if '\\$0'PAGENUM_FAMILY' \
.       ds $PAGE_NUM_FAM \\$1
.    if '\\$0'QUOTE_FAMILY' \
.       ds $QUOTE_FAM \\$1
.    if '\\$0'SUBTITLE_FAMILY' \
.       ds $SUBTITLE_FAM \\$1
.    if '\\$0'TITLE_FAMILY' \
.       ds $TITLE_FAM \\$1
.    if '\\$0'TOC_FAMILY' \
.       ds $TOC_FAM \\$1
.    if '\\$0'TOC_FAM' \
.       ds $TOC_FAM \\$1
.    if '\\$0'TOC_HEADER_FAMILY' \
.       ds $TOC_HEADER_FAM \\$1
.    if '\\$0'TOC_PN_FAMILY' \
.       ds $TOC_PN_FAM \\$1
.END
\#
.MAC _FONT END
.    if '\\$0'AUTHOR_FONT' \
.       ds $AUTHOR_FT \\$1
.    if '\\$0'BIBLIOGRAPHY_FONT' \
.       ds $BIB_FT \\$1
.    if '\\$0'BIBLIOGRAPHY_STRING_FONT' \
.       ds $BIB_STRING_FT \\$1
.    if '\\$0'BLOCKQUOTE_FONT' \
.       ds $BQUOTE_FT \\$1
.    if '\\$0'CITATION_FONT' \
.       ds $BQUOTE_FT \\$1
.    if '\\$0'CITE_FONT' \
.       ds $BQUOTE_FT \\$1
.    if '\\$0'CHAPTER_TITLE_FONT' \
.       ds $CHAPTER_TITLE_FT \\$1
.    if '\\$0'COVER_AUTHOR_FONT' \
.       ds $COVER_AUTHOR_FT \\$1
.    if '\\$0'COVER_CHAPTER_TITLE_FONT' \
.       ds $COVER_CHAPTER_TITLE_FT \\$1
.    if '\\$0'COVER_COPYRIGHT_FONT' \
.       ds $COVER_COPYRIGHT_FT \\$1
.    if '\\$0'COVER_DOCTYPE_FONT' \
.       ds $COVER_DOCTYPE_FT \\$1
.    if '\\$0'COVER_MISC_FONT' \
.       ds $COVER_MISC_FT \\$1
.    if '\\$0'COVER_SUBTITLE_FONT' \
.       ds $COVER_SUBTITLE_FT \\$1
.    if '\\$0'COVER_TITLE_FONT' \
.       ds $COVER_TITLE_FT \\$1
.    if '\\$0'DOC_COVER_AUTHOR_FONT' \
.       ds $DOC_COVER_AUTHOR_FT \\$1
.    if '\\$0'DOC_COVER_CHAPTER_TITLE_FONT' \
.       ds $DOC_COVER_CHAPTER_TITLE_FT \\$1
.    if '\\$0'DOC_COVER_COPYRIGHT_FONT' \
.       ds $DOC_COVER_COPYRIGHT_FT \\$1
.    if '\\$0'DOC_COVER_DOCTYPE_FONT' \
.       ds $DOC_COVER_DOCTYPE_FT \\$1
.    if '\\$0'DOC_COVER_MISC_FONT' \
.       ds $DOC_COVER_MISC_FT \\$1
.    if '\\$0'DOC_COVER_SUBTITLE_FONT' \
.       ds $DOC_COVER_SUBTITLE_FT \\$1
.    if '\\$0'DOC_COVER_TITLE_FONT' \
.       ds $DOC_COVER_TITLE_FT \\$1
.    if '\\$0'DOCTYPE_FONT' \
.       ds $DOCTYPE_FT \\$1
.    if '\\$0'ENDNOTE_FONT' \
.       ds $EN_FT \\$1
.    if '\\$0'ENDNOTE_NUMBER_FONT' \
.       ds $EN_NUMBER_FT \\$1
.    if '\\$0'ENDNOTE_LINENUMBER_FONT' \
.       ds $EN_LN_FT \\$1
.    if '\\$0'ENDNOTE_STRING_FONT' \
.       ds $EN_STRING_FT \\$1
.    if '\\$0'ENDNOTE_TITLE_FONT' \
.       ds $EN_TITLE_FT \\$1
.    if '\\$0'EPIGRAPH_FONT' \
.       ds $EPI_FT \\$1
.    if '\\$0'FOOTNOTE_FONT' \
.       ds $FN_FT \\$1
.    if '\\$0'HDRFTR_CENTER_FONT' \
.       ds $HDRFTR_CENTER_FT \\$1
.    if '\\$0'HDRFTR_LEFT_FONT' \
.       ds $HDRFTR_LEFT_FT \\$1
.    if '\\$0'HDRFTR_RIGHT_FONT' \
.       ds $HDRFTR_RIGHT_FT \\$1
.    if '\\$0'LINENUMBER_FONT' \
.       ds $LN_FT \\$1
.    if '\\$0'PAGENUM_FONT' \
.       ds $PAGE_NUM_FT \\$1
.    if '\\$0'QUOTE_FONT' \
.       ds $QUOTE_FT \\$1
.    if '\\$0'SUBTITLE_FONT' \
.       ds $SUBTITLE_FT \\$1
.    if '\\$0'TITLE_FONT' \
.       ds $TITLE_FT \\$1
.    if '\\$0'TOC_HEADER_FONT' \
.       ds $TOC_HEADER_FT \\$1
.    if '\\$0'TOC_PN_FONT' \
.       ds $TOC_PN_FT \\$1
.END
\#
.MAC _SIZE END
.    if '\\$0'AUTHOR_SIZE' \
.       ds $AUTHOR_SIZE_CHANGE \\$1
.    if '\\$0'BIBLIOGRAPHY_STRING_SIZE' \
.       ds $BIB_STRING_SIZE_CHANGE \\$1
.    if '\\$0'BLOCKQUOTE_SIZE' \
.       ds $BQUOTE_SIZE_CHANGE \\$1
.    if '\\$0'CITATION_SIZE' \
.       ds $BQUOTE_SIZE_CHANGE \\$1
.    if '\\$0'CITE_SIZE' \
.       ds $BQUOTE_SIZE_CHANGE \\$1
.    if '\\$0'CHAPTER_TITLE_SIZE' \
.       ds $CHAPTER_TITLE_SIZE_CHANGE \\$1
.    if '\\$0'COVER_AUTHOR_SIZE' \
.       ds $COVER_AUTHOR_SIZE_CHANGE \\$1
.    if '\\$0'COVER_CHAPTER_TITLE_SIZE' \
.       ds $COVER_CHAPTER_TITLE_SIZE_CHANGE \\$1
.    if '\\$0'COVER_COPYRIGHT_SIZE' \
.       ds $COVER_COPYRIGHT_SIZE_CHANGE \\$1
.    if '\\$0'COVER_DOCTYPE_SIZE' \
.       ds $COVER_DOCTYPE_SIZE_CHANGE \\$1
.    if '\\$0'COVER_MISC_SIZE' \
.       ds $COVER_MISC_SIZE_CHANGE \\$1
.    if '\\$0'COVER_SUBTITLE_SIZE' \
.       ds $COVER_SUBTITLE_SIZE_CHANGE \\$1
.    if '\\$0'COVER_TITLE_SIZE' \
.       ds $COVER_TITLE_SIZE_CHANGE \\$1
.    if '\\$0'DOC_COVER_AUTHOR_SIZE' \
.       ds $DOC_COVER_AUTHOR_SIZE_CHANGE \\$1
.    if '\\$0'DOC_COVER_CHAPTER_TITLE_SIZE' \
.       ds $DOC_COVER_CHAPTER_TITLE_SIZE_CHANGE \\$1
.    if '\\$0'DOC_COVER_COPYRIGHT_SIZE' \
.       ds $DOC_COVER_COPYRIGHT_SIZE_CHANGE \\$1
.    if '\\$0'DOC_COVER_DOCTYPE_SIZE' \
.       ds $DOC_COVER_DOCTYPE_SIZE_CHANGE \\$1
.    if '\\$0'DOC_COVER_MISC_SIZE' \
.       ds $DOC_COVER_MISC_SIZE_CHANGE \\$1
.    if '\\$0'DOC_COVER_SUBTITLE_SIZE' \
.       ds $DOC_COVER_SUBTITLE_SIZE_CHANGE \\$1
.    if '\\$0'DOC_COVER_TITLE_SIZE' \
.       ds $DOC_COVER_TITLE_SIZE_CHANGE \\$1
.    if '\\$0'DOCTYPE_SIZE' \
.       ds $DOCTYPE_SIZE_CHANGE \\$1
.    if '\\$0'ENDNOTE_NUMBER_SIZE' \
.       ds $EN_NUMBER_SIZE_CHANGE \\$1
.    if '\\$0'ENDNOTE_LINENUMBER_SIZE' \
.       ds $EN_LN_SIZE_CHANGE \\$1
.    if '\\$0'ENDNOTE_STRING_SIZE' \
.       ds $EN_STRING_SIZE_CHANGE \\$1
.    if '\\$0'ENDNOTE_TITLE_SIZE' \
.       ds $EN_TITLE_SIZE_CHANGE \\$1
.    if '\\$0'EPIGRAPH_SIZE' \
.       ds $EPI_SIZE_CHANGE \\$1
.    if '\\$0'FOOTNOTE_SIZE' \
.       ds $FN_SIZE_CHANGE \\$1
.    if '\\$0'HDRFTR_CENTER_SIZE' \
.       ds $HDRFTR_CENTER_SIZE_CHANGE \\$1
.    if '\\$0'HDRFTR_LEFT_SIZE' \
.       ds $HDRFTR_LEFT_SIZE_CHANGE \\$1
.    if '\\$0'HDRFTR_RIGHT_SIZE' \
.       ds $HDRFTR_RIGHT_SIZE_CHANGE \\$1
.    if '\\$0'HDRFTR_SIZE' \
.       ds $HDRFTR_SIZE_CHANGE \\$1
.    if '\\$0'LINENUMBER_SIZE' \
.       ds $LN_SIZE_CHANGE \\$1
.    if '\\$0'PAGENUM_SIZE' \
.       ds $PAGE_NUM_SIZE_CHANGE \\$1
.    if '\\$0'QUOTE_SIZE' \
.       ds $QUOTE_SIZE_CHANGE \\$1
.    if '\\$0'SUBTITLE_SIZE' \
.       ds $SUBTITLE_SIZE_CHANGE \\$1
.    if '\\$0'TITLE_SIZE' \
.       ds $TITLE_SIZE_CHANGE \\$1
.    if '\\$0'TOC_HEADER_SIZE' \
.       ds $TOC_HEADER_SIZE_CHANGE \\$1
.    if '\\$0'TOC_PN_SIZE' \
.       ds $TOC_PN_SIZE_CHANGE \\$1
.END
\#
.MAC _COLOR END
.    if \\n[#PRINT_STYLE]=1 .return
.    if '\\$0'ATTRIBUTE_COLOR' \{\
.       nr #ATTRIBUTE_COLOR 1
.       ds $ATTRIBUTE_COLOR \\$1
.    \}
.    if '\\$0'AUTHOR_COLOR' \{\
.       nr #AUTHOR_COLOR 1
.       ds $AUTHOR_COLOR \\$1
.    \}
.    if '\\$0'BLOCKQUOTE_COLOR' \{\
.       nr #BQUOTE_COLOR 1
.       ds $BQUOTE_COLOR \\$1
.    \}
.    if '\\$0'CITATION_COLOR' \{\
.       nr #BQUOTE_COLOR 1
.       ds $BQUOTE_COLOR \\$1
.    \}
.    if '\\$0'CITE_COLOR' \{\
.       nr #BQUOTE_COLOR 1
.       ds $BQUOTE_COLOR \\$1
.    \}
.    if '\\$0'CHAPTER_TITLE_COLOR' \{\
.       nr #CHAPTER_TITLE_COLOR 1
.       ds $CHAPTER_TITLE_COLOR \\$1
.    \}
.    if '\\$0'CODE_COLOR' \{\
.       nr #CODE_COLOR 1
.       ds $CODE_COLOR \\$1
.    \}
.    if '\\$0'COVER_ATTRIBUTE_COLOR' \{\
.       nr #COVER_ATTRIBUTE_COLOR 1
.       ds $COVER_ATTRIBUTE_COLOR \\$1
.    \}
.    if '\\$0'COVER_AUTHOR_COLOR' \{\
.       nr #COVER_AUTHOR_COLOR 1
.       ds $COVER_AUTHOR_COLOR \\$1
.    \}
.    if '\\$0'COVER_CHAPTER_TITLE_COLOR' \{\
.       nr #COVER_CHAPTER_TITLE_COLOR 1
.       ds $COVER_CHAPTER_TITLE_COLOR \\$1
.    \}
.    if '\\$0'COVER_COLOR' \{\
.       nr #COVER_COLOR 1
.       ds $COVER_COLOR \\$1
.    \}
.    if '\\$0'COVER_COPYRIGHT_COLOR' \{\
.       nr #COVER_COPYRIGHT_COLOR 1
.       ds $COVER_COPYRIGHT_COLOR \\$1
.    \}
.    if '\\$0'COVER_MISC_COLOR' \{\
.       nr #COVER_MISC_COLOR 1
.       ds $COVER_MISC_COLOR \\$1
.    \}
.    if '\\$0'COVER_TITLE_COLOR' \{\
.       nr #COVER_TITLE_COLOR 1
.       ds $COVER_TITLE_COLOR \\$1
.    \}
.    if '\\$0'COVER_SUBTITLE_COLOR' \{\
.       nr #COVER_SUBTITLE_COLOR 1
.       ds $COVER_SUBTITLE_COLOR \\$1
.    \}
.    if '\\$0'COVER_DOCTYPE_COLOR' \{\
.       nr #COVER_DOCTYPE_COLOR 1
.       ds $COVER_DOCTYPE_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_ATTRIBUTE_COLOR' \{\
.       nr #DOC_COVER_ATTRIBUTE_COLOR 1
.       ds $DOC_COVER_ATTRIBUTE_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_AUTHOR_COLOR' \{\
.       nr #DOC_COVER_AUTHOR_COLOR 1
.       ds $DOC_COVER_AUTHOR_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_CHAPTER_TITLE_COLOR' \{\
.       nr #DOC_COVER_CHAPTER_TITLE_COLOR 1
.       ds $DOC_COVER_CHAPTER_TITLE_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_COLOR' \{\
.       nr #DOC_COVER_COLOR 1
.       ds $DOC_COVER_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_COPYRIGHT_COLOR' \{\
.       nr #DOC_COVER_COPYRIGHT_COLOR 1
.       ds $DOC_COVER_COPYRIGHT_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_MISC_COLOR' \{\
.       nr #DOC_COVER_MISC_COLOR 1
.       ds $DOC_COVER_MISC_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_TITLE_COLOR' \{\
.       nr #DOC_COVER_TITLE_COLOR 1
.       ds $DOC_COVER_TITLE_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_SUBTITLE_COLOR' \{\
.       nr #DOC_COVER_SUBTITLE_COLOR 1
.       ds $DOC_COVER_SUBTITLE_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_DOCTYPE_COLOR' \{\
.       nr #DOC_COVER_DOCTYPE_COLOR 1
.       ds $DOC_COVER_DOCTYPE_COLOR \\$1
.    \}
.    if '\\$0'DOCHEADER_COLOR' \{\
.       nr #DOCHEADER_COLOR 1
.       ds $DOCHEADER_COLOR \\$1
.    \}
.    if '\\$0'DOCTYPE_COLOR' \{\
.       nr #DOCTYPE_COLOR 1
.       ds $DOCTYPE_COLOR \\$1
.    \}
.    if '\\$0'ENDNOTE_STRING_COLOR' \{\
.       nr #ENDNOTE_STRING_COLOR 1
.       ds $ENDNOTE_STRING_COLOR \\$1
.    \}
.    if '\\$0'EPIGRAPH_COLOR' \{\
.       nr #EPI_COLOR 1
.       ds $EPI_COLOR \\$1
.    \}
.    if '\\$0'FINIS_COLOR' \{\
.       nr #FINIS_COLOR 1
.       ds $FINIS_COLOR \\$1
.    \}
.    if '\\$0'FOOTNOTE_COLOR' \{\
.       nr #FOOTNOTE_COLOR 1
.       ds $FOOTNOTE_COLOR \\$1
.    \}
.    if '\\$0'HDRFTR_CENTER_COLOR' \{\
.       nr #HDRFTR_CENTER_COLOR 1
.       ds $HDRFTR_CENTER_COLOR \\$1
.    \}
.    if '\\$0'HDRFTR_COLOR' \{\
.       nr #HDRFTR_COLOR 1
.       ds $HDRFTR_COLOR \\$1
.    \}
.    if '\\$0'HDRFTR_LEFT_COLOR' \{\
.       nr #HDRFTR_LEFT_COLOR 1
.       ds $HDRFTR_LEFT_COLOR \\$1
.    \}
.    if '\\$0'HDRFTR_RIGHT_COLOR' \{\
.       nr #HDRFTR_RIGHT_COLOR 1
.       ds $HDRFTR_RIGHT_COLOR \\$1
.    \}
.    if '\\$0'HDRFTR_RULE_COLOR' \{\
.       nr #HDRFTR_RULE_COLOR 1
.       ds $HDRFTR_RULE_COLOR \\$1
.    \}
.    if '\\$0'LINEBREAK_COLOR' \{\
.       nr #LINEBREAK_COLOR 1
.       ds $LINEBREAK_COLOR \\$1
.    \}
.    if '\\$0'LINENUMBER_COLOR' \{\
.       nr #LINENUMBER_COLOR 1
.       ds $LN_COLOR \\$1
.    \}
.    if '\\$0'PAGENUM_COLOR' \{\
.       nr #PAGE_NUM_COLOR 1
.       ds $PAGENUM_COLOR \\$1
.    \}
.    if '\\$0'QUOTE_COLOR' \{\
.       nr #QUOTE_COLOR 1
.       ds $QUOTE_COLOR \\$1
.    \}
.    if '\\$0'SECTION_COLOR' \{\
.       nr #LINEBREAK_COLOR 1
.       ds $LINEBREAK_COLOR \\$1
.    \}
.    if '\\$0'SUBTITLE_COLOR' \{\
.       nr #SUBTITLE_COLOR 1
.       ds $SUBTITLE_COLOR \\$1
.    \}
.    if '\\$0'TITLE_COLOR' \{\
.       nr #TITLE_COLOR 1
.       ds $TITLE_COLOR \\$1
.    \}
.END
\#
.MAC _QUAD END
.    if '\\$0'BIBLIOGRAPHY_QUAD' \{\
.       ds $BIB_QUAD \\$1
.       if '\\*[$BIB_QUAD]'R' \
.ab \\$0 at line \\n[.c] must be set to either L or J.  Aborting \\n'[.F]'.
.       if '\\*[$BIB_QUAD]'C' \
.ab \\$0 at line \\n[.c] must be set to either L or J.  Aborting \\n'[.F]'.
.    \}
.    if '\\$0'BIBLIOGRAPHY_STRING_QUAD' \
.       ds $BIB_STRING_QUAD \\$1
.    if '\\$0'BLOCKQUOTE_QUAD' \
.       ds $BQUOTE_QUAD \\$1
.    if '\\$0'CITATION_QUAD' \
.       ds $BQUOTE_QUAD \\$1
.    if '\\$0'CITE_QUAD' \
.       ds $BQUOTE_QUAD \\$1
.    if '\\$0'COVER_COPYRIGHT_QUAD' \
.       ds $COVER_COPYRIGHT_QUAD \\$1
.    if '\\$0'COVER_MISC_QUAD' \
.       ds $COVER_MISC_QUAD \\$1
.    if '\\$0'COVER_QUAD' \
.       ds $COVER_QUAD \\$1
.    if '\\$0'DOC_COVER_COPYRIGHT_QUAD' \
.       ds $DOC_COVER_COPYRIGHT_QUAD \\$1
.    if '\\$0'DOC_COVER_MISC_QUAD' \
.       ds $DOC_COVER_MISC_QUAD \\$1
.    if '\\$0'DOC_COVER_QUAD' \
.       ds $DOC_COVER_QUAD \\$1
.    if '\\$0'DOCHEADER_QUAD' \
.       ds $DOCHEADER_QUAD \\$1
.    if '\\$0'DOC_QUAD' \{\
.       if !\\n[DOCS] .DOC_MACRO_ERROR \\$0
.        ds $DOC_QUAD \\$1
.        QUAD \\*[$DOC_QUAD]
.    \}
.    if '\\$0'ENDNOTE_QUAD' \{\
.       ds $EN_QUAD \\$1
.       if '\\*[$EN_QUAD]'R' \
.ab \\$0 at line \\n[.c] must be set to either L or J.  Aborting \\n'[.F]'.
.       if '\\*[$EN_QUAD]'C' \
.ab \\$0 at line \\n[.c] must be set to either L or J.  Aborting \\n'[.F]'.
.    \}
.    if '\\$0'ENDNOTE_STRING_QUAD' \
.       ds $EN_STRING_QUAD \\$1
.    if '\\$0'ENDNOTE_TITLE_QUAD' \
.       ds $EN_TITLE_QUAD \\$1
.    if '\\$0'EPIGRAPH_QUAD' \
.       ds $EPI_QUAD \\$1
.    if '\\$0'FOOTNOTE_QUAD' \
.       ds $FN_QUAD \\$1
.    if '\\$0'TOC_HEADER_QUAD' \
.       ds $TOC_HEADER_QUAD \\$1
.END
\#
\# DEFAULTS
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Sets up defaults if no values are entered prior to START.
\# *Notes:
\#   The defaults for $CHAPTER_STRING, $DRAFT_STRING, and
\#   $REVISION_STRING are in the COPYSTYLE macro.
\#
.MAC DEFAULTS END
.    if !d $PAPER .PAPER LETTER
.    if !\\n[#DOC_TYPE] .DOCTYPE DEFAULT
.    ie \\n[#PAGENUM_STYLE_SET] .PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.    el \
.       if !\\n[#COPY_STYLE]=1 .PAGENUM_STYLE DIGIT
.    if !\\n[#COPY_STYLE] .COPYSTYLE FINAL
.    if \\n[#DRAFT_WITH_PAGENUM] .COPYSTYLE \\*[$COPY_STYLE]
.    if \\n[#DOC_TYPE]=4 \{\
.       if !\\n[#USER_SET_L_LENGTH] \{\
.          R_MARGIN \\n[#R_MARGIN]u
.          rr #USER_SET_L_LENGTH
.       \}
.       if \\n[#PRINT_STYLE]=1 .PRINTSTYLE TYPEWRITE SINGLESPACE
.    \}
.    if \\n[#COPY_STYLE]=1 \{\
.       COPYSTYLE DRAFT
.       PAGENUMBER 1
.    \}
.    if !r #DOC_HEADER .DOCHEADER
.    if !r #HEADERS_ON .HEADERS
.    if !r #PAGINATE   .PAGINATE
.\"
.    if !r #HEADER_MARGIN .HEADER_MARGIN 4P+6p
.    if !r #HEADER_GAP    .HEADER_GAP 3P
.\"
.    if \\n[#FOOTERS_ON] \{\
.       HEADERS OFF
.       ie \\n[#PAGINATE] \
.          if \\n[#PAGE_NUM_POS_SET]=0 .PAGENUM_POS TOP CENTER
.       el \
.          if !\\n[#T_MARGIN] .T_MARGIN 6P
.    \}
.    if !\\n[#HEADERS_ON] \{\
.       if !\\n[#FOOTERS_ON] \{\
.          ie \\n[#PAGE_NUM_V_POS]=1 \{\
.             HEADER_MARGIN \\n[#HEADER_MARGIN]
.             HEADER_GAP \\n[#HEADER_GAP]
.          \}
.          el .if !r #T_MARGIN .T_MARGIN 6P
.       \}
.    \}
.    if !r #T_MARGIN          .T_MARGIN \\n[#HEADER_MARGIN]+\\n[#HEADER_GAP]
.    if !r #DOCHEADER_ADVANCE .nr #DOCHEADER_ADVANCE \\n[#T_MARGIN]
.    if !r #FOOTER_MARGIN     .FOOTER_MARGIN 3P
.    if !r #FOOTER_GAP        .FOOTER_GAP 3P
.    if !r #B_MARGIN          .B_MARGIN \\n[#FOOTER_MARGIN]u+\\n[#FOOTER_GAP]u
.    if (\\n[#FOOTER_MARGIN]+\\n[.v]>=\\n[#B_MARGIN]) \{\
.       tm1 "[mom]: Your chosen bottom margin for running text is too close to the footer margin.
.       tm1 "       No footers or bottom-of-page page numbers will be printed.
.       tm1 "       Please reset B_MARGIN or FOOTER_MARGIN to allow enough space.
.       tm1 "       If no footers or bottom-of-page page numbers are required,
.       tm1 "       invoke .FOOTER_MARGIN 0 before .START
.    \}
.    if !r #HEADER_RULE_GAP .HEADER_RULE_GAP 4p
.    if !r #FOOTER_RULE_GAP .FOOTER_RULE_GAP 4p
.    if !r #HDRFTR_RULE     .HDRFTR_RULE
.    if !r #PAGE_NUM_SET    .PAGENUMBER 1
.\" Read in number registers and strings for type parameters
.    nr #DOC_L_MARGIN \\n[#L_MARGIN]
.    nr #DOC_L_LENGTH \\n[#L_LENGTH]
.    nr #DOC_R_MARGIN \\n[#PAGE_WIDTH]-(\\n[#DOC_L_MARGIN]+\\n[#L_LENGTH])
.    if '\\*[$SAVED_DOC_FAM]'' \{\
.       ds $DOC_FAM \\*[$FAMILY]
.       rm $SAVED_DOC_FAM
.    \}
.    nr #DOC_PT_SIZE  \\n[#PT_SIZE]
.\"
.    if \\n[#TOC]          .nr #DOC_PT_SIZE \\n[#TOC_PS]
.    if \\n[#ENDNOTES]     .nr #DOC_PT_SIZE \\n[#EN_PS]
.    if \\n[#BIBLIOGRAPHY] .nr #DOC_PT_SIZE \\n[#BIB_PS]
.\"
.    nr #DOC_LEAD     \\n[.v]
.    nr #DOC@LEAD     \\n[#DOC_LEAD]
.    if \\n[#AUTO_LEAD] .nr #DOC_AUTOLEAD \\n[#AUTOLEAD_VALUE]
.\" #SAVED_DOC_LEAD is set in COLLATE
.    if \\n[#SAVED_DOC_LEAD] \{\
.       if \
(\\n[#TOC]=0):\
(\\n[#LIST_OF_FIGURES]=0):\
(\\n[#LIST_OF_TABLES]=0):\
(\\n[#LIST_OF_EQUATIONS]=0) \
.          if !\\n[#DOC_LEAD]=\\n[#SAVED_DOC_LEAD] .nr #RERUN_TRAPS 1
.    \}
.    ie \\n[#ADJ_DOC_LEAD]=1 .
.    el \
.       if !\\n[#DOC_LEAD_ADJUST_OFF] .DOC_LEAD_ADJUST
.    ds $DOC_QUAD \\*[$QUAD_VALUE]
.    if '\\*[$FONT]''   .FT R
.    if '\\*[$PP_FT]''  .ds $PP_FT \\*[$FONT]
.    if !'\\*[$PP_FT]'' .ds $PP_FT \\*[$FONT]
.\" Counters
.    nr #PP                0
.    nr #FN_NUMBER         0 1
.    nr #EN_NUMBER         0 1
.    nr #FN_COUNT_FOR_COLS 0 1
.    nr #DONE_ONCE         0 1
.\" Enable shimming if user hasn't turned it off
.    if \\n[#NO_SHIM]=2    .rr #NO_SHIM
.\" General style defaults for both PRINTSTYLEs
.    nr #PP_STYLE 1
.    PARA_INDENT \\n[#PP_INDENT]u
.    if !d $HDRFTR_FAM               .HDRFTR_FAMILY \\*[$DOC_FAM]
.    if !d $HDRFTR_SIZE_CHANGE       .HDRFTR_SIZE +0
.    if !d $PAGE_NUM_FAM             .PAGENUM_FAMILY \\*[$DOC_FAM]
.    if !d $PAGE_NUM_FT              .PAGENUM_FONT R
.    if !d $PAGE_NUM_SIZE_CHANGE     .PAGENUM_SIZE +0
.    if !r #PAGE_NUM_POS_SET         .PAGENUM_POS BOTTOM CENTER
.    ie \\n[#PAGE_NUM_HYPHENS_SET] \{\
.       if \\n[#PAGE_NUM_HYPHENS]=0  .PAGENUM_HYPHENS OFF
.       if \\n[#PAGE_NUM_HYPHENS]=1  .PAGENUM_HYPHENS
.    \}
.    el .PAGENUM_HYPHENS
.    if !r #HDRFTR_RIGHT_CAPS .HDRFTR_RIGHT_CAPS
.    if \\n[#HDRFTR_RIGHT_CAPS]=0 \
.       if !d $HDRFTR_RIGHT_SIZE_CHANGE .HDRFTR_RIGHT_SIZE +0
.    if !d $FN_FAM        .FOOTNOTE_FAMILY \\*[$DOC_FAM]
.    if !d $FN_FT         .FOOTNOTE_FONT R
.    if !d $FN_QUAD       .FOOTNOTE_QUAD \\*[$DOC_QUAD]
.    if !r #FN_RULE       .FOOTNOTE_RULE
.    if !r #FN_MARKERS    .FOOTNOTE_MARKERS
.    if \\n[#FN_MARKERS]=1 \{\
.       if \\n[#FN_REF]=1 \
.          if !\\n[#FN_MARKER_STYLE] .FOOTNOTE_MARKER_STYLE NUMBER
.       if !\\n[#FN_MARKER_STYLE] .FOOTNOTE_MARKER_STYLE STAR
.    \}
.    if !r #EN_MARKER_STYLE     .ENDNOTE_MARKER_STYLE SUPERSCRIPT
.    if !d $EN_PN_STYLE         .ENDNOTES_PAGENUM_STYLE digit
.    if !d $EN_FAM              .ENDNOTE_FAMILY \\*[$DOC_FAM]
.    if !d $EN_FT               .ENDNOTE_FONT R
.    if !d $EN_QUAD             .ENDNOTE_QUAD \\*[$DOC_QUAD]
.    if !d $EN_STRING           .ENDNOTE_STRING "Endnotes"
.    if !d $EN_STRING_FAM       .ENDNOTE_STRING_FAMILY \\*[$EN_FAM]
.    if !d $EN_STRING_QUAD      .ENDNOTE_STRING_QUAD CENTER
.    if !r #EN_STRING_UNDERLINE .nr #EN_STRING_UNDERLINE 2
.    if !r #EN_STRING_CAPS      .ENDNOTE_STRING_CAPS
.    if !d $EN_TITLE \{\
.       ie \\n[#DOC_TYPE]=2 \{\
.          ie !'\\*[$CHAPTER_TITLE_1]'' \{\
.             ie '\\*[$CHAPTER]'' .ENDNOTE_TITLE "\\*[$CHAPTER_TITLE]"
.             el .ENDNOTE_TITLE \
"\\*[$CHAPTER_STRING] \\*[$CHAPTER]: \\*[$CHAPTER_TITLE]"
.          \}
.             el \{\
.                ie '\\*[$CHAPTER]'' .ENDNOTE_TITLE "\\*[$CHAPTER_STRING]"
.                el .ENDNOTE_TITLE "\\*[$CHAPTER_STRING] \\*[$CHAPTER]"
.             \}
.          \}
.       el .ENDNOTE_TITLE "\\*[$TITLE]"
.    \}
.    if !d $EN_TITLE_FAM          .ENDNOTE_TITLE_FAMILY \\*[$EN_FAM]
.    if !d $EN_TITLE_QUAD         .ENDNOTE_TITLE_QUAD LEFT
.    if !r #EN_TITLE_UNDERLINE    .nr #EN_TITLE_UNDERLINE 1
.    if !d $EN_NUMBER_FAM         .ENDNOTE_NUMBER_FAMILY \\*[$EN_FAM]
.    if !d $EN_LN_FAM             .ENDNOTE_LINENUMBER_FAMILY \\*[$EN_FAM]
.    if !r #EN_NUMBERS_ALIGN_LEFT \{\
.       if !r #EN_NUMBERS_ALIGN_RIGHT \{\
.          ie !\\n[#EN_MARKER_STYLE]=2 .ENDNOTE_NUMBERS_ALIGN RIGHT 2
.          el .ENDNOTE_NUMBERS_ALIGN RIGHT 4
.       \}
.    \}
.    if !r #EN_LN_GAP            .ENDNOTE_LINENUMBER_GAP 1m
.    if !r #EN_ALLOWS_HEADERS    .ENDNOTES_ALLOWS_HEADERS
.    if !d $BIB_PN_STYLE         .BIBLIOGRAPHY_PAGENUM_STYLE digit
.    if !d $BIB_FAM              .BIBLIOGRAPHY_FAMILY \\*[$DOC_FAM]
.    if !d $BIB_FT               .BIBLIOGRAPHY_FONT R
.    if !d $BIB_QUAD             .BIBLIOGRAPHY_QUAD \\*[$DOC_QUAD]
.    if !d $BIB_STRING           .BIBLIOGRAPHY_STRING "Bibliography"
.    if !d $BIB_STRING_FAM       .BIBLIOGRAPHY_STRING_FAMILY \\*[$BIB_FAM]
.    if !d $BIB_STRING_QUAD      .BIBLIOGRAPHY_STRING_QUAD CENTER
.    if !r #BIB_STRING_UNDERLINE .nr #BIB_STRING_UNDERLINE 2
.    if !r #BIB_STRING_CAPS      .BIBLIOGRAPHY_STRING_CAPS
.    if !d $TOC_HEADER_STRING    .TOC_HEADER_STRING "Contents"
.    if !d $TOC_HEADER_QUAD      .TOC_HEADER_QUAD LEFT
.    if !d $TOC_PN_STYLE         .TOC_PAGENUM_STYLE roman
.    if !r #TOC_PN_PADDING       .TOC_PADDING 3
.\" Line numbering
.    if !r #LN_GUTTER      .nr #LN_GUTTER 2
.    if !r #Q_LN_GUTTER    .nr #Q_LN_GUTTER 2
.    if !r #BQ_LN_GUTTER   .nr #BQ_LN_GUTTER 2
.    if !d $LN_FAM         .ds $LN_FAM \\*[$DOC_FAM]
.    if !d $LN_FT          .ds $LN_FT R
.    if !d $LN_SIZE_CHANGE .ds $LN_SIZE_CHANGE +0
.    if !d $LN_COLOR       .ds $LN_COLOR black
.\" PDF link colour
.    if !\\n[PDFHREF_COLOR_SET] .PDF_LINK_COLOR 0.0 0.3 0.9
.\" PDF frame
.    if !d pdf-img:frame-weight .ds pdf-img:frame-weight .5
.    if !d pdf-img:frame-color  .ds pdf-img:frame-color  black
.\" Captions, labels, sources
.\" All at default doc specs except leading, which is autolead 2
.   nr label-type-counter 0 1
.   while \\n+[label-type-counter]<=4 \{\
.      if \\n[label-type-counter]=1 .ds label-type eqn
.      if \\n[label-type-counter]=2 .ds label-type pdf-img
.      if \\n[label-type-counter]=3 .ds label-type pic
.      if \\n[label-type-counter]=4 .ds label-type tbl
.      nr spec-type-counter 0 1
.      while \\n+[spec-type-counter]<=3 \{\
.         if \\n[spec-type-counter]=1 .ds spec-type label
.         if \\n[spec-type-counter]=2 .ds spec-type caption
.         if \\n[spec-type-counter]=3 .ds spec-type source
.         set-defaults
.         set-inline-specs
.      \}
.   \}
.\" String defaults for both PRINTSTYLEs
.    ie \\n[#DOC_TYPE]=1 \{\
.       ie '\\*[$DOC_TITLE]'' \{\
.          if \\n[#USER_DEF_HDRFTR_LEFT]=0  .ds $HDRFTR_LEFT \\*[$AUTHOR_1]
.          if \\n[#USER_DEF_HDRFTR_RIGHT]=0 .ds $HDRFTR_RIGHT \\*[$TITLE]
.       \}
.       el \{\
.          if \\n[#COPY_STYLE]=1             .DRAFT_WITH_PAGENUMBER
.          if \\n[#USER_DEF_HDRFTR_LEFT]=0   .ds $HDRFTR_LEFT \\*[$AUTHOR_1]
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 .ds $HDRFTR_CENTER \\*[$TITLE]
.          if \\n[#USER_DEF_HDRFTR_RIGHT]=0  .ds $HDRFTR_RIGHT \\*[$DOC_TITLE]
.       \}
.    \}
.    el \{\
.       if \\n[#USER_DEF_HDRFTR_LEFT]=0  .ds $HDRFTR_LEFT \\*[$AUTHOR_1]
.       if \\n[#USER_DEF_HDRFTR_RIGHT]=0 .ds $HDRFTR_RIGHT \\*[$TITLE]
.    \}
.    if !d $ATTRIBUTE_STRING     .ds $ATTRIBUTE_STRING by
.    if !d $FINIS_STRING         .FINIS_STRING "End"
.    if !r #FINIS_STRING_CAPS    .nr #FINIS_STRING_CAPS 1
.\" Covers
.    if !r #DOC_COVERS_OFF           .nr #DOC_COVERS 1
.    if !r #COVERS_OFF               .nr #COVERS 1
.    if !d $COVER_COPYRIGHT_QUAD     .COVER_COPYRIGHT_QUAD R
.    if !d $COVER_MISC_QUAD          .COVER_MISC_QUAD L
.    if !d $DOC_COVER_COPYRIGHT_QUAD .DOC_COVER_COPYRIGHT_QUAD R
.    if !d $DOC_COVER_MISC_QUAD      .DOC_COVER_MISC_QUAD L
.    if !r #DOC_COVER_UNDERLINE      .DOC_COVER_UNDERLINE
.    if !r #COVER_UNDERLINE          .COVER_UNDERLINE
.\" Defaults for printstyle TYPEWRITE
.    if \\n[#PRINT_STYLE]=1 \{\
.       TYPEWRITER
.       SS DEFAULT
.       if \\n[#UNDERLINE_QUOTES]=1 .UNDERLINE_QUOTES
.       if \\n[#UNDERLINE_QUOTES]=0 .UNDERLINE_QUOTES OFF
.\" +Doctype underlining (if NAMED)
.       if !r #DOCTYPE_UNDERLINE .nr #DOCTYPE_UNDERLINE 1
.\" +Quotes and blockquotes
.       if !r #Q_OFFSET_VALUE \{\
.          if '\\*[$Q_OFFSET_VALUE]'' .QUOTE_INDENT 1
.       \}
.\" +Epigraphs
.       if !r #EPI_OFFSET_VALUE \
.          if '\\*[$EPI_OFFSET_VALUE]'' .EPIGRAPH_INDENT 2
.\" +Linebreaks
.       if !d $LINEBREAK_CHAR .LINEBREAK_CHAR * 3 2p
.\" +Footnotes
.       if !d $FN_SIZE_CHANGE    .FOOTNOTE_SIZE +0
.       if !r #FN_RULE_LENGTH    .FOOTNOTE_RULE_LENGTH 2i
.\" +Endnotes
.       if !r #EN_PP_INDENT .ENDNOTE_PARA_INDENT \\n[#PP_INDENT]
.\" +Footnotes
.       if !r #FN_RULE_ADJ  .FOOTNOTE_RULE_ADJ 6p
.\" +Slant stuff
.       if !r #SLANT_MEANS_SLANT \{\
.          ie \\n[#UNDERLINE_SLANT]=1 .UNDERLINE_SLANT
.          el .UNDERLINE_SLANT OFF
.       \}
.    \}
.\" Defaults for printstyle TYPESET
.    if \\n[#PRINT_STYLE]=2 \{\
.       if !d $DOCHEADER_LEAD_ADJ .DOCHEADER_LEAD +0
.\" +Cover
.       if !d $COVER_LEAD_ADJ .COVER_LEAD +0
.       if !d $COVER_FAM      .COVER_FAMILY \\*[$DOC_FAM]
.\" (title)
.       if !d $COVER_TITLE_FAM \{\
.          ie !d $COVER_FAM .COVER_TITLE_FAMILY \\*[$DOC_FAM]
.          el .COVER_TITLE_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_TITLE_FT .COVER_TITLE_FONT B
.       if !d $COVER_TITLE_SIZE_CHANGE .COVER_TITLE_SIZE +3.5
.\" (chapter title)
.       if !d $COVER_CHAPTER_TITLE_FAM \{\
.          ie !d $COVER_FAM .COVER_CHAPTER_TITLE_FAMILY \\*[$DOC_FAM]
.          el .COVER_CHAPTER_TITLE_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_CHAPTER_TITLE_FT .COVER_CHAPTER_TITLE_FONT BI
.       if !d $COVER_CHAPTER_TITLE_SIZE_CHANGE .COVER_CHAPTER_TITLE_SIZE +4
.\" (subtitle)
.       if !d $COVER_SUBTITLE_FAM \{\
.          ie !d $COVER_FAM .COVER_SUBTITLE_FAMILY \\*[$DOC_FAM]
.          el .COVER_SUBTITLE_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_SUBTITLE_FT .COVER_SUBTITLE_FONT R
.       if !d $COVER_SUBTITLE_SIZE_CHANGE .COVER_SUBTITLE_SIZE +0
.\" (attribution and author[s])
.       if !d $COVER_AUTHOR_FAM \{\
.          ie !d $COVER_FAM .COVER_AUTHOR_FAMILY \\*[$DOC_FAM]
.          el .COVER_AUTHOR_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_AUTHOR_FT .COVER_AUTHOR_FONT I
.       if !d $COVER_AUTHOR_SIZE_CHANGE .COVER_AUTHOR_SIZE +0
.\" (doctype if "named")
.       if !d $COVER_DOCTYPE_FAM \{\
.          ie !d $COVER_FAM .COVER_DOCTYPE_FAMILY \\*[$DOC_FAM]
.          el .COVER_DOCTYPE_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_DOCTYPE_FT .COVER_DOCTYPE_FONT BI
.       if !d $COVER_DOCTYPE_SIZE_CHANGE .COVER_DOCTYPE_SIZE +3
.\" (copyright)
.       if !d $COVER_COPYRIGHT_FAM \{\
.          ie !d $COVER_FAM .COVER_COPYRIGHT_FAMILY \\*[$DOC_FAM]
.          el .COVER_COPYRIGHT_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_COPYRIGHT_FT .COVER_COPYRIGHT_FONT R
.       if !d $COVER_COPYRIGHT_SIZE_CHANGE .COVER_COPYRIGHT_SIZE -2
.\" (misc)
.       if !d $COVER_MISC_FAM         .COVER_MISC_FAMILY \\*[$DOC_FAM]
.       if !d $COVER_MISC_FT          .COVER_MISC_FONT R
.       if !d $COVER_MISC_SIZE_CHANGE .COVER_MISC_SIZE -2
.       if !r #COVER_MISC_AUTOLEAD    .COVER_MISC_AUTOLEAD 2
.\" +Doc cover
.       if !d $DOC_COVER_LEAD_ADJ .DOC_COVER_LEAD +0
.       if !d $DOC_COVER_FAM      .DOC_COVER_FAMILY \\*[$DOC_FAM]
.\" (title)
.       if !d $DOC_COVER_TITLE_FAM \{\
.          ie !d $DOC_COVER_FAM .DOC_COVER_TITLE_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_TITLE_FAMILY \\*[$DOC_COVER_FAM]
.       \}
.       if !d $DOC_COVER_TITLE_FT          .DOC_COVER_TITLE_FONT B
.       if !d $DOC_COVER_TITLE_SIZE_CHANGE .DOC_COVER_TITLE_SIZE +3.5
.\" (chapter title)
.       if !d $DOC_COVER_CHAPTER_TITLE_FAM \{\
.          ie !d $DOC_COVER_FAM .DOC_COVER_CHAPTER_TITLE_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_CHAPTER_TITLE_FAMILY \\*[$DOC_COVER_FAM]
.       \}
.       if !d $DOC_COVER_CHAPTER_TITLE_FT .DOC_COVER_CHAPTER_TITLE_FONT BI
.       if !d $DOC_COVER_CHAPTER_TITLE_SIZE_CHANGE .DOC_COVER_CHAPTER_TITLE_SIZE +4
.\" (subtitle)
.       if !d $DOC_COVER_SUBTITLE_FAM \{\
.          ie !d $DOC_COVER_FAM .DOC_COVER_SUBTITLE_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_SUBTITLE_FAMILY \\*[$DOC_COVER_FAM]
.       \}
.       if !d $DOC_COVER_SUBTITLE_FT .DOC_COVER_SUBTITLE_FONT R
.       if !d $DOC_COVER_SUBTITLE_SIZE_CHANGE .DOC_COVER_SUBTITLE_SIZE +0
.\" (attribution and author[s])
.       if !d $DOC_COVER_AUTHOR_FAM \{\
.          ie !d $DOC_COVER_FAM .DOC_COVER_AUTHOR_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_AUTHOR_FAMILY \\*[$DOC_COVER_FAM]
.       \}
.       if !d $DOC_COVER_AUTHOR_FT .DOC_COVER_AUTHOR_FONT I
.       if !d $DOC_COVER_AUTHOR_SIZE_CHANGE .DOC_COVER_AUTHOR_SIZE +0
.\" (doctype if "named")
.       if !d $DOC_COVER_DOCTYPE_FAM \{\
.          ie !d $DOC_COVER_FAM .DOC_COVER_DOCTYPE_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_DOCTYPE_FAMILY \\*[$DOC_COVER_FAM]
.       \}
.       if !d $DOC_COVER_DOCTYPE_FT .DOC_COVER_DOCTYPE_FONT BI
.       if !d $DOC_COVER_DOCTYPE_SIZE_CHANGE .DOC_COVER_DOCTYPE_SIZE +3
.\" (copyright)
.       if !d $DOC_COVER_COPYRIGHT_FAM \{\
.          ie !d $DOC_COVER_FAM .DOC_COVER_COPYRIGHT_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_COPYRIGHT_FAMILY \\*[$DOC_COVER_FAM]
.       \}
.       if !d $DOC_COVER_COPYRIGHT_FT .DOC_COVER_COPYRIGHT_FONT R
.       if !d $DOC_COVER_COPYRIGHT_SIZE_CHANGE .DOC_COVER_COPYRIGHT_SIZE -2
.\" (misc)
.       if !d $DOC_COVER_MISC_FAM         .DOC_COVER_MISC_FAMILY \\*[$DOC_FAM]
.       if !d $DOC_COVER_MISC_FT          .DOC_COVER_MISC_FONT R
.       if !d $DOC_COVER_MISC_SIZE_CHANGE .DOC_COVER_MISC_SIZE -2
.       if !r #DOC_COVER_MISC_AUTOLEAD    .DOC_COVER_MISC_AUTOLEAD 2
.\" +Docheader
.       if !d $DOCHEADER_FAM .DOCHEADER_FAMILY \\*[$DOC_FAM]
.       if !d $TITLE_FAM \{\
.          ie !d $DOCHEADER_FAM .TITLE_FAMILY \\*[$DOC_FAM]
.          el .TITLE_FAMILY \\*[$DOCHEADER_FAM]
.       \}
.       if !d $TITLE_FT .TITLE_FONT B
.       if !d $TITLE_SIZE_CHANGE \{\
.          ie \\n[#DOC_TYPE]=2 .TITLE_SIZE +4
.          el .TITLE_SIZE +3.5
.       \}
.       if !d $CHAPTER_TITLE_FAM \{\
.          ie !d $DOCHEADER_FAM .CHAPTER_TITLE_FAMILY \\*[$DOC_FAM]
.          el .CHAPTER_TITLE_FAMILY \\*[$DOCHEADER_FAM]
.       \}
.       if !d $CHAPTER_TITLE_FT          .CHAPTER_TITLE_FONT BI
.       if !d $CHAPTER_TITLE_SIZE_CHANGE .CHAPTER_TITLE_SIZE +4
.       if !d $SUBTITLE_FAM \{\
.          ie !d $DOCHEADER_FAM .SUBTITLE_FAMILY \\*[$DOC_FAM]
.          el .SUBTITLE_FAMILY \\*[$DOCHEADER_FAM]
.       \}
.       if !d $SUBTITLE_FT          .SUBTITLE_FONT R
.       if !d $SUBTITLE_SIZE_CHANGE .SUBTITLE_SIZE +0
.       if !d $AUTHOR_FAM \{\
.          ie !d $DOCHEADER_FAM .AUTHOR_FAMILY \\*[$DOC_FAM]
.          el .AUTHOR_FAMILY \\*[$DOCHEADER_FAM]
.       \}
.       if !d $AUTHOR_FT          .AUTHOR_FONT I
.       if !d $AUTHOR_SIZE_CHANGE .AUTHOR_SIZE +0
.       if !d $DOCTYPE_FAM \{\
.          ie !d $DOCHEADER_FAM .DOCTYPE_FAMILY \\*[$DOC_FAM]
.          el .DOCTYPE_FAMILY \\*[$DOCHEADER_FAM]
.       \}
.       if !d $DOCTYPE_FT           .DOCTYPE_FONT BI
.       if !d $DOCTYPE_SIZE_CHANGE  .DOCTYPE_SIZE +3
.       if !r #DOCTYPE_UNDERLINE    .DOCTYPE_UNDERLINE
.\" +Headers and footers
.       if !d $HDRFTR_LEFT_FAM              .HDRFTR_LEFT_FAMILY \\*[$DOC_FAM]
.       if !d $HDRFTR_LEFT_FT               .HDRFTR_LEFT_FONT R
.       if \\n[#HDRFTR_LEFT_CAPS] \
.          if !d $HDRFTR_LEFT_SIZE_CHANGE   .HDRFTR_LEFT_SIZE -2
.       if !d $HDRFTR_LEFT_SIZE_CHANGE      .HDRFTR_LEFT_SIZE -.5
.       if !d $HDRFTR_CENTER_FAM            .HDRFTR_CENTER_FAMILY \\*[$DOC_FAM]
.       if !d $HDRFTR_CENTER_FT             .HDRFTR_CENTER_FONT I
.       if \\n[#HDRFTR_CENTER_CAPS] \
.          if !d $HDRFTR_CENTER_SIZE_CHANGE .HDRFTR_CENTER_SIZE -2
.       if !d $HDRFTR_CENTER_SIZE_CHANGE    .HDRFTR_CENTER_SIZE -.5
.       if !d $HDRFTR_RIGHT_FAM             .HDRFTR_RIGHT_FAMILY \\*[$DOC_FAM]
.       if !d $HDRFTR_RIGHT_FT              .HDRFTR_RIGHT_FONT R
.       if \\n[#HDRFTR_RIGHT_CAPS] \
.          if !d $HDRFTR_RIGHT_SIZE_CHANGE  .HDRFTR_RIGHT_SIZE -2
.       if !d $HDRFTR_RIGHT_SIZE_CHANGE     .HDRFTR_RIGHT_SIZE -.5
.\" +Quotes
.       if !d $QUOTE_FAM         .QUOTE_FAMILY \\*[$DOC_FAM]
.       if !d $QUOTE_FT          .QUOTE_FONT I
.       if !d $QUOTE_SIZE_CHANGE .QUOTE_SIZE+0
.       if !r #Q_OFFSET_VALUE \
.          if '\\*[$Q_OFFSET_VALUE]'' .QUOTE_INDENT 3
.\" +Blockquotes
.\"  Note: the leading for quotes and blockquotes is set after .DEFAULTS in START
.       if !d $BQUOTE_FAM         .BLOCKQUOTE_FAMILY \\*[$DOC_FAM]
.       if !d $BQUOTE_FT          .BLOCKQUOTE_FONT R
.       if !d $BQUOTE_SIZE_CHANGE .BLOCKQUOTE_SIZE -1
.       if !d $BQUOTE_QUAD        .BLOCKQUOTE_QUAD LEFT
.\" +Epigraphs
.       if !d $EPI_FAM         .EPIGRAPH_FAMILY \\*[$DOC_FAM]
.       if !d $EPI_FT          .EPIGRAPH_FONT R
.       if !d $EPI_SIZE_CHANGE .EPIGRAPH_SIZE -1.5
.       if !r #EPI_AUTOLEAD    .EPIGRAPH_AUTOLEAD 2
.       if !d $EPI_QUAD        .EPIGRAPH_QUAD \\*[$DOC_QUAD]
.       if !r #EPI_OFFSET_VALUE \
.          if '\\*[$EPI_OFFSET_VALUE]'' .EPIGRAPH_INDENT 3
.\" +Linebreaks
.       if !d $LINEBREAK_CHAR  .LINEBREAK_CHAR * 3 3p
.       if !d $LINEBREAK_COLOR .LINEBREAK_COLOR black
.\" +Footnotes
.       if !r #FN_RULE_LENGTH .FOOTNOTE_RULE_LENGTH 4P
.       if !r #FN_RULE_ADJ    .FOOTNOTE_RULE_ADJ 3p
.       if !d $FN_SIZE_CHANGE .FOOTNOTE_SIZE -2
.       if !r #FN_AUTOLEAD    .FOOTNOTE_AUTOLEAD 2
.\" +Endnotes
.       if !r #EN_PS                 .ENDNOTE_PT_SIZE (\\n[#DOC_PT_SIZE]u)
.       if !d $EN_STRING_FT          .ENDNOTE_STRING_FONT B
.       if !d $EN_STRING_SIZE_CHANGE .ENDNOTE_STRING_SIZE +1
.       if !d $EN_TITLE_FT           .ENDNOTE_TITLE_FONT B
.       if !d $EN_TITLE_SIZE_CHANGE  .ENDNOTE_TITLE_SIZE +0
.       if !d $EN_NUMBER_FT          .ENDNOTE_NUMBER_FONT B
.       if !d $EN_LN_FT              .ENDNOTE_LINENUMBER_FONT R
.       if !d $EN_NUMBER_SIZE_CHANGE .ENDNOTE_NUMBER_SIZE +0
.       if !d $EN_LN_SIZE_CHANGE     .ENDNOTE_LINENUMBER_SIZE +0
.       if !r #EN_PP_INDENT          .ENDNOTE_PARA_INDENT 1.5m
.       if !d $EN_SPACE              .ENDNOTE_SPACING 0
.\" +Bibliography
.       if !r #BIB_LIST               .BIBLIOGRAPHY_TYPE PLAIN
.       if !r #BIB_PS                 .BIBLIOGRAPHY_PT_SIZE (\\n[#DOC_PT_SIZE]u)
.       if !d $BIB_STRING_FT          .BIBLIOGRAPHY_STRING_FONT B
.       if !d $BIB_STRING_SIZE_CHANGE .BIBLIOGRAPHY_STRING_SIZE +1
.\" +Table of contents
.       if !d $TOC_FAM                .TOC_FAMILY \\*[$DOC_FAM]
.       if !r #TOC_PS                 .TOC_PT_SIZE (\\n[#DOC_PT_SIZE]u)
.       if '\\*[$TOC_LEAD]''          .TOC_LEAD \\n[#DOC@LEAD]u ADJUST
.       if !d $TOC_HEADER_FAM         .TOC_HEADER_FAMILY \\*[$TOC_FAM]
.       if !d $TOC_HEADER_SIZE_CHANGE .TOC_HEADER_SIZE +4
.       if !d $TOC_HEADER_FT          .TOC_HEADER_FONT B
.       if !d $TOC_PN_FAM             .TOC_PN_FAMILY \\*[$TOC_FAM]
.       if !d $TOC_PN_FT              .TOC_PN_FONT R
.       if !d $TOC_PN_SIZE_CHANGE     .TOC_PN_SIZE +0
.    \}
.\" +Refer support
.    if !r #EN_REF .nr #FN_REF 1
.    if !d $REF_FN_INDENT \{\
.       if \\n[#PRINT_STYLE]=1 .INDENT_REFS FOOTNOTE .5i
.       if \\n[#PRINT_STYLE]=2 .INDENT_REFS FOOTNOTE 2m
.    \}
.    if !d $REF_EN_INDENT \{\
.       if \\n[#PRINT_STYLE]=1 .INDENT_REFS ENDNOTE .5i
.       if \\n[#PRINT_STYLE]=2 .INDENT_REFS ENDNOTE 2m
.    \}
.    if !d $REF_BIB_INDENT \{\
.       if \\n[#PRINT_STYLE]=1 .INDENT_REFS BIBLIO .5i
.       if \\n[#PRINT_STYLE]=2 .INDENT_REFS BIBLIO 2m
.    \}
.\" Define strings for idem entries
.    if \\n[#PRINT_STYLE]=1 .char \[idem] \[hy]\[hy]\[hy]
.    if \\n[#PRINT_STYLE]=2 .char \[idem] \v'-.3m'\l'3m'\v'.3m'
.\" Adjust doc leading for PRINTSTYLE TYPESET
.    if \\n[#PRINT_STYLE]=2 \
.       if \\n[#ADJ_DOC_LEAD]=1 .DOC_LEAD_ADJUST
.\" This diversion is to get a value for #FN_AUTOLEAD
.    di NULL
.       if \\n[#AUTO_LEAD] \{\
.          nr #RESTORE_AUTO_LEAD 1
.          nr #SAVED_AUTOLEAD_VALUE \\n[#AUTOLEAD_VALUE]
.       \}
.       ev NULL
.       if \\n[#PRINT_STYLE]=1 \{\
.          ps \\*[$TYPEWRITER_PS]
.          ie \\n[#SINGLE_SPACE]=1 .vs \\n[#ORIGINAL_DOC_LEAD]u
.          el .vs \\n[#ORIGINAL_DOC_LEAD]u/2u
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          ps  \\n[#DOC_PT_SIZE]u\\*[$FN_SIZE_CHANGE]
.          vs \\n[.ps]u+\\n[#FN_AUTOLEAD]u
.       \}
.       nr #FN_LEAD \\n[#LEAD]
.       ev
.    di
.    if \\n[#RESTORE_AUTO_LEAD] \{\
.       nr #AUTO_LEAD 1
.       nr #AUTOLEAD_VALUE  \\n[#SAVED_AUTOLEAD_VALUE]
.    \}
.    ie !\\n[#COLLATE] \{\
.\" DOC_LEAD adjusted (or not) here
.       TRAPS
.       if \\n[#REMOVE_ADJ] .DOC_LEAD \\n[#DOC_LEAD]u-\\n[#DOC_LEAD_ADJ]u
.\" Endnote, bibliography and toc leading
.       nr #OK_PROCESS_LEAD 1
.       nr #RESTORE_DOC_LEAD \\n[.v]
.       nr #RESTORE_B_MARGIN \\n[#B_MARGIN]
.       if \\n[#PRINT_STYLE]=1 \{\
.          ie \\n[#SINGLE_SPACE] \{\
.             ENDNOTE_LEAD      12 ADJUST
.             BIBLIOGRAPHY_LEAD 12 ADJUST
.          \}
.          el \{\
.             ie \\n[#EN_SINGLESPACE] .ENDNOTE_LEAD 12 ADJUST
.             el .ENDNOTE_LEAD 24 ADJUST
.             ie \\n[#BIB_SINGLESPACE] .BIBLIOGRAPHY_LEAD 12 ADJUST
.             el .BIBLIOGRAPHY_LEAD 24 ADJUST
.          \}
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          ie !d $EN_LEAD  .ENDNOTE_LEAD \\n[#UNADJUSTED_DOC_LEAD]u ADJUST
.          el .ENDNOTE_LEAD \\*[$EN_LEAD] \\*[$ADJUST_EN_LEAD]
.          ie !d $BIB_LEAD .BIBLIOGRAPHY_LEAD \\n[#UNADJUSTED_DOC_LEAD]u ADJUST
.          el .BIBLIOGRAPHY_LEAD \\*[$BIB_LEAD] \\*[$ADJUST_BIB_LEAD]
.          ie !d $TOC_LEAD .TOC_LEAD \\n[#UNADJUSTED_DOC_LEAD]u \\*[$ADJUST_TOC_LEAD]
.          el .TOC_LEAD \\*[$TOC_LEAD] \\*[$ADJUST_TOC_LEAD]
.       \}
.       ie !d $BIB_SPACE .BIBLIOGRAPHY_SPACING 0
.       el \{\
.          if \\n[#DEFER_BIB_SPACING]=1 \{\
.             BIBLIOGRAPHY_SPACING \\*[$BIB_SPACE]
.             rr #DEFER_BIB_SPACING
.          \}
.       \}
.       nr #DOC_LEAD \\n[#RESTORE_DOC_LEAD]u
.       nr #B_MARGIN \\n[#RESTORE_B_MARGIN]
.       vs \\n[#DOC_LEAD]u
.    \}
.    el \{\
.       if \\n[#COLLATE] \{\
.          if !\\n[#PRINT_STYLE]=1 \{\
.             if \\n[#RERUN_TRAPS] \{\
.                TRAPS
.                rr #RERUN_TRAPS
.             \}
.          \}
.       \}
.    \}
.\" Set default heading and toc-entry family if not done already
.    nr #HD_LEVEL 0 1 \" loop step
.    nr #LOOP 9       \" loop count
.    while \\n+[#HD_LEVEL]<=\\n[#LOOP] \{\
.       if '\\*[$HEAD_\\n[#HD_LEVEL]_FAM]'' \
.           ds $HEAD_\\n[#HD_LEVEL]_FAM \\*[$DOC_FAM]
.       if '\\*[$HEAD_\\n[#HD_LEVEL]_BASELINE_ADJ]'' \
.           ds $HEAD_\\n[#HD_LEVEL]_BASELINE_ADJ \\n[.v]/10
.       if '\\*[$TOC_HEAD_\\n[#HD_LEVEL]_FAM]'' \
.           ds $TOC_HEAD_\\n[#HD_LEVEL]_FAM \\*[$DOC_FAM]
.    \}
.    if '\\*[$TOC_TITLE_FAM]'' .ds $TOC_TITLE_FAM \\*[$DOC_FAM]
.\" Re-run MNinit to capture strings and registers set in DEFAULTS.
.    if !'\\*[$MN-arg1]'' \{\
.       MNinit \
\\*[$MN-arg1] \\*[$MN-arg2] \
\\*[$MN-arg3] \\*[$MN-arg4] \
\\*[$MN-arg5] \\*[$MN-arg6] \
\\*[$MN-arg7] \\*[$MN-arg8] \
\\*[$MN-arg9]
.    \}
.    if \\n[#PRINT_STYLE]=1 .nr #IGNORE 1
.    if \\n[#AUTO_LEAD] \{\
.       rr #AUTO_LEAD
.       rr #AUTOLEAD_VALUE
.    \}
.END
\#
\# ====================================================================
\#
\# +++START THE DOCUMENT+++
\#
\# THE START MACRO
\# ---------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Reads in default document style parameters and any parameters
\#   the user has changed before issuing START.
\#   Using the information gathered in the opening macros,
\#   prints appropriate title (or chapter #), subtitle, author
\#   and document type (if appropriate).
\# *Notes:
\#   The .PRINT \& (zero-width character) is required to get the
\#   subsequent .sp request to work as advertised.
\#
\#   The overall document line length, family, and point-size
\#   are stored in #DOC_L_LENGTH, $DOC_FAM, and #DOC_PT_SIZE for
\#   use in the HEADER and FOOTER macros.
\#
\#  First, define some strings for point sizes
\#
\# Doc cover
\#
.ds $DOC_COVER_AUTHOR_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$DOC_COVER_AUTHOR_SIZE_CHANGE]
.ds $DOC_COVER_CHAPTER_TITLE_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$DOC_COVER_CHAPTER_TITLE_SIZE_CHANGE]
.ds $DOC_COVER_COPYRIGHT_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$DOC_COVER_COPYRIGHT_SIZE_CHANGE]
.ds $DOC_COVER_DOCTYPE_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$DOC_COVER_DOCTYPE_SIZE_CHANGE]
.ds $DOC_COVER_MISC_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$DOC_COVER_MISC_SIZE_CHANGE]
.ds $DOC_COVER_SUBTITLE_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$DOC_COVER_SUBTITLE_SIZE_CHANGE]
.ds $DOC_COVER_TITLE_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$DOC_COVER_TITLE_SIZE_CHANGE]
\# Cover
.ds $COVER_AUTHOR_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$COVER_AUTHOR_SIZE_CHANGE]
.ds $COVER_CHAPTER_TITLE_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$COVER_CHAPTER_TITLE_SIZE_CHANGE]
.ds $COVER_COPYRIGHT_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$COVER_COPYRIGHT_SIZE_CHANGE]
.ds $COVER_DOCTYPE_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$COVER_DOCTYPE_SIZE_CHANGE]
.ds $COVER_MISC_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$COVER_MISC_SIZE_CHANGE]
.ds $COVER_SUBTITLE_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$COVER_SUBTITLE_SIZE_CHANGE]
.ds $COVER_TITLE_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$COVER_TITLE_SIZE_CHANGE]
\# Docheader
.ds $AUTHOR_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$AUTHOR_SIZE_CHANGE]
.ds $CHAPTER_TITLE_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$CHAPTER_TITLE_SIZE_CHANGE]
.ds $COPYRIGHT_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$COPYRIGHT_SIZE_CHANGE]
.ds $DOCTYPE_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$DOCTYPE_SIZE_CHANGE]
.ds $SUBTITLE_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$SUBTITLE_SIZE_CHANGE]
.ds $TITLE_PT_SIZE \
    \\n[#DOC_PT_SIZE]u\\*[$TITLE_SIZE_CHANGE]
\#
\# Next, some utility macros for various routines to prevent repetition
\#
.MAC DOC_HEADER_QUAD END
.    if '\\$0'DOC_HEADER_QUAD' .ds $CALLING_MACRO DOCHEADER
.    if '\\$0'COVER_H_POS'     .ds $CALLING_MACRO COVER
.    if '\\$0'DOC_COVER_H_POS' .ds $CALLING_MACRO DOC_COVER
.    ie !'\\*[$\\*[$CALLING_MACRO]_QUAD]'' \{\
.       if '\\*[$\\*[$CALLING_MACRO]_QUAD]'L'      .LEFT
.       if '\\*[$\\*[$CALLING_MACRO]_QUAD]'LEFT'   .LEFT
.       if '\\*[$\\*[$CALLING_MACRO]_QUAD]'R'      .RIGHT
.       if '\\*[$\\*[$CALLING_MACRO]_QUAD]'RIGHT'  .RIGHT
.       if '\\*[$\\*[$CALLING_MACRO]_QUAD]'C'      .RIGHT
.       if '\\*[$\\*[$CALLING_MACRO]_QUAD]'CENTER' .CENTER
.       if '\\*[$\\*[$CALLING_MACRO]_QUAD]'CENTRE' .CENTER
.    \}
.    el .CENTER
.END
\#
\# Aliases for DOC_HEADER_QUAD
\#
.ALIAS COVER_H_POS      DOC_HEADER_QUAD
.ALIAS DOC_COVER_H_POS  DOC_HEADER_QUAD
\#
.MAC PRINT_AUTHORS END
.    ie r#DOING_COVER \{\
.       if \\n[#DOC_COVER]=1 \{\
.          ie !'\\*[$AUTHOR_DOCCOVER_1]'' \{\
.             nr #AUTHORS \\n[#AUTHOR_DOCCOVER_NUM]
.             nr #NEXT_AUTHOR 0 1
.             while \\n[#AUTHORS]>\\n[#NEXT_AUTHOR] \{\
.                ie \\n[#DOC_COVER_AUTHOR_COLOR]=1 \
.                   PRINT \
\m[\\*[$DOC_COVER_AUTHOR_COLOR]]\\*[$AUTHOR_DOCCOVER_\\n+[#NEXT_AUTHOR]]\m[]
.                el .PRINT \\*[$AUTHOR_DOCCOVER_\\n+[#NEXT_AUTHOR]]
.             \}
.          \}
.          el \{\
.             nr #AUTHORS \\n[#AUTHOR_NUM]
.             nr #NEXT_AUTHOR 0 1
.             while \\n[#AUTHORS]>\\n[#NEXT_AUTHOR] \{\
.                ie \\n[#DOC_COVER_AUTHOR_COLOR]=1 \
.                   PRINT \
\m[\\*[$DOC_COVER_AUTHOR_COLOR]]\\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]\m[]
.                el .PRINT \\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]
.             \}
.          \}
.          return
.       \}
.       if \\n[#COVER]=1 \{\
.          ie !'\\*[$AUTHOR_COVER_1]'' \{\
.             nr #AUTHORS \\n[#AUTHOR_COVER_NUM]
.             nr #NEXT_AUTHOR 0 1
.             while \\n[#AUTHORS]>\\n[#NEXT_AUTHOR] \{\
.                ie \\n[#COVER_AUTHOR_COLOR]=1 \
.                   PRINT \
\m[\\*[$COVER_AUTHOR_COLOR]]\\*[$AUTHOR_COVER_\\n+[#NEXT_AUTHOR]]\m[]
.                el .PRINT \\*[$AUTHOR_COVER_\\n+[#NEXT_AUTHOR]]
.             \}
.          \}
.          el \{\
.             nr #AUTHORS \\n[#AUTHOR_NUM]
.             nr #NEXT_AUTHOR 0 1
.             while \\n[#AUTHORS]>\\n[#NEXT_AUTHOR] \{\
.                ie \\n[#COVER_AUTHOR_COLOR]=1 \
.                   PRINT \
\m[\\*[$COVER_AUTHOR_COLOR]]\\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]\m[]
.                el .PRINT \\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]
.             \}
.          \}
.          return
.       \}
.    \}
.    el \{\
.       nr #AUTHORS \\n[#AUTHOR_NUM]
.       nr #NEXT_AUTHOR 0 1
.       while \\n[#AUTHORS]>\\n[#NEXT_AUTHOR] \{\
.          ie \\n[#AUTHOR_COLOR]=1 \
.             PRINT \m[\\*[$AUTHOR_COLOR]]\\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]\m[]
.          el .PRINT \\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]
.       \}
.    \}
.END
\#
.MAC DEFAULT_DOCHEADER END
.    DOC_HEADER_QUAD
.    if !'\\*[$TITLE_1]'' \{\
.       FAMILY  \\*[$TITLE_FAM]
.       FT      \\*[$TITLE_FT]
.       ps \\*[$TITLE_PT_SIZE]
.       vs      \\n[#DOCHEADER_LEAD]u
.       nr #ARG_NUM 0 1
.       while \\n[#TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.          ie \\n[#TITLE_COLOR]=1 \
.             PRINT "\m[\\*[$TITLE_COLOR]]\\*[$TITLE_\\n[#ARG_NUM]]\m[]
.          el .PRINT "\\*[$TITLE_\\n[#ARG_NUM]]
.       \}
.    \}
.    if !'\\*[$SUBTITLE_1]'' \{\
.       FAMILY  \\*[$SUBTITLE_FAM]
.       FT      \\*[$SUBTITLE_FT]
.       ps \\*[$SUBTITLE_PT_SIZE]
.       nr #ARG_NUM 0 1
.       while \\n[#SUBTITLE_NUM]>=\\n+[#ARG_NUM] \{\
.          ie \\n[#SUBTITLE_COLOR]=1 \
.             PRINT "\m[\\*[$SUBTITLE_COLOR]]\\*[$SUBTITLE_\\n[#ARG_NUM]]\m[]
.          el .PRINT "\\*[$SUBTITLE_\\n[#ARG_NUM]]
.       \}
.    \}
.    if !'\\*[$AUTHOR_1]'' \{\
.       FAMILY  \\*[$AUTHOR_FAM]
.       FT      \\*[$AUTHOR_FT]
.       ps \\*[$AUTHOR_PT_SIZE]
.       ie \\n[#ATTRIBUTE_COLOR]=1 \
.          PRINT \&\m[\\*[$ATTRIBUTE_COLOR]]\\*[$ATTRIBUTE_STRING]\m[]
.       el .PRINT \&\\*[$ATTRIBUTE_STRING]
.       PRINT_AUTHORS
.    \}
.    FAMILY \\*[$DOC_FAM]
.    FT R
.END
\#
.MAC CHAPTER_DOCHEADER END
.    DOC_HEADER_QUAD
.    FAMILY  \\*[$TITLE_FAM]
.    FT      \\*[$TITLE_FT]
.    ps \\*[$TITLE_PT_SIZE]
.    vs \\n[#DOCHEADER_LEAD]u
.\" Chapter title only
.    ie '\\*[$CHAPTER]'' \{\
.       ie !'\\*[$CHAPTER_TITLE_1]'' \{\
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY  \\*[$CHAPTER_TITLE_FAM]
.             FT      \\*[$CHAPTER_TITLE_FT]
.             ps \\*[$CHAPTER_TITLE_PT_SIZE]
.             vs \\n[#DOCHEADER_LEAD]u
.          \}
.          nr #ARG_NUM 0 1
.          while \\n[#CHAPTER_TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.             ie \\n[#TITLE_COLOR]=1 \{\
.                PRINT \
\m[\\*[$TITLE_COLOR]]\\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]\m[]
.             \}
.             el .PRINT \\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]
.          \}
.       \}
.       el \{\
.          ie \\n[#TITLE_COLOR]=1 \{\
.             PRINT \m[\\*[$TITLE_COLOR]]\\*[$CHAPTER_STRING]\m[]
.          \}
.          el .PRINT \\*[$CHAPTER_STRING]
.       \}
.    \}
.\" Chapter string, possibly with a chapter title
.    el \{\
.       ie \\n[#TITLE_COLOR]=1 \{\
.          PRINT \m[\\*[$TITLE_COLOR]]\\*[$CHAPTER_STRING] \\*[$CHAPTER]\m[]
.       \}
.       el .PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.       if !'\\*[$CHAPTER_TITLE_1]'' \{\
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY  \\*[$CHAPTER_TITLE_FAM]
.             FT      \\*[$CHAPTER_TITLE_FT]
.             ps \\*[$CHAPTER_TITLE_PT_SIZE]
.             vs \\n[#DOCHEADER_LEAD]u
.             ALD     \\n[.v]u/4u \" Put a little space before the chapter title
.          \}
.          nr #ARG_NUM 0 1
.          while \\n[#CHAPTER_TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.             ie \\n[#CHAPTER_TITLE_COLOR]=1 \{\
.                PRINT \
\m[\\*[$CHAPTER_TITLE_COLOR]]\\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]\m[]
.             \}
.             el .PRINT \\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]
.          \}
.          RLD \\n[#DOC_LEAD]u    \" Just looks better this way
.       \}
.    \}
.    FAMILY \\*[$DOC_FAM]
.    FT R
.END
\#
.MAC NAMED_DOCHEADER END
.    DOC_HEADER_QUAD
.    FAMILY  \\*[$TITLE_FAM]
.    FT      \\*[$TITLE_FT]
.    ps \\*[$TITLE_PT_SIZE]
.    vs      \\n[#DOCHEADER_LEAD]u
.    if !'\\*[$TITLE_1]'' \{\
.       nr #ARG_NUM 0 1
.       while \\n[#TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.          ie \\n[#TITLE_COLOR]=1 \{\
.             PRINT "\m[\\*[$TITLE_COLOR]]\\*[$TITLE_\\n[#ARG_NUM]]\m[]
.          \}
.          el .PRINT "\\*[$TITLE_\\n[#ARG_NUM]]
.       \}
.    \}
.    if !'\\*[$SUBTITLE]'' \{\
.       FAMILY  \\*[$SUBTITLE_FAM]
.       FT      \\*[$SUBTITLE_FT]
.       ps \\*[$SUBTITLE_PT_SIZE]
.       nr #ARG_NUM 0 1
.       while \\n[#SUBTITLE_NUM]>=\\n+[#ARG_NUM] \{\
.          ie \\n[#SUBTITLE_COLOR]=1 \{\
.             PRINT "\m[\\*[$SUBTITLE_COLOR]]\\*[$SUBTITLE_\\n[#ARG_NUM]]\m[]
.          \}
.          el .PRINT "\\*[$SUBTITLE_\\n[#ARG_NUM]]
.       \}
.    \}
.    if !'\\*[$AUTHOR_1]'' \{\
.       FAMILY  \\*[$AUTHOR_FAM]
.       FT      \\*[$AUTHOR_FT]
.       ps \\*[$AUTHOR_PT_SIZE]
.       ie \\n[#ATTRIBUTE_COLOR]=1 \{\
.          PRINT \&\m[\\*[$ATTRIBUTE_COLOR]]\\*[$ATTRIBUTE_STRING]\m[]
.       \}
.       el .PRINT \&\\*[$ATTRIBUTE_STRING]
.       PRINT_AUTHORS
.    \}
.    FAMILY  \\*[$DOCTYPE_FAM]
.    FT      \\*[$DOCTYPE_FT]
.    ps \\*[$DOCTYPE_PT_SIZE]
.    vs \\n[#DOCHEADER_LEAD]u
.    ALD     \\n[#DOCHEADER_LEAD]u
.    nr #FROM_DOCTYPE 1
.    if \\n[#DOCTYPE_COLOR]=1 .COLOR \\*[$DOCTYPE_COLOR]
.    ie \\n[#DOCTYPE_UNDERLINE]=1 \
.       UNDERSCORE \\*[$DOCTYPE_UNDERLINE_GAP] "\\*[$DOC_TYPE]"
.    el .PRINT "\\*[$DOC_TYPE]"
.    COLOR black
.    FAMILY \\*[$DOC_FAM]
.    FT R
.    rr #FROM_DOCTYPE
.END
\#
\# COVER PAGE
\# ----------
\# *Arguments:
\#   TITLE | DOCTITLE | CHAPTER | CHAPTER_TITLE | CHAPTER+TITLE | COVERTITLE \
\#   [ SUBTITLE AUTHOR DOCTYPE COPYRIGHT MISC BLANKPAGE ]
\# *Function:
\#   Toggles the number register for each cover page element
\#   passed as an argument.
\# *Notes:
\#   TITLE, DOCTITLE, CHAPTER, CHAPTER_TITLE or CHAPTER+TITLE must
\#   be supplied.  After that, users may enter as many or as few of
\#   the arguments as they like.  BLANKPAGE inserts a blank page
\#   after the cover.
\#
\#   If called as DOC_COVER, performs the same operations, but
\#   applies everything to a doc cover.
\#
.MAC COVER END
.    ie '\\$0'DOC_COVER' \{\
.       nr #DOC_COVER 1
.       ds DOC_ DOC_
.    \}
.    el .nr #COVER 1
.    nr #ARG_NUM 0 1
.    nr #COVER_ITEM \\n[#NUM_ARGS]  \"loop count
.    while \\n+[#ARG_NUM]<=\\n[#COVER_ITEM] \{\
.       if '\\$1'TITLE' \{\
.          nr #\\*[DOC_]COVER_TITLE 1
.          shift
.       \}
.       if '\\$1'DOCTITLE' \{\
.          nr #\\*[DOC_]COVER_TITLE 2
.          shift
.       \}
.       if '\\$1'CHAPTER' \{\
.          nr #\\*[DOC_]COVER_TITLE 3
.          shift
.       \}
.       if '\\$1'CHAPTER_TITLE' \{\
.          nr #\\*[DOC_]COVER_TITLE 4
.          shift
.       \}
.       if '\\$1'CHAPTER+TITLE' \{\
.          nr #\\*[DOC_]COVER_TITLE 5
.          shift
.       \}
.       if '\\$1'\\*[DOC_]COVERTITLE' \{\
.          nr #\\*[DOC_]COVER_TITLE 6
.          shift
.       \}
.       if '\\$1'SUBTITLE' \{\
.          nr #\\*[DOC_]COVER_SUBTITLE 1
.          shift
.       \}
.       if '\\$1'AUTHOR' \{\
.          nr #\\*[DOC_]COVER_AUTHOR 1
.          shift
.       \}
.       if '\\$1'DOCTYPE' \{\
.          nr #\\*[DOC_]COVER_DOCTYPE 1
.          shift
.       \}
.       if '\\$1'COPYRIGHT' \{\
.          nr #\\*[DOC_]COVER_COPYRIGHT 1
.          shift
.       \}
.       if '\\$1'MISC' \{\
.          nr #\\*[DOC_]COVER_MISC 1
.          shift
.       \}
.       if '\\$1'PDF_OUTLINE_LABEL' \{\
.          shift
.          ds $PDF_\\*[DOC_]COVER_LABEL \\$1
.          shift
.       \}
.       if '\\$1'BLANKPAGE' \{\
.          nr #\\*[DOC_]COVER_BLANKPAGE 1
.          shift
.       \}
.    \}
.    if '\\$0'DOC_COVER' .rm DOC_
.END
\#
.MAC COVERTITLE END
.    ie '\\$0'DOC_COVERTITLE' \{\
.       ie \\n[#NUM_ARGS]=0 \{\
.          if \\n[#DOC_COVER_TITLE_NUM] \{\
.             nr #ITEM 0 1
.             while \\n[#DOC_COVER_TITLE_NUM]>\\n[#ITEM] \{\
.                rm $DOC_COVER_TITLE_\\n+[#ITEM]
.             \}
.             rr #DOC_COVER_TITLE_NUM
.             rm $DOC_COVER_TITLE
.          \}
.       \}
.       el \{\
.          nr #DOC_COVER_TITLE_NUM 0 1
.          while \\n[#NUM_ARGS]>\\n[#DOC_COVER_TITLE_NUM] \{\
.             ds \
$DOC_COVER_TITLE_\\n+[#DOC_COVER_TITLE_NUM] \\$\\n[#DOC_COVER_TITLE_NUM]
.          \}
.          ds $DOC_COVER_TITLE \\$*
.       \}
.    \}
.    el \{\
.       ie \\n[#NUM_ARGS]=0 \{\
.          if \\n[#COVER_TITLE_NUM] \{\
.             nr #ITEM 0 1
.             while \\n[#COVER_TITLE_NUM]>\\n[#ITEM] \{\
.                rm $COVER_TITLE_\\n+[#ITEM]
.             \}
.             rr #COVER_TITLE_NUM
.             rm $COVER_TITLE
.          \}
.       \}
.       el \{\
.          nr #COVER_TITLE_NUM 0 1
.          while \\n[#NUM_ARGS]>\\n[#COVER_TITLE_NUM] \{\
.             ds $COVER_TITLE_\\n+[#COVER_TITLE_NUM] \\$\\n[#COVER_TITLE_NUM]
.          \}
.          ds $COVER_TITLE \\$*
.\" .          if \\n[#DOCTITLE_NUM]=0 .PDF_TITLE \\*[$COVER_TITLE]
.       \}
.    \}
.END
\#
\# COVER PAGE LEADING
\# ------------------
\# *Arguments:
\#   <+|- amount by which to in/decrease leading of cover/doc cover>
\# *Function:
\#   Stores user supplied lead in/decrease in string $COVER_LEAD_ADJ
\#   or $DOC_COVER_LEAD_ADJ, depending on whether the macro was called
\#   with an alias (DOC_COVER_LEAD).
\# *Notes:
\#   A unit of measure must be supplied.  Decimal fractions OK.
\#   Default is +0, i.e. same as DOC_LEAD.
\#
.MAC COVER_LEAD END
.    ie '\\$0'DOC_COVER_LEAD' .ds $DOC_COVER_LEAD_ADJ \\$1
.    el .ds $COVER_LEAD_ADJ \\$1
.END
\#
\# MISCs get treated similarly to QUOTEs and BLOCKQUOTEs with respect to
\# leading
\#
.MAC MISC_AUTOLEAD END
.    if '\\$0'DOC_COVER_MISC_AUTOLEAD' .nr #DOC_COVER_MISC_AUTOLEAD (p;\\$1)
.    if '\\$0'COVER_MISC_AUTOLEAD'     .nr #COVER_MISC_AUTOLEAD (p;\\$1)
.END
\#
.ALIAS DOC_COVER_MISC_AUTOLEAD  MISC_AUTOLEAD
.ALIAS COVER_MISC_AUTOLEAD      MISC_AUTOLEAD
\#
\# COVER PAGE START POSITION
\# -------------------------
\# *Arguments:
\#   <distance from page top at which to start cover/doc cover>
\# *Function:
\#   Stores user supplied lead in/decrease in #COVER_START_POS
\#   or #DOC_COVER_START_POS, depending on whether the macro was
\#   called by an alias (DOC_COVER_ADVANCE).
\# *Notes:
\#   A unit of measure must be supplied.  Decimal fractions OK.
\#   If user doesn't invoke this macro, the default starting
\#   position for both covers and doc covers is 1/3 of the way
\#   down the page (setup in DO_COVER).
\#
.MAC COVER_ADVANCE END
.    ie '\\$0'DOC_COVER_ADVANCE' .nr #DOC_COVER_START_POS (\\$1)
.    el .nr #COVER_START_POS (\\$1)
.END
\#
\# UNDERLINE CONTROL
\# -----------------
\# *Arguments:
\#   [ DOUBLE ] [ <underline weight> [<underline gap>] ] | <none> | <anything>
\# *Function:
\#   Toggles underlining of the element indicated by the calling alias
\#   on or off.  Uses #<element>_UNDERLINE_WEIGHT to set the weight,
\#   and defines string $<element>_UNDERLINE_GAP.
\# *Notes:
\#   Calling aliases COVER_ and DOCCOVER_ only apply if DOCTYPE is
\#   NAMED and the DOCTYPE arg is passed to COVER or DOC_COVER.
\#
.MAC _UNDERLINE END
.    ie '\\$1'' \{\
.       if '\\$0'BIBLIOGRAPHY_STRING_UNDERLINE' \
.          nr #BIB_STRING_UNDERLINE 1
.       if '\\$0'BIBLIOGRAPHY_STRING_UNDERSCORE' \
.          nr #BIB_STRING_UNDERLINE 1
.       if '\\$0'COVER_UNDERLINE' \
.          nr #COVER_UNDERLINE 1
.       if '\\$0'DOC_COVER_UNDERLINE' \
.          nr #DOC_COVER_UNDERLINE 1
.       if '\\$0'DOCTYPE_UNDERLINE' \
.          nr #DOCTYPE_UNDERLINE 1
.       if '\\$0'ENDNOTE_STRING_UNDERLINE' \
.          nr #EN_STRING_UNDERLINE 1
.       if '\\$0'ENDNOTE_STRING_UNDERSCORE' \
.          nr #EN_STRING_UNDERLINE 1
.       if '\\$0'ENDNOTE_TITLE_UNDERLINE' \
.          nr #EN_TITLE_UNDERLINE 1
.       if '\\$0'ENDNOTE_TITLE_UNDERSCORE' \
.          nr #EN_TITLE_UNDERLINE 1
.    \}
.    el \{\
.       ie \\n[#NUM_ARGS]=1 \{\
.          ds $ARG \\$1
.          substring $ARG -1
.          ie \B'\\*[$ARG]' \{\
.             if !\\n[#PRINT_STYLE]=1 \{\
.                if '\\$0'BIBLIOGRAPHY_STRING_UNDERLINE' \
.                   BIBLIOGRAPHY_STRING_UNDERLINE_WEIGHT \\$1
.                if '\\$0'BIBLIOGRAPHY_STRING_UNDERSCORE' \
.                   BIBLIOGRAPHY_STRING_UNDERLINE_WEIGHT \\$1
.                if '\\$0'COVER_UNDERLINE' \
.                   COVER_UNDERLINE_WEIGHT \\$1
.                if '\\$0'DOC_COVER_UNDERLINE' \
.                   DOC_COVER_UNDERLINE_WEIGHT \\$1
.                if '\\$0'DOCTYPE_UNDERLINE' \
.                   DOCTYPE_UNDERLINE_WEIGHT \\$1
.                if '\\$0'ENDNOTE_STRING_UNDERLINE' \{\
.                   ENDNOTE_STRING_UNDERLINE_WEIGHT \\$1
.                   nr #EN_STRING_UNDERLINE 1
.                \}
.                if '\\$0'ENDNOTE_STRING_UNDERSCORE' \{\
.                   ENDNOTE_STRING_UNDERLINE_WEIGHT \\$1
.                   nr #EN_STRING_UNDERLINE 1
.                \}
.                if '\\$0'ENDNOTE_TITLE_UNDERLINE' \
.                   ENDNOTE_TITLE_UNDERLINE_WEIGHT \\$1
.                if '\\$0'ENDNOTE_TITLE_UNDERSCORE' \
.                   ENDNOTE_TITLE_UNDERLINE_WEIGHT \\$1
.             \}
.          \}
.          el \{\
.             if '\\$0'BIBLIOGRAPHY_STRING_UNDERLINE' \{\
.                ie '\\$1'DOUBLE' .nr #BIB_STRING_UNDERLINE 2
.                el .nr #BIB_STRING_UNDERLINE 0
.             \}
.             if '\\$0'BIBLIOGRAPHY_STRING_UNDERSCORE' \{\
.                ie '\\$1'DOUBLE' .nr #BIB_STRING_UNDERLINE 2
.                el .nr #BIB_STRING_UNDERLINE 0
.             \}
.             if '\\$0'COVER_UNDERLINE'     .nr #COVER_UNDERLINE 0
.             if '\\$0'DOC_COVER_UNDERLINE' .nr #DOC_COVER_UNDERLINE 0
.             if '\\$0'DOCTYPE_UNDERLINE'   .nr #DOCTYPE_UNDERLINE 0
.             if '\\$0'ENDNOTE_STRING_UNDERLINE' \{\
.                ie '\\$1'DOUBLE' .nr #EN_STRING_UNDERLINE 2
.                el .nr #EN_STRING_UNDERLINE 0
.             \}
.             if '\\$0'ENDNOTE_STRING_UNDERSCORE' \{\
.                ie '\\$1'DOUBLE' .nr #EN_STRING_UNDERLINE 2
.                el .nr #EN_STRING_UNDERLINE 0
.             \}
.             if '\\$0'ENDNOTE_TITLE_UNDERLINE' \{\
.                ie '\\$1'DOUBLE' .nr #EN_TITLE_UNDERLINE 2
.                el .nr #EN_TITLE_UNDERLINE 0
.             \}
.             if '\\$0'ENDNOTE_TITLE_UNDERSCORE' \{\
.                ie '\\$1'DOUBLE' .nr #EN_TITLE_UNDERLINE 2
.                el .nr #EN_TITLE_UNDERLINE 0
.             \}
.          \}
.       \}
.       el \{\
.          if !\\n[#PRINT_STYLE]=1 \{\
.             if '\\$0'BIBLIOGRAPHY_STRING_UNDERLINE' \{\
.                nr #BIB_STRING_UNDERLINE 1
.                if '\\$1'DOUBLE' \{\
.                   nr #BIB_STRING_UNDERLINE 2
.                   shift
.                \}
.                BIBLIOGRAPHY_STRING_UNDERLINE_WEIGHT \\$1
.                if !'\\$2'' \
.                   ds $BIB_STRING_UNDERLINE_GAP \\$2
.                if !'\\$3'' \
.                   ds $BIB_STRING_RULE_GAP \\$3
.             \}
.             if '\\$0'BIBLIOGRAPHY_STRING_UNDERSCORE' \{\
.                nr #BIB_STRING_UNDERLINE 1
.                if '\\$1'DOUBLE' \{\
.                   nr #BIB_STRING_UNDERLINE 2
.                   shift
.                \}
.                BIBLIOGRAPHY_STRING_UNDERLINE_WEIGHT \\$1
.                if !'\\$2'' .ds $BIB_STRING_UNDERLINE_GAP \\$2
.                if !'\\$3'' .ds $BIB_STRING_RULE_GAP \\$3
.             \}
.             if '\\$0'COVER_UNDERLINE' \{\
.                nr #COVER_UNDERLINE 1
.                COVER_UNDERLINE_WEIGHT \\$1
.                ds $COVER_UNDERLINE_GAP \\$2
.             \}
.             if '\\$0'DOC_COVER_UNDERLINE' \{\
.                nr #DOC_COVER_UNDERLINE 1
.                DOC_COVER_UNDERLINE_WEIGHT \\$1
.                ds $DOC_COVER_UNDERLINE_GAP \\$2
.             \}
.             if '\\$0'DOCTYPE_UNDERLINE' \{\
.                nr #DOCTYPE_UNDERLINE 1
.                DOCTYPE_UNDERLINE_WEIGHT \\$1
.                ds $DOCTYPE_UNDERLINE_GAP \\$2
.             \}
.\" ENDNOTE_STRING_UNDERLINE and ENDNOTE_STRING_UNDERSCORE are identical
.\" _UNDERLINE left in for backward compatibility
.             if '\\$0'ENDNOTE_STRING_UNDERLINE' \{\
.                nr #EN_STRING_UNDERLINE 1
.                if '\\$1'DOUBLE' \{\
.                   nr #EN_STRING_UNDERLINE 2
.                   shift
.                \}
.                ENDNOTE_STRING_UNDERLINE_WEIGHT \\$1
.                if !'\\$2'' .ds $EN_STRING_UNDERLINE_GAP \\$2
.                if !'\\$3'' .ds $EN_STRING_RULE_GAP \\$3
.             \}
.             if '\\$0'ENDNOTE_STRING_UNDERSCORE' \{\
.                nr #EN_STRING_UNDERLINE 1
.                if '\\$1'DOUBLE' \{\
.                   nr #EN_STRING_UNDERLINE 2
.                   shift
.                \}
.                ENDNOTE_STRING_UNDERLINE_WEIGHT \\$1
.                if !'\\$2'' .ds $EN_STRING_UNDERLINE_GAP \\$2
.                if !'\\$3'' .ds $EN_STRING_RULE_GAP \\$3
.             \}
.\" ENDNOTE_TITLE_UNDERLINE and ENDNOTE_TITLE_UNDERSCORE are identical
.\" _UNDERLINE left in for backward compatibility
.             if '\\$0'ENDNOTE_TITLE_UNDERLINE' \{\
.                nr #EN_TITLE_UNDERLINE 1
.                ENDNOTE_TITLE_UNDERLINE_WEIGHT \\$1
.                ds $EN_TITLE_UNDERLINE_GAP \\$2
.             \}
.             if '\\$0'ENDNOTE_TITLE_UNDERSCORE' \{\
.                nr #EN_TITLE_UNDERLINE 1
.                ENDNOTE_TITLE_UNDERLINE_WEIGHT \\$1
.                ds $EN_TITLE_UNDERLINE_GAP \\$2
.             \}
.          \}
.       \}
.    \}
.END
\#
.ALIAS BIBLIOGRAPHY_STRING_UNDERSCORE _UNDERLINE
.ALIAS BIBLIOGRAPHY_STRING_UNDERLINE  _UNDERLINE
.ALIAS COVER_UNDERLINE                _UNDERLINE
.ALIAS DOC_COVER_UNDERLINE            _UNDERLINE
.ALIAS DOCTYPE_UNDERLINE              _UNDERLINE
.ALIAS ENDNOTE_STRING_UNDERLINE       _UNDERLINE
.ALIAS ENDNOTE_STRING_UNDERSCORE      _UNDERLINE
.ALIAS ENDNOTE_TITLE_UNDERLINE        _UNDERLINE
.ALIAS ENDNOTE_TITLE_UNDERSCORE       _UNDERLINE
\#
\# COVERS - WHETHER TO PRINT
\# -------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes registers #COVERS and #COVERS_OFF, checked for
\#   in DEFAULTS (in START) prior to printing
\#
.MAC COVERS END
.    ie '\\$0'DOC_COVERS' \{\
.       ie '\\$1'' \{\
.          rr #DOC_COVERS_OFF
.          nr #DOC_COVERS 1
.       \}
.       el \{\
.          rr #DOC_COVERS
.          nr #DOC_COVERS_OFF 1
.       \}
.    \}
.    el \{\
.       ie '\\$1'' \{\
.          rr #COVERS_OFF
.          nr #COVERS 1
.       \}
.       el \{\
.          rr #COVERS
.          nr #COVERS_OFF 1
.       \}
.    \}
.END
\#
\# COVER_COUNTS_PAGES
\# ------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes registers #COVERS_COUNT or #DOCCOVERS_COUNT,
\#   used in END_COVER to determine whether to increment the page
\#   number silently when doc covers or covers are output.
\#
.MAC COVER_COUNTS_PAGES END
.    if '\\$0'DOC_COVER_COUNTS_PAGES' \{\
.       ie '\\$1'' .nr #DOCCOVERS_COUNT 1
.       el .rr #DOCCOVERS_COUNT
.       return
.    \}
.    if '\\$0'COVER_COUNTS_PAGES' \{\
.       ie '\\$1'' .nr #COVERS_COUNT 1
.       el .rr #COVERS_COUNT
.       return
.    \}
.END
\#
.MAC DO_COVER END
.    nr #DOING_COVER 1
.    ev COVER
.    evc 0
.    TRAP OFF
.    if \\n[#PAGINATE]=1 \{\
.       nr #PAGINATION_WAS_ON 1
.       rr #PAGINATE
.    \}
.    if \\n[#HEADERS_ON]=1 \{\
.       nr #HEADERS_WERE_ON 1
.       HEADERS OFF
.    \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       nr #FOOTERS_WERE_ON 1
.       FOOTERS OFF
.    \}
.    if \\n[#COLUMNS]=1 \{\
.       nr #COLUMNS_WERE_ON 1
.       rr #COLUMNS
.    \}
.    ds PDF_BM
.    ie '\\$0'DO_DOC_COVER' \{\
.       ds  DOC_  DOC_
.       nr #DOC_COVER_DONE 1
.       if '\\*[$PDF_DOC_COVER_LABEL]'' \
.          ds $PDF_DOC_COVER_LABEL Cover:
.    \}
.    el \{\
.       if '\\*[$PDF_COVER_LABEL]'' .ds $PDF_COVER_LABEL Title Page:
.    \}
.    if !r#\\*[DOC_]COVER_START_POS \
.       nr #\\*[DOC_]COVER_START_POS \\n[#PAGE_LENGTH]/3
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#SINGLE_SPACE]=1 .vs \\n[#DOC_LEAD]u*2u
.       el .vs \\n[#DOC_LEAD]u
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       vs \\n[#DOC_LEAD]u\\*[$\\*[DOC_]COVER_LEAD_ADJ]
.       nr #\\*[DOC_]COVER_LEAD \\n[#LEAD]
.    \}
.    if \\n[.ns] .rs
.    if '\\$0'DO_COVER' \{\
.       if \\n[TOC.RELOCATE]==5 \{\
.          if !rTOC_BH .TOC_BEFORE_HERE
.       \}
.    \}
.    if '\\$0'DO_DOC_COVER' \{\
.       if \\n[TOC.RELOCATE]==3 \{\
.          if !rTOC_BH .TOC_BEFORE_HERE
.       \}
.    \}
.    RV_HARD_SET_MARGINS
.    sp |\\n[#\\*[DOC_]COVER_START_POS]u-1v
.    if \\n[#\\*[DOC_]COVER_COLOR]=1 \{\
.       nf
\m[\\*[$\\*[DOC_]COVER_COLOR]]
.       EOL
.    \}
.    \\*[DOC_]COVER_H_POS
.    fam \\*[$\\*[DOC_]COVER_TITLE_FAM]
.    ft  \\*[$\\*[DOC_]COVER_TITLE_FT]
.    ps  \\*[$\\*[DOC_]COVER_TITLE_PT_SIZE]
.    ie \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#SINGLE_SPACE]=1 \{ .vs \\n[#DOC_LEAD]u*2u \}
.       el \{ .vs \\n[#DOC_LEAD]u \}
.    \}
.    el .vs \\n[#\\*[DOC_]COVER_LEAD]u
.    if \\n[#PRINT_STYLE]=1 .TYPEWRITER
.    if \\n[#\\*[DOC_]COVER_TITLE] \{\
.       nr PDFHREF.VIEW.LEADING.H \\n[PDFHREF.VIEW.LEADING]
.       nr PDFHREF.VIEW.LEADING   \\n[nl]u-1v-1000u
.    \}
.    if \\n[#\\*[DOC_]COVER_TITLE]=1 \{\
.       ie \\n[#PRINT_STYLE]=1 \{\
.          CAPS
.          nr #ARG_NUM 0 1
.          while \\n[#TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.             UNDERSCORE "\\*[$TITLE_\\n[#ARG_NUM]]"
.             if \\n[#ARG_NUM]>1 .as PDF_BM " \"
.             as PDF_BM \\*[$TITLE_\\n[#ARG_NUM]]
.          \}
.          CAPS OFF
.       \}
.       el \{\
.          nr #ARG_NUM 0 1
.          while \\n[#TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.             ie \\n[#\\*[DOC_]COVER_TITLE_COLOR]=1 \{\
.                PRINT \
\m[\\*[$\\*[DOC_]COVER_TITLE_COLOR]]\\*[$TITLE_\\n[#ARG_NUM]]\m[]
.             \}
.             el \
.                PRINT "\\*[$TITLE_\\n[#ARG_NUM]]
.             if \\n[#ARG_NUM]>1 .as PDF_BM " \"
.             as PDF_BM \\*[$TITLE_\\n[#ARG_NUM]]
.          \}
.       \}
.       PDF_BOOKMARK 1 \\*[$PDF_\\*[DOC_]COVER_LABEL] \\*[PDF_BM]
.\" .          PDF_TITLE \\*[PDF_BM]
.    \}
.    if \\n[#\\*[DOC_]COVER_TITLE]=2 \{\
.       ie \\n[#PRINT_STYLE]=1 \{\
.          CAPS
.          nr #ARG_NUM 0 1
.          while \\n[#DOCTITLE_NUM]>=\\n+[#ARG_NUM] \{\
.             UNDERSCORE "\\*[$\\*[DOC_]TITLE_\\n[#ARG_NUM]]"
.             if \\n[#ARG_NUM]>1 .as PDF_BM " \"
.             as PDF_BM \\*[$\\*[DOC_]TITLE_\\n[#ARG_NUM]]
.          \}
.          CAPS OFF
.       \}
.       el \{\
.          nr #ARG_NUM 0 1
.          while \\n[#DOCTITLE_NUM]>=\\n+[#ARG_NUM] \{\
.             ie \\n[#\\*[DOC_]COVER_TITLE_COLOR]=1 \{\
.                PRINT \
\m[\\*[$\\*[DOC_]COVER_TITLE_COLOR]]\\*[$\\*[DOC_]TITLE_\\n[#ARG_NUM]]\m[]
.             \}
.             el .PRINT \\*[$\\*[DOC_]TITLE_\\n[#ARG_NUM]]
.             if \\n[#ARG_NUM]>1 .as PDF_BM " \"
.             as PDF_BM \\*[$\\*[DOC_]TITLE_\\n[#ARG_NUM]]
.          \}
.       \}
.       PDF_BOOKMARK 1 \\*[$PDF_\\*[DOC_]COVER_LABEL] \\*[PDF_BM]
.\" .          PDF_TITLE \\*[PDF_BM]
.    \}
.    if \\n[#\\*[DOC_]COVER_TITLE]=3 \{\
.       ie \\n[#PRINT_STYLE]=1 \{\
.          CAPS
.          PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.          CAPS OFF
.       \}
.       el \{\
.          ie \\n[#\\*[DOC_]COVER_TITLE_COLOR]=1 \{\
.             PRINT \
\m[\\*[$\\*[DOC_]COVER_TITLE_COLOR]]\\*[$CHAPTER_STRING] \\*[$CHAPTER]\m[]
.          \}
.          el .PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.       \}
.       PDF_BOOKMARK 1 \
\\*[$PDF_\\*[DOC_]COVER_LABEL] \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.\" .          PDF_TITLE \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.    \}
.    if \\n[#\\*[DOC_]COVER_TITLE]=4 \{\
.       ie \\n[#PRINT_STYLE]=1 \{\
.          CAPS
.          nr #ARG_NUM 0 1
.             ie \\n[#SINGLE_SPACE]=0 .vs \\n[#DOC_LEAD]u/2u
.             el .vs \\n[#DOC_LEAD]u
.             sp
.          while \\n[#CHAPTER_TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.             UNDERSCORE "\\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]"
.             if \\n[#ARG_NUM]>1 .as PDF_BM " \"
.             as PDF_BM \\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]
.          \}
.          CAPS OFF
.          if \\n[#SINGLE_SPACE]=0 .vs \\n[#DOC_LEAD]u
.       \}
.       el \{\
.          nr #ARG_NUM 0 1
.          while \\n[#CHAPTER_TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.             ie \\n[#\\*[DOC_]COVER_TITLE_COLOR]=1 \{\
.                PRINT \
\m[\\*[$\\*[DOC_]COVER_TITLE_COLOR]]\\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]\m[]
.             \}
.             el .PRINT \\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]
.             if \\n[#ARG_NUM]>1 .as PDF_BM " \"
.             as PDF_BM \\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]
.          \}
.       \}
.       PDF_BOOKMARK 1 \\*[$PDF_\\*[DOC_]COVER_LABEL] \\*[PDF_BM]
.\" .          PDF_TITLE \\*[PDF_BM]
.    \}
.    if \\n[#\\*[DOC_]COVER_TITLE]=5 \{\
.       ie \\n[#PRINT_STYLE]=1 \{\
.          CAPS
.          PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.          CAPS OFF
.       \}
.       el \{\
.          ie \\n[#\\*[DOC_]COVER_TITLE_COLOR]=1 \{\
.             PRINT \
\m[\\*[$\\*[DOC_]COVER_TITLE_COLOR]]\\*[$CHAPTER_STRING] \\*[$CHAPTER]\m[]
.          \}
.          el .PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.       \}
.       if !'\\*[$CHAPTER_TITLE_1]'' \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             ie \\n[#SINGLE_SPACE]=0 .vs \\n[#DOC_LEAD]u/2u
.             el .vs \\n[#DOC_LEAD]u
.             sp
.             nr #ARG_NUM 0 1
.             while \\n[#CHAPTER_TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.                UNDERSCORE "\\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]"
.                if \\n[#ARG_NUM]>1 .as PDF_BM " \"
.                as PDF_BM \\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]
.             \}
.             if \\n[#SINGLE_SPACE]=0 .vs \\n[#DOC_LEAD]u
.          \}
.          el \{\
.             fam \\*[$\\*[DOC_]COVER_CHAPTER_TITLE_FAM]
.             ft  \\*[$\\*[DOC_]COVER_CHAPTER_TITLE_FT]
.             ps  \\*[$\\*[DOC_]COVER_CHAPTER_TITLE_PT_SIZE]
.             ALD \\n[.v]u/4u \"Put a little space before the chapter title
.             nr #ARG_NUM 0 1
.             while \\n[#CHAPTER_TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.                ie \\n[#\\*[DOC_]COVER_TITLE_COLOR]=1 \{\
.                   PRINT \
\m[\\*[$\\*[DOC_]COVER_TITLE_COLOR]]\\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]\m[]
.                \}
.                el .PRINT \\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]
.                if \\n[#ARG_NUM]>1 .as PDF_BM " \"
.                as PDF_BM \\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]
.             \}
.          \}
.       \}
.       PDF_BOOKMARK 1 \\*[$PDF_\\*[DOC_]COVER_LABEL] \\*[PDF_BM]
.\" .          PDF_TITLE \\*[PDF_BM]
.    \}
.    if \\n[#\\*[DOC_]COVER_TITLE]=6 \{\
.       ie \\n[#PRINT_STYLE]=1 \{\
.          CAPS
.          nr #ARG_NUM 0 1
.          while \\n[#\\*[DOC_]COVER_TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.             UNDERSCORE "\\*[$\\*[DOC_]COVER_TITLE_\\n[#ARG_NUM]]"
.                if \\n[#ARG_NUM]>1 .as PDF_BM " \"
.                as PDF_BM \\*[$\\*[DOC_]COVER_TITLE_\\n[#ARG_NUM]]
.          \}
.          CAPS OFF
.       \}
.       el \{\
.          nr #ARG_NUM 0 1
.          while \\n[#\\*[DOC_]COVER_TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.             ie \\n[#\\*[DOC_]COVER_TITLE_COLOR]=1 \{\
.                PRINT \
\m[\\*[$\\*[DOC_]COVER_TITLE_COLOR]]\
\\*[$\\*[DOC_]COVER_TITLE_\\n[#ARG_NUM]]\m[]
.             \}
.             el .PRINT \\*[$\\*[DOC_]COVER_TITLE_\\n[#ARG_NUM]]
.             if \\n[#ARG_NUM]>1 .as PDF_BM " \"
.             as PDF_BM \\*[$\\*[DOC_]COVER_TITLE_\\n[#ARG_NUM]]
.          \}
.       \}
.       PDF_BOOKMARK 1 \\*[$PDF_\\*[DOC_]COVER_LABEL] \\*[PDF_BM]
.\" .          PDF_TITLE \\*[PDF_BM]
.    \}
.    if \\n[#\\*[DOC_]COVER_TITLE] \{\
.      nr PDFHREF.VIEW.LEADING \\n[PDFHREF.VIEW.LEADING.H]
.      rr PDFHREF.VIEW.LEADING.H
.    \}
.    if !\\n[#DOC_TYPE]=2 \{\
.       if \\n[#\\*[DOC_]COVER_SUBTITLE]=1 \{\
.          fam \\*[$\\*[DOC_]COVER_SUBTITLE_FAM]
.          ft  \\*[$\\*[DOC_]COVER_SUBTITLE_FT]
.          ps  \\*[$\\*[DOC_]COVER_SUBTITLE_PT_SIZE]
.          if \\n[#PRINT_STYLE]=1 \{\
.             TYPEWRITER
.             ie \\n[#SINGLE_SPACE]=0 .vs \\n[#DOC_LEAD]u/2u
.             el .vs \\n[#DOC_LEAD]u
.             sp
.          \}
.          if \\n[#\\*[DOC_]COVER]=1 \{\
.             ie !'\\*[$SUBTITLE_\\*[DOC_]COVER_1]'' \{\
.                nr #SUBTITLES \\n[#SUBTITLE_\\*[DOC_]COVER_NUM]
.                nr #NEXT_SUBTITLE 0 1
.                while \\n[#SUBTITLES]>\\n[#NEXT_SUBTITLE] \{\
.                   ie \\n[#\\*[DOC_]COVER_SUBTITLE_COLOR]=1 \{\
.                      PRINT \
\m[\\*[$\\*[DOC_]COVER_SUBTITLE_COLOR]]\
\\*[$SUBTITLE_\\*[DOC_]COVER_\\n+[#NEXT_SUBTITLE]]\m[]
.                   \}
.                   el .PRINT \
\\*[$SUBTITLE_\\*[DOC_]COVER_\\n+[#NEXT_SUBTITLE]]
.                \}
.             \}
.             el \{\
.                nr #SUBTITLES \\n[#SUBTITLE_NUM]
.                nr #NEXT_SUBTITLE 0 1
.                while \\n[#SUBTITLES]>\\n[#NEXT_SUBTITLE] \{\
.                   ie \\n[#\\*[DOC_]COVER_SUBTITLE_COLOR]=1 \{\
.                      PRINT \
\m[\\*[$\\*[DOC_]COVER_SUBTITLE_COLOR]]\\*[$SUBTITLE_\\n+[#NEXT_SUBTITLE]]\m[]
.                   \}
.                   el .PRINT \\*[$SUBTITLE_\\n+[#NEXT_SUBTITLE]]
.                \}
.             \}
.          \}
.          if \\n[#PRINT_STYLE]=1 \{\
.             if \\n[#SINGLE_SPACE]=0 .vs
.          \}
.       \}
.       if \\n[#PRINT_STYLE]=1 \{\
.          if !r#\\*[DOC_]COVER_SUBTITLE .sp
.       \}
.    \}
.    if \\n[#\\*[DOC_]COVER_AUTHOR]=1 \{\
.       fam \\*[$\\*[DOC_]COVER_AUTHOR_FAM]
.       ft  \\*[$\\*[DOC_]COVER_AUTHOR_FT]
.       ps  \\*[$\\*[DOC_]COVER_AUTHOR_PT_SIZE]
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          ie \\n[#SINGLE_SPACE]=1 .vs \\n[#DOC_LEAD]u
.          el .vs \\n[#DOC_LEAD]u/2u
.          sp
.       \}
.       ie d$ATTRIBUTE_STRING_DO_CCOVER \{\
.          ie \\n[#\\*[DOC_]COVER_ATTRIBUTE_COLOR]=1 \{\
.             PRINT \
\&\m[\\*[$\\*[DOC_]COVER_ATTRIBUTE_COLOR]]\
\\*[$ATTRIBUTE_STRING_\\*[DOC_]COVER]\m[]
.          \}
.          el .PRINT \&\\*[$ATTRIBUTE_STRING_\\*[DOC_]COVER]
.       \}
.       el \{\
.          if d$ATTRIBUTE_STRING \{\
.             ie \\n[#\\*[DOC_]COVER_ATTRIBUTE_COLOR]=1 \{\
.                PRINT \
\&\m[\\*[$\\*[DOC_]COVER_ATTRIBUTE_COLOR]]\\*[$ATTRIBUTE_STRING]\m[]
.             \}
.             el .PRINT \&\\*[$ATTRIBUTE_STRING]
.          \}
.       \}
.       PRINT_AUTHORS
.    \}
.    fam \\*[$\\*[DOC_]COVER_DOCTYPE_FAM]
.    ft  \\*[$\\*[DOC_]COVER_DOCTYPE_FT]
.    ps  \\*[$\\*[DOC_]COVER_DOCTYPE_PT_SIZE]
.    sp
.    if \\n[#DOC_TYPE]=3 \{\
.       if \\n[#\\*[DOC_]COVER_DOCTYPE]=1 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             TYPEWRITER
.             vs \\n[#DOC_LEAD]u
.             UNDERSCORE2 "\\*[$DOC_TYPE]"
.          \}
.          el \{\
.             nr #FROM_\\*[DOC_]COVER 1
.             ie \\n[#\\*[DOC_]COVER_DOCTYPE_COLOR]=1 \{\
.                COLOR \\*[$\\*[DOC_]COVER_DOCTYPE_COLOR]
.                ie \\n[#\\*[DOC_]COVER_UNDERLINE]=1 \
.                   UNDERSCORE \\*[$\\*[DOC_]COVER_UNDERLINE_GAP] "\\*[$DOC_TYPE]"
.                el .PRINT "\\*[$DOC_TYPE]"
.             \}
.             el \{\
.                ie \\n[#\\*[DOC_]COVER_UNDERLINE]=1 \
.                   UNDERSCORE \
\\*[$\\*[DOC_]COVER_UNDERLINE_GAP] "\\*[$DOC_TYPE]"
.                el .PRINT "\\*[$DOC_TYPE]"
.             \}
.             rr #FROM_\\*[DOC_]COVER
.          \}
.       \}
.    \}
.    sp |\\n[#VISUAL_B_MARGIN]u
.    ie \\n[#PRINT_STYLE]=1 \{\
.       TYPEWRITER
.       ie \\n[#SINGLE_SPACE]=1 .vs \\n[#DOC_LEAD]u
.       el .vs \\n[#DOC_LEAD]u/2u
.       sp
.    \}
.    el \{\
.       fam \\*[$\\*[DOC_]COVER_COPYRIGHT_FAM]
.       ft  \\*[$\\*[DOC_]COVER_COPYRIGHT_FT]
.       ps \\*[$\\*[DOC_]COVER_COPYRIGHT_PT_SIZE]
.       vs \\n[.ps]u+\\n[#\\*[DOC_]COVER_MISC_AUTOLEAD]u
.       nr #COPYRIGHT_V_ADJ \\n[#DOC_LEAD]-\\n[.v]
.       sp \\n[#COPYRIGHT_V_ADJ]u
.       rr #COPYRIGHT_V_ADJ
.    \}
.    if \\n[#\\*[DOC_]COVER_COPYRIGHT]=1 \{\
.       if !'\\*[$COPYRIGHT_DOCCOVER]'' \{\
.          ds $SAVED_COPYRIGHT \\*[$COPYRIGHT]
.          ds $COPYRIGHT \\*[$COPYRIGHT_DOCCOVER]
.       \}
.       QUAD \\*[$\\*[DOC_]COVER_COPYRIGHT_QUAD]
.       ie \\n[#\\*[DOC_]COVER_COPYRIGHT_COLOR]=1 \{\
.          PRINT \m[\\*[$\\*[DOC_]COVER_COPYRIGHT_COLOR]]\\*[$COPYRIGHT]\m[]
.       \}
.       el .PRINT \\*[$COPYRIGHT]
.       if d$SAVED_COPYRIGHT .ds $COPYRIGHT \\*[$SAVED_COPYRIGHT]
.    \}
.    br
.    if \\n[#\\*[DOC_]COVER_MISC]=1 \{\
.       if \\n[#PRINT_STYLE]=2 \{\
.          fam \\*[$\\*[DOC_]COVER_MISC_FAM]
.          ft  \\*[$\\*[DOC_]COVER_MISC_FT]
.          ps \\*[$\\*[DOC_]COVER_MISC_PT_SIZE]
.       \}
.       QUAD \\*[$\\*[DOC_]COVER_MISC_QUAD]
.       ie !'\\*[$MISC_\\*[DOC_]COVER_1]'' \{\
.          nr #MISCS \\n[#MISC_\\*[DOC_]COVER_NUM]
.          nr #NEXT_MISC 0 1
.          while \\n[#MISCS]>\\n[#NEXT_MISC] \{\
.             ie \\n[#\\*[DOC_]COVER_MISC_COLOR]=1 \{\
.                da MISC_DIV
.                PRINT \
\m[\\*[$\\*[DOC_]COVER_MISC_COLOR]]\\*[$MISC_\\*[DOC_]COVER_\\n+[#NEXT_MISC]]\m[]
.                br
.                da
.                rm $MISC_\\*[DOC_]COVER_\\n[#NEXT_MISC]
.                rm $MISC_\\n[#NEXT_MISC]
.             \}
.             el \{\
.                da MISC_DIV
.                PRINT \\*[$MISC_\\*[DOC_]COVER_\\n+[#NEXT_MISC]]
.                br
.                da
.                rm $MISC_\\*[DOC_]COVER_\\n[#NEXT_MISC]
.                rm $MISC_\\n[#NEXT_MISC]
.             \}
.          \}
.          rm $MISC_\\n+[#NEXT_MISC]
.       \}
.       el \{\
.          nr #MISCS \\n[#MISC_NUM]
.          nr #NEXT_MISC 0 1
.          while (\\n[#MISCS]>=\\n+[#NEXT_MISC]) \{\
.             ie \\n[#\\*[DOC_]COVER_MISC_COLOR]=1 \{\
.                da MISC_DIV
.                PRINT \
\m[\\*[$\\*[DOC_]COVER_MISC_COLOR]]\\*[$MISC_\\n[#NEXT_MISC]]\m[]
.                br
.                da
.             \}
.             el \{\
.                da MISC_DIV
.                PRINT \\*[$MISC_\\n[#NEXT_MISC]]
.                br
.                da
.             \}
.             nr #MISC_DEPTH +\\n[dn]
.          \}
.       \}
.       nr #MISC_DEPTH -\\n[#DOC_LEAD]
.       sp |\\n[#VISUAL_B_MARGIN]u-\\n[#MISC_DEPTH]u
.       nf
.       MISC_DIV
.       rm MISC_DIV
.       rr #MISC_DEPTH
.    \}
.    if '\\$0'DO_COVER'     .nr #COVER_END 1
.    if '\\$0'DO_DOC_COVER' .nr #DOC_COVER_END 1
.    if \\n[TOC.RELOCATE]==1 \{\
.       if !\\n[#COVER_BLANKPAGE] \
.          if !rTOC_BH .TOC_AFTER_HERE
.    \}
.    if '\\$0'DO_COVER' \{\
.       if \\n[TOC.RELOCATE]==6 \
.          if !rTOC_BH .TOC_AFTER_HERE
.    \}
.    if '\\$0'DO_DOC_COVER' \{\
.       if \\n[TOC.RELOCATE]==4 \
.          if !rTOC_BH .TOC_AFTER_HERE
.    \}
.    if '\\$0'DO_DOC_COVER' .rm DOC_
.    END_COVER
.END
\#
\# Macro to terminate (doc)cover processing
\#
.MAC END_COVER END
.    EOL
.    TRAP
.    NEWPAGE
.    if \\n[#PAGINATION_WAS_ON]=1 .nr % +1
.    if \\n[#DOC_COVER_END]=1 \{\
.       ie \\n[#DOC_COVER_BLANKPAGE]=1 \{\
.          if \\n[TOC.RELOCATE] \
.             if !\\n[#TOC_BH] .TOC_AFTER_HERE
.          NEWPAGE
.          rr #DOC_COVER_BLANKPAGE
.          if !\\n[#DOCCOVERS_COUNT]=1 .nr % -2
.       \}
.       el \
.          if !\\n[#DOCCOVERS_COUNT]=1 .nr #PAGE_NUM_ADJ -1
.       rr #DOC_COVER_END
.    \}
.    if \\n[#COVER_END]=1 \{\
.       ie \\n[#COVER_BLANKPAGE]=1 \{\
.          if \\n[TOC.RELOCATE] \
.             if !\\n[TOC_BH] .TOC_AFTER_HERE
.          NEWPAGE
.          rr #COVER_BLANKPAGE
.          if !\\n[#COVERS_COUNT]=1 .nr % -2
.       \}
.       el \
.          if !\\n[#COVERS_COUNT]=1 .nr #PAGE_NUM_ADJ -1
.       rr #COVER_END
.    \}
.    if !'\\n[.ev]'0' .ev
.    if \\n[#PAGINATION_WAS_ON] \{\
.       rr #PAGINATION_WAS_ON
.       PAGINATE
.       PAGENUMBER \\n%+\\n[#PAGE_NUM_ADJ]-1
.    \}
.    if \\n[#HEADERS_WERE_ON] \{\
.       rr #HEADERS_WERE_ON
.       HEADERS
.    \}
.    if \\n[#FOOTERS_WERE_ON] \{\
.       rr #FOOTERS_WERE_ON
.       FOOTERS
.    \}
.    if \\n[#COLUMNS_WERE_ON]=1 \{\
.       rr #COLUMNS_WERE_ON 1
.       nr #COLUMNS 1
.    \}
.    rr #DOING_COVER
.    if \\n[.ns] .nop \&
.    if \\n[#RECTO_VERSO] .nr #RV_POST_COVER 1
.END
\#
\# Macro to begin document processing
\#
.MAC START END
.    nr #DOCS 1
.    if \\n[TOC.RELOCATE]==2 \{\
.       if !\\n[TOC_BH] .TOC_BEFORE_HERE
.    \}
.    if !n .nop \X'ps: exec 0 setlinejoin'\X'ps: exec 0 setlinecap'
.    if !\\n[#PRINT_STYLE] \{\
.       PRINTSTYLE TYPEWRITE
.       PRINT \&
.       po 6P
.       ll 39P
.       ta \\n[.l]u
.       sp |1i-1v
.       CENTER
.       PRINT "You neglected to enter a PRINTSTYLE"
.       fl
.       ab [mom]: PRINTSTYLE missing.  Aborting '\\n[.F]'.
.    \}
.    if \\n[#LINENUMBERS]=1 \{\
.       nn
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#COLLATE] \{\
.       COPYSTYLE \\*[$COPY_STYLE]
.       nr #HEADERS_ON \\n[#HEADER_STATE]
.       if \\n[#PAGE_NUM_V_POS]=1 .nr #PAGINATE \\n[#PAGINATION_STATE]
.       PRINT \&
.       if !'\\*[$RESTORE_PAGENUM_STYLE]'' \{\
.          PAGENUM_STYLE \\*[$RESTORE_PAGENUM_STYLE]
.          rm $RESTORE_PAGENUM_STYLE
.       \}
.    \}
.    DEFAULTS
.    nr #PAGE_TOP \\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.    rr #RESET_TRAPS
.    if !r#EN_Q_AUTOLEAD  .nr #EN_Q_LEAD \\n[#EN_LEAD]
.    if !r#EN_BQ_AUTOLEAD .nr #EN_BQ_LEAD \\n[#EN_LEAD]
.\"  TOC/recto-verso stuff
.    if !r@L_MARGIN .nr @L_MARGIN \\n[#DOC_L_MARGIN]
.    if !r@R_MARGIN .nr @R_MARGIN \\n[#DOC_R_MARGIN]
.\" Covers and doc covers
.    if \\n[#DOC_COVERS]=1 \{\
.       if \\n[#DOC_COVER]=1 \{\
.          DO_DOC_COVER
.          rr #DOC_COVER
.          rr #DOC_COVER_TITLE
.          rr #DOC_COVER_SUBTITLE
.          rr #DOC_COVER_AUTHOR
.          rr #DOC_COVER_DOCTYPE
.          rr #DOC_COVER_COPYRIGHT
.          rr #DOC_COVER_MISC
.       \}
.    \}
.    if \\n[#COVERS]=1 \{\
.       if \\n[#COVER]=1 \{\
.          DO_COVER
.          rr #COVER
.          rr #COVER_TITLE
.          rr #COVER_SUBTITLE
.          rr #COVER_AUTHOR
.          rr #COVER_DOCTYPE
.          rr #COVER_COPYRIGHT
.          rr #COVER_MISC
.       \}
.    \}
.    if !\\n[#TOC] .RV_HARD_SET_MARGINS
.    if \\n[#COLUMNS] .COLUMNS \\n[#NUM_COLS] \\n[#GUTTER]u
.\" Collect TITLE for TOC.
.    if !\\n[#TOC]=1 \{\
.       nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.       af #TOC_ENTRY_PN \\g[#PAGENUMBER]
.       ie \\n[#USER_SET_TITLE_ITEM] \{\
.          ds $TOC_TITLE_ITEM \\*[$USER_SET_TITLE_ITEM]
.          rr #USER_SET_TITLE_ITEM
.          rm $USER_SET_TITLE_ITEM
.       \}
.       el \{\
.          ie \\n[#DOC_TYPE]=2 \{\
.             ie '\\*[$CHAPTER_TITLE]'' \
.                ds $TOC_TITLE_ITEM \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.             el \{\
.                ie '\\*[$CHAPTER]'' \
.                   ds $TOC_TITLE_ITEM \\*[$CHAPTER_TITLE]
.                el \
.                   ds $TOC_TITLE_ITEM \
\\*[$CHAPTER_STRING] \\*[$CHAPTER]: \\*[$CHAPTER_TITLE]
.             \}
.          \}
.          el \
.             ds $TOC_TITLE_ITEM \\*[$TITLE]
.       \}
.       if \\n[#TOC_AUTHORS]=1 \{\
.          ie '\\*[$TOC_AUTHORS]'' \
.             as $TOC_TITLE_ITEM / \\*[$AUTHOR_1]
.          el \{\
.             as $TOC_TITLE_ITEM / \\*[$TOC_AUTHORS]
.             rm $TOC_AUTHORS
.          \}
.       \}
.       sp |\\n[#DOCHEADER_ADVANCE]u-\\n[#DOC_LEAD]u
.       PDF_BOOKMARK 1 \\*[$TOC_TITLE_ITEM]
.       as $TOC_TITLE_ITEM \|
.       if \\n[#PREFIX_CH_NUM] \{\
.          rn $TOC_TITLE_ITEM $TOC_TITLE_ITEM_OLD
.          ds $TOC_CH_NUM \\n[#CH_NUM].\[toc-hd-num-spacer]
.          ds $TOC_TITLE_ITEM \\*[$TOC_CH_NUM]\\*[$TOC_TITLE_ITEM_OLD]
.          rm $TOC_TITLE_ITEM_OLD
.       \}
.       TITLE_TO_TOC
.    \}
.    if !\\n[#TOC] .nr #POST_TOP 1
.\" End TITLE collection
.    if \\n[#PRINT_PAGENUM_ON_PAGE_1] \{\
.       br
.       sp |\\n[#HEADER_MARGIN]u
.       PRINT_PAGE_NUMBER
.    \}
.    rr #COLLATE
.    rr #PAGINATION_STATE
.\" End collate stuff
.    ie \\n[#DOC_HEADER]=0 \{\
.       if \\n[.ns] .rs
.       if \\n[#DOC_TYPE]=4 \
.          if !'\\n[.z]'' .di
.       nr #STORED_PP_INDENT \\n[#PP_INDENT]
.       PARA_INDENT 0
.       PP
.       PARA_INDENT \\n[#STORED_PP_INDENT]u
.       rr #STORED_PP_INDENT
.       ie r#ADVANCE_FROM_TOP \{\
.          br
.          sp |\\n[#ADVANCE_FROM_TOP]u-1v
.          if \\n[#ADJ_DOC_LEAD]=1 .SHIM
.       \}
.       el \{\
.          br
.          sp |\\n[#T_MARGIN]u-1v
.       \}
.       if \\n[#COLUMNS] \{\
.          mk dc
.          nr #COL_NUM 0 1
.          po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n[.o]
.          ll \\n[#COL_L_LENGTH]u
.       \}
.       nr #PP 0
.    \}
.    el \{\
.       if \\n[#AUTO_LEAD] .nr #RESTORE_AUTO_LEAD 1
.       if \\n[#PRINT_STYLE]=2 .vs \\n[#DOC_LEAD]u\\*[$DOCHEADER_LEAD_ADJ]
.       if \\n[#RESTORE_AUTO_LEAD] \{\
.          nr #AUTO_LEAD 1
.          nr #AUTOLEAD_VALUE  \\n[#SAVED_AUTOLEAD_VALUE]
.       \}
.       nr #DOCHEADER_LEAD \\n[#LEAD]
.\" Default doctype
.       if \\n[#DOC_TYPE]=1 \{\
.          if \\n[.ns] .rs
.          ev DOCHEADER
.          if \\n[#DOCHEADER_COLOR]=1 \{\
.             nf
\m[\\*[$DOCHEADER_COLOR]]
.             EOL
.          \}
.          L_MARGIN \\n[#DOC_L_MARGIN]u
.          LL       \\n[#DOC_L_LENGTH]u
.          ta \\n[.l]u
.          if \\n[#PRINT_STYLE]=1 \{\
.             DOC_HEADER_QUAD
.             TYPEWRITER
.             if !\\n[#SINGLE_SPACE] \{\
.                vs (\\n[#DOC_LEAD]u/2u)+(\\n[.v]u/3u)
.                sp |\\n[#T_MARGIN]u-1v
.             \}
.             if !'\\*[$TITLE_1]'' \{\
.                CAPS
.                nr #ARG_NUM 0 1
.                while \\n[#TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.                   UNDERSCORE 3p "\\*[$TITLE_\\n[#ARG_NUM]]"
.                \}
.                CAPS OFF
.             \}
.             if !'\\*[$SUBTITLE]'' \{\
.                sp
.                nr #ARG_NUM 0 1
.                while \\n[#SUBTITLE_NUM]>=\\n+[#ARG_NUM] \{\
.                   UNDERSCORE 3p "\\*[$SUBTITLE_\\n[#ARG_NUM]]"
.                \}
.             \}
.             if !'\\*[$AUTHOR_1]'' \{\
.                sp
.                PRINT \&\\*[$ATTRIBUTE_STRING]
.                nr #AUTHORS \\n[#AUTHOR_NUM]
.                nr #NEXT_AUTHOR 0 1
.                if !\\n[#SINGLE_SPACE] .vs (\\n[#DOC_LEAD]u/2u)+(\\n[.v]u/3u)
.                while \\n[#AUTHORS]>\\n[#NEXT_AUTHOR] \{\
.                   PRINT \\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]
.                \}
.             \}
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             DEFAULT_DOCHEADER
.          \}
.          ev
.       \}
.\" Chapter doctype
.       if \\n[#DOC_TYPE]=2 \{\
.          if \\n[.ns] .rs
.          ev DOCHEADER
.          if \\n[#DOCHEADER_COLOR]=1 \{\
.             nf
\m[\\*[$DOCHEADER_COLOR]]
.             EOL
.          \}
.          L_MARGIN \\n[#DOC_L_MARGIN]u
.          LL       \\n[#DOC_L_LENGTH]u
.          ta \\n[.l]u
.          if \\n[#PRINT_STYLE]=1 \{\
.             CENTER
.             TYPEWRITER
.             if !\\n[#SINGLE_SPACE] \{\
.                vs (\\n[#DOC_LEAD]u/2u)+(\\n[.v]u/3u)
.                sp |\\n[#T_MARGIN]u-1v
.             \}
.             ie '\\*[$CHAPTER]'' \{\
.                CAPS
.                ie !'\\*[$CHAPTER_TITLE]'' \{\
.                   nr #ARG_NUM 0 1
.                   while \\n[#CHAPTER_TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.                      UNDERSCORE 3p "\\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]"
.                   \}
.                \}
.                el \{\
.                   CAPS
.                   UNDERSCORE 3p "\\*[$CHAPTER_STRING]"
.                \}
.                CAPS OFF
.                RLD 1v
.             \}
.             el \{\
.                CAPS
.                PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.                CAPS OFF
.                if !'\\*[$CHAPTER_TITLE]'' \{\
.                   sp
.                   nr #ARG_NUM 0 1
.                   while \\n[#CHAPTER_TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.                      UNDERSCORE 3p "\\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]"
.                   \}
.                \}
.                RLD 1v
.             \}
.             vs \\n[#DOC_LEAD]u
.             if \\n[#SINGLE_SPACE] .sp 2
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             CHAPTER_DOCHEADER
.             di DOCHEADER_DIVERSION \" This diversion is only
.             br                     \" necessary to find the depth of the
.             CHAPTER_DOCHEADER      \" docheader
.             br
.             di
.             nr #DOCHEADER_DEPTH \\n[dn]-\\n[#DOCHEADER_LEAD] \" Storing the depth (height) of the diversion
.                                                              \" in #DOCHEADER_DEPTH
.             rm DOCHEADER_DIVERSION                           \" Removing the diversion macro
.          \}
.          ev
.       \}
.\" Named
.       if \\n[#DOC_TYPE]=3 \{\
.          if \\n[.ns] .rs
.          ev DOCHEADER
.          if \\n[#DOCHEADER_COLOR]=1 \{\
.             nf
\m[\\*[$DOCHEADER_COLOR]]
.             EOL
.          \}
.          L_MARGIN \\n[#DOC_L_MARGIN]u
.          LL       \\n[#DOC_L_LENGTH]u
.          ta \\n[.l]u
.          if \\n[#PRINT_STYLE]=1 \{\
.             CENTER
.             TYPEWRITER
.             if !\\n[#SINGLE_SPACE] \{\
.                vs (\\n[#DOC_LEAD]u/2u)+(\\n[.v]u/3u)
.                sp |\\n[#T_MARGIN]u-1v
.             \}
.             if !'\\*[$TITLE_1]'' \{\
.                CAPS
.                nr #ARG_NUM 0 1
.                while \\n[#TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.                   UNDERSCORE 3p "\\*[$TITLE_\\n[#ARG_NUM]]"
.                \}
.                CAPS OFF
.             \}
.             if !'\\*[$SUBTITLE]'' \{\
.                sp
.                nr #ARG_NUM 0 1
.                while \\n[#SUBTITLE_NUM]>=\\n+[#ARG_NUM] \{\
.                   UNDERSCORE 3p "\\*[$SUBTITLE_\\n[#ARG_NUM]]"
.                \}
.             \}
.             if !'\\*[$AUTHOR_1]'' \{\
.                sp
.                PRINT \&\\*[$ATTRIBUTE_STRING]
.                nr #AUTHORS \\n[#AUTHOR_NUM]
.                nr #NEXT_AUTHOR 0 1
.                if !\\n[#SINGLE_SPACE] .vs (\\n[#DOC_LEAD]u/2u)+(\\n[.v]u/3u)
.                while \\n[#AUTHORS]>\\n[#NEXT_AUTHOR] \{\
.                   PRINT \\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]
.                \}
.             \}
.             ie !\\n[#SINGLE_SPACE] .sp 2
.             el .sp
.             ie \\n[#DOCTYPE_UNDERLINE] \{\
.             UNDERSCORE2 3p "\\*[$DOC_TYPE]"
.             \}
.             el \
.                PRINT "\\*[$DOC_TYPE]"
.             if \\n[#SINGLE_SPACE]=1 .sp
.          \}
.          if \\n[#PRINT_STYLE]=2 .NAMED_DOCHEADER
.          ev
.       \}
.       if !\\n[#DOC_TYPE]=4 \{\
.          if \\n[#PRINT_STYLE]=1 .sp
.          if \\n[#PRINT_STYLE]=2 .sp \\n[#DOC_LEAD]u*2u
.          if \\n[#COLUMNS] \{\
.             nr #COL_NUM 0 1
.             nr #L_LENGTH_FOR_EPI \\n[#L_LENGTH]
.             ie \\n[#RV_POST_COVER] \{\
.                nr #COL_\\n+[#COL_NUM]_L_MARGIN \\n[#DOC_L_MARGIN]
.                po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.                nr #L_MARGIN \\n[.o]
.                rr #RV_POST_COVER
.             \}
.             el \{\
.                po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.                nr #L_MARGIN \\n[.o]
.             \}
.             LL \\n[#COL_L_LENGTH]u
.             ta \\n[.l]u
.          \}
.       \}
.    \}
.    vs \\n[#DOC_LEAD]u
.    if \\n[#ADJ_DOC_LEAD]=1 \{\
.       ie \\n[#ADVANCE_FROM_TOP]=0 \
.          if \\n[#DOC_HEADER]=1 .SHIM
.       el .rr #ADVANCE_FROM_TOP
.    \}
.    mk dc
.    QUAD \\*[$DOC_QUAD]
.    CLEANUP_DEFAULTS
.    nr #START_FOR_FOOTERS 1
.    if !\\n[#DOC_TYPE]=4 .em TERMINATE
.    if \\n[#LINENUMBERS]=2 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.    \}
.    if \\n[#RUN_ON]=1 \{\
.       if \\n[#FN_MARKER_STYLE]=1 .RUNON_WARNING
.       if \\n[#FN_MARKER_STYLE]=2 .RUNON_WARNING
.    \}
.END
\#
.MAC CLEANUP_DEFAULTS END
.    nr #START 1
.    if \\n[#DOC_HEADER]=1 .nr #DOC_HEADER 2
.    rm $TOC_TITLE_ITEM
.    rr #MISC_NUM
.    rr #MISCS
.    rr #NEXT_AUTHOR
.    rr #NEXT_MISC
.END
\#
\# ====================================================================
\#
\# +++MACROS TO CHANGE SOME DEFAULTS+++
\#
\# DOCUMENT HEADER
\# ---------------
\# *Argument:
\#   <none> | <anything> [distance to advance from top of page]
\# *Function:
\#   Turns printing of document header on or off.  If a second
\#   numeric argument with units of measure is given, advances that
\#   distance from the top of the page without printing the document
\#   header.
\# *Notes:
\#   Default is on.  If the 1st argument is <anything> (which turns
\#   document headers off), the optional 2nd argument may be given
\#   (with a unit of measure).
\#
.MAC DOCHEADER END
.    ie '\\$1'' .nr #DOC_HEADER 1
.    el \{\
.       if !'\\$2'' .nr #ADVANCE_FROM_TOP (\\$2)
.       nr #DOC_HEADER 0
.    \}
.END
\#
\# DOCUMENT HEADER LEADING
\# -----------------------
\# *Arguments:
\#   <+|- amount by which to in/decrease leading of doc header>
\# *Function:
\#   Stores user supplied lead in/decrease in string $DOCHEADER_LEAD_ADJ.
\# *Notes:
\#   A unit of measure must be supplied.  Decimal fractions OK.
\#   Default is +0, i.e. same as DOC_LEAD.
\#
.MAC DOCHEADER_LEAD END
.    ds $DOCHEADER_LEAD_ADJ \\$1
.END
\#
\# DOCHEADER ADVANCE
\# -----------------
\# *Arguments:
\#   <docheader start position>
\# *Function:
\#   Creates register #DOCHEADER_ADVANCE, used in START.
\# *Notes:
\#   Unit of measure required.
\#   Default is same as T_MARGIN.
\#
.MAC DOCHEADER_ADVANCE END
.    nr #DOCHEADER_ADVANCE \\$1
.END
\#
\# DOCUMENT LEFT MARGIN
\# --------------------
\# *Argument:
\#   <left margin of document>
\# *Function:
\#   Creates or modifies register #DOC_L_MARGIN.
\# *Notes:
\#   Affects everything on the page.
\#
.MAC DOC_LEFT_MARGIN END
.    if !\\n[#DOCS] .DOC_MACRO_ERROR \\$0
.    br
.    nr #DOC_L_MARGIN (\\$1)
.    L_MARGIN \\n[#DOC_L_MARGIN]u
.END
\#
\# DOCUMENT RIGHT MARGIN
\# ---------------------
\# *Argument:
\#   <right margin of document>
\# *Function:
\#   Creates or modifies register #DOC_R_MARGIN.
\# *Notes:
\#   Affects everything on the page.
\#
.MAC DOC_RIGHT_MARGIN END
.    br
.    nr #DOC_R_MARGIN (\\$1)
.    R_MARGIN \\n[#DOC_R_MARGIN]
.    nr #DOC_L_LENGTH \\n[#L_LENGTH]
.END
\#
\# DOCUMENT LINE LENGTH
\# --------------------
\# *Argument:
\#   <line length of document>
\# *Function:
\#   Creates or modifies register #DOC_L_LENGTH.
\# *Notes:
\#   Affects everything on the page.
\#
.MAC DOC_LINE_LENGTH END
.    if !\\n[DOCS] .DOC_MACRO_ERROR \\$0
.    br
.    nr #DOC_L_LENGTH (\\$1)
.    LL \\n[#DOC_L_LENGTH]u
.    ta \\n[.l]u
.END
\#
\# DOCUMENT FAMILY
\# ---------------
\# *Argument:
\#   <family of running text>
\# *Function:
\#   Creates or modifies string $DOC_FAM.
\# *Notes:
\#   Affects everything except headers and footers.
\#
.MAC DOC_FAMILY END
.    if !\\n[DOCS] .DOC_MACRO_ERROR \\$0
.    br
.    ds $DOC_FAM \\$1
.    ds $FAMILY  \\*[$DOC_FAM]
.    AUTHOR_FAMILY     \\*[$DOC_FAM]
.    BLOCKQUOTE_FAMILY \\*[$DOC_FAM]
.    DOCHEADER_FAMILY  \\*[$DOC_FAM]
.    DOCTYPE_FAMILY    \\*[$DOC_FAM]
.    EPIGRAPH_FAMILY   \\*[$DOC_FAM]
.    FOOTNOTE_FAMILY   \\*[$DOC_FAM]
.    HDRFTR_FAMILY     \\*[$DOC_FAM]
.    LINENUMBER_FAMILY \\*[$DOC_FAM]
.    QUOTE_FAMILY      \\*[$DOC_FAM]
.    SUBTITLE_FAMILY   \\*[$DOC_FAM]
.    TITLE_FAMILY      \\*[$DOC_FAM]
.END
\#
\# DOCUMENT POINT SIZE
\# -------------------
\# *Argument:
\#   <point size of running text>
\# *Function:
\#   Creates or modifies register #DOC_PT_SIZE.
\# *Notes:
\#   DOC_PT_SIZE is the basis for calculating all type sizes in
\#   a document.  Ignored if PRINTSTYLE TYPEWRITE.
\#
.ALIAS DOC_PT_SIZE PT_SIZE
\#
\# DOCUMENT LEAD
\# -------------
\# *Argument:
\#   <lead (".vs") of running text> [ADJUST]
\# *Function:
\#   Creates or modifies register #DOC_LEAD.  If the optional
\#   ADJUST argument is given, adjusts leading so that the last
\#   line of text falls exactly on #B_MARGIN.
\# *Notes:
\#   DOC_LEAD is the basis for calculating all leading changes in
\#   a document.  Default for TYPESET is 16; 24 for TYPEWRITE.
\#
\#   Because the visible bottom or footer margin of a page depends
\#   on the overall document lead supplied by the register #DOC_LEAD,
\#   DOC_LEAD, in the body of a document, should always be associated
\#   with the start of a new page (in other words, just before or
\#   just after a manual NEWPAGE).  Ignored if PRINTSTYLE TYPEWRITE.
\#
.MAC DOC_LEAD END
.    if \\n[#IGNORE] .return
.    if !\\n[#DOCS] .DOC_MACRO_ERROR \\$0
.    br
.    if '\\$0'DOC_LEAD' \{\
.       vs \\$1
.       rr #DOC_AUTOLEAD
.       rr #DOC_AUTOLEAD_FACTOR
.       nr #DOC_LEAD \\n[.v]
.    \}
.    nr #RESET_TRAPS 1
.    if !\\n[#ADJ_DOC_LEAD] .nr #REMOVE_ADJ 1
.    if !'\\$0'DOC_LEAD' \{\
.       if '\\$0'EN_LEAD' .nr #DOC_LEAD \\n[#EN_LEAD]
.       if '\\$0'BIB_LEAD' .nr #DOC_LEAD \\n[#BIB_LEAD]
.       if '\\$0'TOC_LEAD' .nr #DOC_LEAD \\n[#TOC_LEAD]
.       if '\\$2'ADJUST' .TRAPS
.       rr #RESET_TRAPS
.    \}
.END
\#
\# ADJUST DOCUMENT LEAD
\# --------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Adjusts document lead so that the last line of text falls exactly
\#   on #B_MARGIN.
\#
.MAC DOC_LEAD_ADJUST END
.    ie '\\$1'' \{\
.       nr #ADJ_DOC_LEAD 1
.       rr #DOC_LEAD_ADJUST_OFF
.    \}
.    el \{\
.       nr #ADJ_DOC_LEAD 0
.       nr #DOC_LEAD_ADJUST_OFF 1
.    \}
.END
\#
\# SHIM
\# ----
\# *Argument:
\#   None
\# *Function:
\#   Advances to the next "valid" baseline.
\# *Notes:
\#   If a user plays around with spacing in a doc (say, with ALD),
\#   it isn't easy to get mom back on track so she can achieve
\#   perfectly flush bottom margins.  Any time SHIM is used, it
\#   ensures that the next output line falls on a valid baseline.
\#
\# First, a little convenience macro
\#
.MAC PROCESS_SHIM END
.    while \\n+[#VALID_BASELINE]<\\n[#CURRENT_V_POS] \{\
.
.    \}
.    nr #SHIM \\n[#VALID_BASELINE]-\\n[#CURRENT_V_POS]
.END
\#
\# And a macro to disable SHIM
\#
.MAC NO_SHIM END
.    ie '\\$1'' .nr #NO_SHIM 1
.    el .rr #NO_SHIM
.END
\#
.nr #NO_SHIM 2 \" Restored to 1 in DEFAULTS.
\#
.MAC SHIM END
.    ie \\n[#NO_SHIM] .return
.    el \{\
.       nr #VALID_BASELINE \\n[#T_MARGIN]-\\n[#DOC_LEAD] \\n[#DOC_LEAD]
.       if !r#CURRENT_V_POS .nr #CURRENT_V_POS \\n[.d]
.       ie \\n[#ADVANCE_FROM_TOP] \{\
.          ie \\n[#CURRENT_V_POS]<(\\n[#T_MARGIN]-1v) \{\
.             while \\n-[#VALID_BASELINE]>\\n[#CURRENT_V_POS] .
.             nr #VALID_BASELINE +\\n[#DOC_LEAD]
.             nr #SHIM \\n[#VALID_BASELINE]-\\n[#CURRENT_V_POS]
.          \}
.          el .PROCESS_SHIM
.       \}
.       el .PROCESS_SHIM
'       sp \\n[#SHIM]u
.       rr #CURRENT_V_POS
.    \}
.END
\#
\# ====================================================================
\#
\# +++INTERNATIONALIZATION+++
\#
\# ATTRIBUTE STRING
\# ----------------
\# *Argument:
\#   <what goes in the "by" slot before author in the document header>
\# *Function:
\#   Creates or modifies string $ATTRIBUTE_STRING.
\# *Notes:
\#   Default is "by".  A blank string ("") may be used if no
\#   attribution is desired.  Blank line results.
\#
.MAC ATTRIBUTE_STRING END
.    if !'\\$1'DOC_COVER' \
.       if !'\\$1'COVER' .nr #NEITHER 1
.    if !'\\$1'COVER' \
.       if !'\\$1'DOC_COVER' .nr #NEITHER 1
.    if '\\$1'DOC_COVER' \
.       ds $ATTRIBUTE_STRING_DOC_COVER \\$2
.    if '\\$1'COVER' \
.       ds $ATTRIBUTE_STRING_COVER \\$2
.    if \\n[#NEITHER]=1 \{\
.       ds $ATTRIBUTE_STRING \\$1
.       rr #NEITHER
.    \}
.END
\#
\# CHAPTER STRING
\# --------------
\# *Argument:
\#   <what to print any time the word "chapter" is required>
\# *Function:
\#   Creates or modifies string $CHAPTER_STRING.
\# *Notes:
\#   Default is "chapter".
\#
.MAC CHAPTER_STRING END
.    ds $CHAPTER_STRING \\$1
.END
\#
\# DRAFT STRING
\# ------------
\# *Argument:
\#   <what to print any time the word "draft" is required>
\# *Function:
\#   Creates or modifies string $DRAFT_STRING.
\# *Notes:
\#   Default is "draft".
\#
.MAC DRAFT_STRING END
.    ds $DRAFT_STRING \\$1
.END
\#
\# REVISION STRING
\# ---------------
\# *Argument:
\#   <what to print any time the word "revision" is required>
\# *Function:
\#   Creates or modifies string $REVISION_STRING.
\# *Notes:
\#   Default is "revision".
\#
.MAC REVISION_STRING END
.    ds $REVISION_STRING \\$1
.END
\#
\# FINIS STRING
\# ------------
\# *Argument:
\#   <what to print with the finis macro>
\# *Function:
\#   Creates or modifies string $FINIS_STRING.
\# *Notes:
\#   Default is "END".
\#
.MAC FINIS_STRING END
.    ds $FINIS_STRING \\$1
.END
\#
.MAC FINIS_STRING_CAPS END
.    ie '\\$1'' .nr #FINIS_STRING_CAPS 1
.    el .nr #FINIS_STRING_CAPS 0
.END
\#
\# ====================================================================
\#
\# +++RECTO/VERSO+++
\#
\# RECTO_VERSO
\# -----------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Switches HDRFTR_LEFT and HDRFTR_RIGHT on alternate pages.  Also
\#   switches page numbers left and right if either is chosen rather
\#   than the default centered page numbers.  Switches left and right
\#   margins if differing values have been entered.
\# *Notes:
\#   Default is OFF.
\#
.MAC RECTO_VERSO END
.    ie '\\$1'' .nr #RECTO_VERSO 1
.    el .nr #RECTO_VERSO 0
.END
\#
\# FORCE RECTO
\# -----------
\# *Function:
\#   Forces doccover and cover pages to recto
\#
.MAC RV_HARD_SET_MARGINS END
.    DOC_LEFT_MARGIN  \\n[@L_MARGIN]u
.    DOC_RIGHT_MARGIN \\n[@R_MARGIN]u
.    po \\n[#DOC_L_MARGIN]u
.    LL \\n[#DOC_L_LENGTH]u
.END
\#
\# ====================================================================
\#
\# +++EPIGRAPHS+++
\#
\# EPIGRAPH INDENT
\# ---------------
\# *Argument:
\#   <value by which to multiply PP_INDENT for block epigraphs>
\# *Function:
\#   Creates or modifies register #EPI_OFFSET_VALUE.
\# *Notes:
\#   Default is 2 for TYPEWRITE, 3 for TYPESET.
\#
.MAC EPIGRAPH_INDENT END
.    rr #EPI_OFFSET_VALUE
.    rm $EPI_OFFSET_VALUE
.    ds $EVAL_EI_ARG \\$1
.    substring $EVAL_EI_ARG -1
.    ie \B'\\*[$EVAL_EI_ARG]' .nr #EPI_OFFSET_VALUE \\$1
.    el .ds $EPI_OFFSET_VALUE \\$1
.    rm $EVAL_EI_ARG
.END
\#
\# EPIGRAPH AUTOLEAD
\# -----------------
\# *Argument:
\#   <amount of lead to add to the epigraph ps for epigraph leading>
\# *Function:
\#   Creates or modifies register #EPI_AUTOLEAD.
\# *Notes:
\#   Default is 2 (for TYPESET; TYPEWRITE doesn't require this).
\#
.MAC EPIGRAPH_AUTOLEAD END
.    nr #EPI_AUTOLEAD (p;\\$1)
.END
\#
\# EPIGRAPH
\# --------
\# *Arguments:
\#   BLOCK | <anything>
\# *Function:
\#   Places an epigraph before the document's text, after the
\#   document header, or after a HEAD.
\# *Notes:
\#   #EPIGRAPH 1 = centered; 2 = block
\#
\#   By default, epigraphs are centered, allowing the user
\#   to input them on a line per line basis.  To change this
\#   behaviour, the user can supply the argument BLOCK, which
\#   will produce indented, filled text similar to BLOCKQUOTE.
\#
\#   If a block epigraph contains more than one para, ALL paras of
\#   the epigraph must be preceded by PP.  Otherwise, PP is optional.
\#
.MAC EPIGRAPH END
.    nr #PP_STYLE 2
.    nr #Q_PP     0
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#START] \{\
.       if \\n[#PRINT_STYLE]=1 \
.          if \\n[#AUTHOR_LINES]=1 .sp \\n[#DOC_LEAD]u
.    \}
.    ie '\\$1'' \{\
.       nr #EPIGRAPH 1
.       ev EPIGRAPH
.       nr #IN_DIVER 1
.       ll \\n[#L_LENGTH]u
.       ta \\n[.l]u
.       CHECK_INDENT
.       if \\n[#COLUMNS] \{\
.          ie \\n[#START] \{\
.              ll \\n[#DOC_L_LENGTH]u
.              ta \\n[.l]u
.          \}
.          el \{\
.             ll \\n[#COL_L_LENGTH]u
.             ta \\n[.l]u
.          \}
.       \}
.       CENTER
.       if \\n[#PRINT_STYLE]=1 \{\
.          fam \\*[$TYPEWRITER_FAM]
.          ft  R
.          if '\\*[$EPI_FT]'I' .FT I
.          ps  \\*[$TYPEWRITER_PS]
.          ie \\n[#SINGLE_SPACE] .vs \\n[#DOC_LEAD]u
.          el .vs \\n[#DOC_LEAD]u/2u
.          nr #EPI_LEAD      \\n[#LEAD]
.          nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY   \\*[$EPI_FAM]
.          FT       \\*[$EPI_FT]
.          ps  \\n[#DOC_PT_SIZE]u\\*[$EPI_SIZE_CHANGE]
.          if \\n[#EPI_COLOR]=1 \{\
.             nf
\m[\\*[$EPI_COLOR]]
.             EOL
.          \}
.          vs \\n[.ps]u+\\n[#EPI_AUTOLEAD]u
.          nr #EPI_LEAD      \\n[#LEAD]
.          nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.       \}
.       di EPI_TEXT
.       nr #DIVERSIONS_HY_MARGIN (p;\\n[.ps]u*2.75)/1000
.       HY_SET 1 \\n[#DIVERSIONS_HY_MARGIN]u (\\n[#PT_SIZE]u/1000u/8u)p
.       hy 14
.       nr #EPI_ACTIVE 1
.    \}
.    el \{\
.       ie '\\$1'BLOCK' \{\
.          nr #EPIGRAPH 2
.          ev EPIGRAPH
.          evc 0
.          ie \\n[#START] \{\
.             ie \\n[#COLUMNS] \{\
.                ie r#EPI_OFFSET_VALUE \
.                   ll \
\\n[#L_LENGTH_FOR_EPI]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.                el \
.                   ll \
\\n[#L_LENGTH_FOR_EPI]u-(\\*[$EPI_OFFSET_VALUE]u*2u)
.                ta \\n[.l]u
.             \}
.             el \{\
.                ie r#EPI_OFFSET_VALUE \
.                   ll \
\\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.                el \
.                   ll \\n[#L_LENGTH]u-(\\*[$EPI_OFFSET_VALUE]*2u)
.                ta \\n[.l]u
.             \}
.          \}
.          el \{\
.             ie r#EPI_OFFSET_VALUE \
.                ll \
\\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.             el \
.                ll \\n[#L_LENGTH]u-(\\*[$EPI_OFFSET_VALUE]*2u)
.             ta \\n[.l]u
.             if \\n[#COLUMNS] \{\
.                ie r#EPI_OFFSET_VALUE \
.                   ll \
\\n[#COL_L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.                el \
.                   ll \\n[#COL_L_LENGTH]u-(\\*[$EPI_OFFSET_VALUE]*2u)
.                ta \\n[.l]u
.             \}
.             CHECK_INDENT
.          \}
.          if \\n[#PRINT_STYLE]=1 \{\
.             fam \\*[$TYPEWRITER_FAM]
.             ft  R
.             if '\\*[$EPI_FT]'I' .FT I
.             ps  \\*[$TYPEWRITER_PS]
.             ie \\n[#SINGLE_SPACE] .vs \\n[#DOC_LEAD]u
.             el .vs \\n[#DOC_LEAD]u/2u
.             QUAD LEFT
.             HY OFF
.             nr #EPI_LEAD \\n[#LEAD]
.             nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.             di EPI_TEXT
.             nr #EPI_ACTIVE 1
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY   \\*[$EPI_FAM]
.             FT       \\*[$EPI_FT]
.             ps  \\n[#DOC_PT_SIZE]u\\*[$EPI_SIZE_CHANGE]
.             if \\n[#EPI_COLOR]=1 \{\
.                nf
\m[\\*[$EPI_COLOR]]
.                EOL
.             \}
.             vs \\n[.ps]u+\\n[#EPI_AUTOLEAD]u
.             QUAD     \\*[$EPI_QUAD]
.             nr #DIVERSIONS_HY_MARGIN (p;\\n[.ps]u*2.75)/1000
.             HY_SET 1 \\n[#DIVERSIONS_HY_MARGIN]u (\\n[#PT_SIZE]u/1000u/8u)p
.             hy 14
.             nr #EPI_LEAD \\n[#LEAD]
.             nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.             di EPI_TEXT
.             nr #EPI_ACTIVE 1
.          \}
.       \}
.       el .DO_EPIGRAPH
.    \}
.END
\#
\# DO EPIGRAPH
\# -----------
\# *Arguments:
\#   <none>
\# *Function:
\#   Ends diversion started in EPIGRAPH.  Makes spacing
\#   adjustments to compensate for the difference between epigraph
\#   leading and overall document leading, so that the bottom of
\#   the pages remain flush.
\# *Notes:
\#   In addition to its usual place at the beginning of a
\#   document, EPIGRAPH may also be used after HEAD.
\#
.MAC DO_EPIGRAPH END
.    br
.    di
.    rr #IN_DIVER
.    if \\n[#RESET_FN_COUNTERS]=2 \{\
.       if !\\n[#FN_COUNT]=1 \{\
.          if ((\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS])+\\n[#DIVER_DEPTH])>(\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS]) \{\
.             DIVER_FN_2_POST
.             rr #RESET_FN_COUNTERS
.          \}
.       \}
.    \}
.    nr #SAVED_FN_NUMBER \\n[#FN_NUMBER]
.    nr #DONE_ONCE 0 1
.    REMOVE_INDENT
.    ev
.    nr #EPI_DEPTH \\n[#DIVER_DEPTH]-\\n[#EPI_LEAD]
.    nr #EPI_LINES \\n[#EPI_DEPTH]/\\n[#EPI_LEAD]
.    ie \\n[#START] \{\
.       RLD \\n[#SHIM]u
.       nr #EPI_WHITESPACE (\\n[#DOC_LEAD]*\\n[#EPI_LINES])-\\n[#EPI_DEPTH]
.       while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.          nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.       \}
.       if \\n[#PRINT_STYLE]=1 \
.          if !\\n[#SINGLE_SPACE]=1 .ALD \\n[#DOC_LEAD]u
.       if \\n[#PRINT_STYLE]=2 \{\
.          ie !\\n[#DOC_TYPE]=2 .RLD \\n[#DOC_LEAD]u
.          el \{\
.             ie '\\*[$CHAPTER_TITLE]'' .RLD \\n[#DOC_LEAD]u
.             el .if '\\*[$CHAPTER]''   .RLD \\n[#DOC_LEAD]u
.          \}
.          if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \
.             ALD \\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)
.          if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \
.             ALD \
\\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.       \}
.    \}
.    el \{\
.       ie \\n[#EPI_DEPTH]<\\n[#TRAP_DISTANCE] \{\
.          nr #EPI_FITS 1
.          nr #EPI_WHITESPACE (\\n[#DOC_LEAD]*\\n[#EPI_LINES])-\\n[#EPI_DEPTH]
.          while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.             nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.          \}
.          ie \\n[#PRINT_STYLE]=1 \{\
.             if \\n[#EPI_WHITESPACE]=\\n[#DOC_LEAD] \
.                ALD \\n[#EPI_WHITESPACE]u/2u
.          \}
.          el \{\
.             if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \
.                ALD \
\\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)
.             if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \
.                ALD \
\\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.          \}
.          if \\n[#DIVER_FN]=2 .rr #DIVER_FN
.       \}
.       el \{\
.          nr #EPI_LINES_TO_TRAP 0 1
.          while \\n[#EPI_LEAD]*\\n+[#EPI_LINES_TO_TRAP]<\\n[#TRAP_DISTANCE] \{\
.             nr #LOOP 1
.          \}
.          nr #EPI_LINES_TO_TRAP -1
.          nr #EPI_WHITESPACE \
(\\n[#EPI_LINES_TO_TRAP]*\\n[#DOC_LEAD])-(\\n[#EPI_LINES_TO_TRAP]*\\n[#EPI_LEAD])
.          while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.             nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.          \}
.          if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \
.             ALD \\n[#EPI_WHITESPACE]u
.          if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \
.             ALD \\n[#EPI_WHITESPACE]u-\\n[#DOC_LEAD]u
.       \}
.    \}
.    if \\n[#EPIGRAPH]=1 \{\
.       po \\n[#L_MARGIN]u
.       if \\n[#COLUMNS] \{\
.          po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n[.o]
.       \}
.    \}
.    if \\n[#EPIGRAPH]=2 \{\
.       ie \\n[#EPI_OFFSET_VALUE] \
.          nr #EPI_OFFSET \
\\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.       el .nr #EPI_OFFSET \\n[#L_MARGIN]+\\*[$EPI_OFFSET_VALUE]
.       if \\n[#COLUMNS] \{\
.          ie r#EPI_OFFSET_VALUE \
.             nr #EPI_OFFSET \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.          el .nr #EPI_OFFSET \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]+\\*[$EPI_OFFSET_VALUE]
.       \}
.       po \\n[#EPI_OFFSET]u
.    \}
.    nf
.    EPI_TEXT
.    br
.    ie \\n[#START] \{\
.       if \\n[#PRINT_STYLE]=1 .SHIM
.       if \\n[#PRINT_STYLE]=2 \{\
.          if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \
.             ALD \\n[#EPI_WHITESPACE]u/2u
.          if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \
.             ALD (\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.          SHIM
.       \}
.    \}
.    el \{\
.       rr #EPI_ACTIVE
.       ie \\n[#EPI_FITS] \{\
.          ie \\n[#FN_FOR_EPI] \{\
.             nr #EPI_LINES_TO_END 1
.             nr #EPI_WHITESPACE \
(\\n[#EPI_LINES_TO_END]*\\n[#DOC_LEAD])-(\\n[#EPI_LINES_TO_END]*\\n[#EPI_LEAD])
.             while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.                nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.             \}
.             ALD \\n[#EPI_WHITESPACE]u-(\\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u)
.          \}
.          el \{\
.             ie \\n[#PRINT_STYLE]=1 \{\
.                if \\n[#EPI_WHITESPACE]=\\n[#DOC_LEAD] \
.                   ALD \\n[#EPI_WHITESPACE]u
.             \}
.             el \{\
.                if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \
.                   ALD \\n[#EPI_WHITESPACE]u/2u
.                if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \
.                   ALD (\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.             \}
.          \}
.       \}
.       el \{\
.          nr #EPI_LINES_TO_END \\n[#EPI_LINES]-\\n[#EPI_LINES_TO_TRAP]
.          if \\n[#LOOP] .nr #EPI_LINES_TO_END +1
.          rr #LOOP
.          nr #EPI_WHITESPACE \
(\\n[#EPI_LINES_TO_END]*\\n[#DOC_LEAD])-(\\n[#EPI_LINES_TO_END]*\\n[#EPI_LEAD])
.          while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.             nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.          \}
.          ALD \\n[#EPI_WHITESPACE]u-(\\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u)
.          if \\n[#PRINT_STYLE]=1 \{\
.             if !\\n[#SINGLE_SPACE] \{\
.                nr #EPI_LINES_EVEN \\n[#EPI_LINES_TO_END]%2
.                ie \\n[#EPI_LINES_EVEN] .ALD .5v
.                el .RLD .5v
.                rr #EPI_LINES_EVEN
.             \}
.          \}
.       \}
.    \}
.    nr #PP_STYLE 1
.    rr #EPI_FITS
.    ALD \\n[#DOC_LEAD]u
.    QUAD \\*[$DOC_QUAD]
.    po \\n[#L_MARGIN]u
.    if \\n[#COLUMNS] \{\
.       po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.       nr #L_MARGIN \\n[.o]
.    \}
.    if \\n[#START] \{\
.       if \\n[#COLUMNS] \{\
.          po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n[.o]
.          mk dc
.       \}
.    \}
.    if \\n[#LINENUMBERS]=2 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.    \}
.END
\#
\# ====================================================================
\#
\# +++FINIS MACRO+++
\#
\# FINIS
\# -----
\# *Arguments:
\#   <none>
\# *Function:
\#   Deposits --END-- at the end of a document.
\#
.MAC FINIS END
.    if !\\n[@TOP] \{\
.       if \\n[.t]<=2v \{\
.          tm1 "[mom]: '\\n[.F]': Insufficient room to print \\$0 on last page.
.          return
.       \}
.    \}
.    br
.    ev FINIS
.    evc 0
.    if \\n[#TAB_ACTIVE] .TQ
.    if \\n[#INDENT_ACTIVE] .IQ CLEAR
.    nr #EM_ADJUST (1m/8)
.    if \\n[#COLUMNS] \{\
.       po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.       nr #L_MARGIN \\n[.o]
.    \}
.    ALD \\n[#DOC_LEAD]u
.    CENTER
.    if \\n[#FINIS_STRING_CAPS]=1 .CAPS
.    if \\n[#PRINT_STYLE]=1 .PRINT "--\\*[$FINIS_STRING]--
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#FINIS_COLOR] \
.          PRINT \
\m[\\*[$FINIS_COLOR]]\v'-\\n[#EM_ADJUST]u'\[em]\v'+\\n[#EM_ADJUST]u'\
\\*[$FINIS_STRING]\v'-\\n[#EM_ADJUST]u'\*[FU1]\[em]\m[]\c
.       el .PRINT \
\v'-\\n[#EM_ADJUST]u'\[em]\v'+\\n[#EM_ADJUST]u'\
\\*[$FINIS_STRING]\v'-\\n[#EM_ADJUST]u'\*[FU1]\[em]\m[]\c
.    \}
.    EL
.    if \\n[#FINIS_STRING_CAPS]=1 .CAPS OFF
.    ev
.    pdfsync
.END
\#
\# ====================================================================
\#
\# +++HEADERS/FOOTERS+++
\#
\# Define a string so that the current page number can be incorporated
\# into the strings for hdrftr left, right, and center.  NOTE: This is
\# not the same thing as using the shortform # in hdrftr strings.
\#
.ds PAGE# \En[#PAGENUMBER]
\#
.MAC RESTORE_SPACE END
.   vpt 0
.   rs
.   nop \&
.   sp -1
.   ch RR_@TOP
.   rr @TOP
.   vpt
.END
\#
\# HDRFTR RULE GAP
\# ---------------
\# *Argument:
\#   <amount of space between header/footer and header/footer rule>
\# *Function:
\#   Creates or modifies register #HDRFTR_RULE_GAP to hold amount
\#   of space between header/footer and header/footer rule.
\# *Notes:
\#   Default is 4p.
\#
.MAC HDRFTR_RULE_GAP END
.    nr #HDRFTR_RULE_GAP (\\$1)
.    if '\\$0'HEADER_RULE_GAP' \{\
.       nr #HEADER_RULE_GAP \\n[#HDRFTR_RULE_GAP]
.       if r #FOOTER_RULE_GAP .nr #FOOTER_RULE_GAP \\n[#FOOTER_RULE_GAP]
.    \}
.    if '\\$0'FOOTER_RULE_GAP' \{\
.       nr #FOOTER_RULE_GAP \\n[#HDRFTR_RULE_GAP]
.       if r #HEADER_RULE_GAP .nr #HEADER_RULE_GAP \\n[#HEADER_RULE_GAP]
.    \}
.END
\#
\# HDRFTR LEFT
\# -----------
\# *Argument:
\#   <what to put in the left position of page header/footers>
\# *Function:
\#   Creates or modifies string $HDRFTR_LEFT.
\#   Creates register #USER_DEF_HDRFTR_LEFT, which, if 1,
\#   overrides the $HDRFTR_LEFT string created by default
\#   in DEFAULTS.
\# *Notes:
\#   Especially useful if doc has more than one author, and a list
\#   of authors by last name is desired in header/footers.
\#   Default is author.
\#
\#   If the argument is the # character, simply prints the current
\#   page number.
\#
\#   If the user wants to incorporate the page number into the string,
\#   \*[PAGE#] must be used.  For example, if the user wants to put
\#   an elipsis before the page number in the string, s/he should use
\#   ...\*[PAGE#], not ...#
\#
.MAC HDRFTR_LEFT END
.    nr #USER_DEF_HDRFTR_LEFT 1
.    ds $HDRFTR_LEFT \\$1
.END
\#
\# HDRFTR LEFT CAPS
\# ----------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalisation of $HDRFTR_LEFT (typically, the author of
\#   the document) on or off.
\# *Notes:
\#   Default is on.
\#
.MAC HDRFTR_LEFT_CAPS END
.    ie '\\$1'' .nr #HDRFTR_LEFT_CAPS 1
.    el \{\
.       nr #HDRFTR_LEFT_CAPS 0
.       ds $HDRFTR_LEFT_SIZE_CHANGE +0
.    \}
.END
\#
\# HDRFTR CENTER
\# -------------
\# *Argument:
\#   <what to put in the centre position of page header/footers>
\# *Function:
\#   Creates or modifies string $HDRFTR_CENTER.
\#   Creates register #USER_DEF_HDRFTR_CENTER, which, if 1,
\#   overrides the $HDRFTR_CENTER string created by default
\#   in COPYSTYLE.
\# *Notes:
\#   Default is document type if DOCTYPE NAMED, Chapter # if DOCTYPE
\#   CHAPTER, draft and revision number if COPYSTYLE DRAFT.
\#
\#   If the argument is the # character, simply prints the current
\#   page number.
\#
\#   If the user wants to incorporate the page number into the string,
\#   \*[PAGE#] must be used.  For example, if the user wants to put
\#   an elipsis before the page number in the string, s/he should use
\#   ...\*[PAGE#], not ...#
\#
.MAC HDRFTR_CENTER END
.    nr #USER_DEF_HDRFTR_CENTER 1
.    if '\\$0'FOOTER_CENTER' \{\
.       ds $HDRFTR_CENTER_OLD \\*[$HDRFTR_CENTER]
.       ds $HDRFTR_CENTER_NEW \\$1
.    \}
.    if '\\$0'FOOTER_CENTRE' \{\
.       ds $HDRFTR_CENTER_OLD \\*[$HDRFTR_CENTER]
.       ds $HDRFTR_CENTER_NEW \\$1
.    \}
.    ds $HDRFTR_CENTER \\$1
.END
\#
\# HDRFTR CENTER CAPS
\# ------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalisation of $HDRFTR_CENTER (typically, doctype of
\#   the document) on or off.
\# *Notes:
\#   Default is on.
\#
.MAC HDRFTR_CENTER_CAPS END
.    ie '\\$1'' .nr #HDRFTR_CENTER_CAPS 1
.    el \{\
.       nr #HDRFTR_CENTER_CAPS 0
.       ds $HDRFTR_CENTER_SIZE_CHANGE +0
.    \}
.END
\#
\# HDRFTR CENTER PADDING
\# ---------------------
\# *Argument:
\#   LEFT | RIGHT <amount of padding to put left or right of hdrftr
\#   center string>
\# *Function:
\#   Creates or modifies registers #HDRFTR_CTR_PAD_LEFT or
\#   #HDRFTR_CTR_PAD_RIGHT.
\# *Notes:
\#   By default, the HDRFTR_CENTER string is centered on the doc
\#   line length.  Long titles or long author names can screw up
\#   visual centering, or create overprints.  This macro allows the
\#   user to pad the center string by the specified amount of space
\#   to fix these problems.
\#
\#   A unit of measure is required.
\#
.MAC HDRFTR_CENTER_PAD END
.    if '\\$1'LEFT'  .nr #HDRFTR_CTR_PAD_LEFT (\\$2)
.    if '\\$1'RIGHT' .nr #HDRFTR_CTR_PAD_RIGHT (\\$2)
.END
\#
\# SWITCH HDRFTR CENTER PADDING SIDE - support macro
\# --------------------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Switches the padding side of hdrftr center padding.
\# *Notes:
\#   Required to keep spacing around hdrftr string constant
\#   in recto/verso documents.
\#
.MAC SWITCH_HDRFTR_CENTER_PAD END
.    nr #HDRFTR_CTR_PAD_TMP  \\n[#HDRFTR_CTR_PAD_LEFT]
.    HDRFTR_CENTER_PAD LEFT  \\n[#HDRFTR_CTR_PAD_RIGHT]u
.    HDRFTR_CENTER_PAD RIGHT \\n[#HDRFTR_CTR_PAD_TMP]u
.END
\#
\# HDRFTR RIGHT
\# ------------
\# *Argument:
\#   <what to put in the right position of page header/footers>
\# *Function:
\#   Creates or modifies string $HDRFTR_RIGHT.
\#   Creates register #USER_DEF_HDRFTR_RIGHT, which, if 1,
\#   overrides the $HDRFTR_RIGHT string created by default
\#   in DEFAULTS.
\# *Notes:
\#   Default is document title.
\#
\#   If the argument is the # character, simply prints the current
\#   page number.
\#
\#   If the user wants to incorporate the page number into the string,
\#   \*[PAGE#] must be used.  For example, if the user wants to put
\#   an elipsis before the page number in the string, s/he should use
\#   ...\*[PAGE#], not ...#
\#
.MAC HDRFTR_RIGHT END
.    nr #USER_DEF_HDRFTR_RIGHT 1
.    ds $HDRFTR_RIGHT \\$1
.END
\#
\# HDRFTR RIGHT CAPS
\# -----------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalisation of $HDRFTR_RIGHT (typically, the title of
\#   the document) on or off.
\# *Notes:
\#   Default is on.
\#
.MAC HDRFTR_RIGHT_CAPS END
.    ie '\\$1'' .nr #HDRFTR_RIGHT_CAPS 1
.    el \{\
.       nr #HDRFTR_RIGHT_CAPS 0
.       ds $HDRFTR_RIGHT_SIZE_CHANGE +0
.    \}
.END
\#
\# HDRFTR RULE
\# -----------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   If invoked via the alias HDRFTR_RULE_INTERNAL in HDRFTR, prints a rule
\#   under the header/over the footer.  Otherwise, turns HDRFTR_RULE
\#   on or off.
\#
.MAC HDRFTR_RULE END
.    if r #HEADERS_ON \
.       if \\n[#HEADERS_ON]=1 .nr #HDRFTR_RULE_GAP \\n[#HEADER_RULE_GAP]
.    if r #FOOTERS_ON \
.       if \\n[#FOOTERS_ON]=1 .nr #HDRFTR_RULE_GAP \\n[#FOOTER_RULE_GAP]
.    if '\\$0'HDRFTR_RULE_INTERNAL' \{\
.       ie \\n[#USERDEF_HDRFTR] \{\
.          nr #CAP_HEIGHT_ADJUST \\n[#HDRFTR_HEIGHT]
.          if \\n[#HEADERS_ON] \{\
.             rt \\n[y]u
.             ALD \\n[#HDRFTR_RULE_GAP]u
.             nr #HDRFTR_RULE_WEIGHT \\n[#HEADER_RULE_WEIGHT]
.             nr #HDRFTR_RULE_WEIGHT_ADJ \\n[#HEADER_RULE_WEIGHT_ADJ]
.          \}
.          if \\n[#FOOTERS_ON] \{\
.             rt \\n[y]u
.             RLD \
\\n[#HDRFTR_RULE_GAP]u+\\n[#CAP_HEIGHT_ADJUST]u+\\n[#FOOTER_RULE_WEIGHT]u
.             nr #HDRFTR_RULE_WEIGHT \\n[#FOOTER_RULE_WEIGHT]
.             nr #HDRFTR_RULE_WEIGHT_ADJ \\n[#FOOTER_RULE_WEIGHT_ADJ]
.          \}
.          ie \\n[#HDRFTR_RULE_COLOR]=1 \{\
\m[\\*[$HDRFTR_RULE_COLOR]]\
\D't \\n[#HDRFTR_RULE_WEIGHT]u'\
\h'|0'\
\v'+\\n[#HDRFTR_RULE_WEIGHT_ADJ]u'\
\D'l \\n[#DOC_L_LENGTH]u 0'\
\D't \\n[#RULE_WEIGHT]u'\
\h'-\\n[#RULE_WEIGHT]u'\
\m[]
.          \}
.          el \{\
\D't \\n[#HDRFTR_RULE_WEIGHT]u'\
\h'|0'\
\v'+\\n[#HDRFTR_RULE_WEIGHT_ADJ]u'\
\D'l \\n[#DOC_L_LENGTH]u 0'\
\D't \\n[#RULE_WEIGHT]u'\
\h'-\\n[#RULE_WEIGHT]u'
.          \}
.          br
.       \}
.       el \{\
.          if \\n[#PRINT_STYLE]=1 .nr #CAP_HEIGHT_ADJUST \\n[#CAP_HEIGHT]
.          if \\n[#PRINT_STYLE]=2 \{\
.             ie \\n[#LEFT_CAP_HEIGHT]>\\n[#CENTER_CAP_HEIGHT] \
.                nr #CAP_HEIGHT_ADJUST \\n[#LEFT_CAP_HEIGHT]
.             el .nr #CAP_HEIGHT_ADJUST \\n[#CENTER_CAP_HEIGHT]
.             ie \\n[#CAP_HEIGHT_ADJUST]>\\n[#RIGHT_CAP_HEIGHT] \
.                nr #CAP_HEIGHT_ADJUST \\n[#CAP_HEIGHT_ADJUST]
.             el .nr #CAP_HEIGHT_ADJUST \\n[#RIGHT_CAP_HEIGHT]
.          \}
.          if \\n[#HEADERS_ON] \{\
.             rt \\n[y]u
.             ALD \\n[#HDRFTR_RULE_GAP]u
.             nr #HDRFTR_RULE_WEIGHT \\n[#HEADER_RULE_WEIGHT]
.             nr #HDRFTR_RULE_WEIGHT_ADJ \\n[#HEADER_RULE_WEIGHT_ADJ]
.          \}
.          if \\n[#FOOTERS_ON] \{\
.             rt \\n[y]u
.             RLD \
\\n[#HDRFTR_RULE_GAP]u+\\n[#CAP_HEIGHT_ADJUST]u+\\n[#FOOTER_RULE_WEIGHT]u
.             nr #HDRFTR_RULE_WEIGHT \\n[#FOOTER_RULE_WEIGHT]
.             nr #HDRFTR_RULE_WEIGHT_ADJ \\n[#FOOTER_RULE_WEIGHT_ADJ]
.          \}
.          ie \\n[#HDRFTR_RULE_COLOR]=1 \{\
\m[\\*[$HDRFTR_RULE_COLOR]]\
\D't \\n[#HDRFTR_RULE_WEIGHT]u'\
\h'|0'\
\v'+\\n[#HDRFTR_RULE_WEIGHT_ADJ]u'\
\D'l \\n[#DOC_L_LENGTH]u 0'\
\D't \\n[#RULE_WEIGHT]u'\
\h'-\\n[#RULE_WEIGHT]u'\
\m[]
.          \}
.          el \{\
\D't \\n[#HDRFTR_RULE_WEIGHT]u'\
\h'|0'\
\v'+\\n[#HDRFTR_RULE_WEIGHT_ADJ]u'\
\D'l \\n[#DOC_L_LENGTH]u 0'\
\D't \\n[#RULE_WEIGHT]u'\
\h'-\\n[#RULE_WEIGHT]u'
.          \}
.          br
.       \}
.    \}
.    if '\\$0'HEADER_RULE' \{\
.       ie '\\$1'' \{\
.          nr #HEADER_RULE 1
.          nr #HDRFTR_RULE 1
.       \}
.       el \{\
.          nr #HEADER_RULE 0
.          nr #HDRFTR_RULE 0
.       \}
.    \}
.    if '\\$0'FOOTER_RULE' \{\
.       ie '\\$1'' \{\
.          nr #FOOTER_RULE 1
.          nr #HDRFTR_RULE 1
.       \}
.       el \{\
.          nr #FOOTER_RULE 0
.          nr #HDRFTR_RULE 0
.       \}
.    \}
.    if '\\$0'HDRFTR_RULE' \{\
.       ie '\\$1'' .nr #HDRFTR_RULE 1
.       el .nr #HDRFTR_RULE 0
.    \}
.END
\#
.ALIAS HDRFTR_RULE_INTERNAL HDRFTR_RULE
\#
\# HDRFTR PLAIN
\# ------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Sets the family, font, and point size of all strings in
\#   header/footers to the same family and point size as running
\#   text.  Font for the header/footer becomes roman throughout.
\#
.MAC HDRFTR_PLAIN END
.    HDRFTR_FAMILY        \\*[$DOC_FAM]
.    HDRFTR_PT_SIZE       \\n[#DOC_PT_SIZE]
.    HDRFTR_LEFT_FAMILY   \\*[$DOC_FAM]
.    HDRFTR_LEFT_FONT     R
.    HDRFTR_LEFT_SIZE     +0
.    HDRFTR_LEFT_CAPS     OFF
.    HDRFTR_CENTER_FAMILY \\*[$DOC_FAM]
.    HDRFTR_CENTER_FONT   R
.    HDRFTR_CENTER_SIZE   +0
.    HDRFTR_CENTER_CAPS   OFF
.    HDRFTR_RIGHT_FAMILY  \\*[$DOC_FAM]
.    HDRFTR_RIGHT_FONT    R
.    HDRFTR_RIGHT_SIZE    +0
.    HDRFTR_RIGHT_CAPS    OFF
.END
\#
\# SWITCH HDRFTR
\# -------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #SWITCH_HDRFTR, used to switch
\#   default location of HDRFTR_LEFT and HDRFTR_RIGHT.
\# *Notes:
\#   Default is OFF.
\#
\# Typically, the author string appears at the left of header/footers,
\# and the title string appears at the right.  This switches the
\# location of the two.  Useful in conjunction with RECTO_VERSO to tweak
\# switches on alternate pages to come out as the user wishes.  The
\# assumption of RECTO_VERSO is that the first page of the document
\# (recto) is odd, and even though it has no header/footer, if it did
\# have one, it would print as AUTHOR...CENTER...TITLE (or whatever
\# strings the user has supplied for HDRFTR_LEFT/RIGHT), meaning that
\# the next page, which does have a header/footer, will come out as
\# TITLE...CENTER...AUTHOR (or whatever strings the user has supplied
\# for HDRFTR_LEFT/RIGHT).  SWITCH_HDRFTRS allows the user to get the
\# desired string in the desired place on the desired recto/verso page.
\#
.MAC SWITCH_HDRFTR END
.    ie '\\$1'' .nr #SWITCH_HDRFTR 1
.    el .nr #SWITCH_HDRFTR 0
.END
\#
\# USER DEFINED HDRFTR RECTO
\# -------------------------
\# *Arguments:
\#   L | LEFT | C | CENTER | CENTER | R | RIGHT <hdrftr_recto_string>
\# *Function:
\#   Toggles #USERDEF_HDRFTR on, stores quad as #USERDEF_HDRFTR_RECTO_QUAD,
\#   stores string in $USERDEF_HDRFTR_RECTO.
\# *Notes:
\#   For use when users don't want 3-part headers/footers, but rather
\#   want to design their own headers/footers and need different
\#   headers/footers on recto and verso pages.  Using just
\#   HEADER_RECTO, even when recto/verso is not on, allows users to
\#   design their own headers/footers for doc pages.
\#
.MAC HDRFTR_RECTO END
.    nr #USERDEF_HDRFTR 1
.    if '\\$1'L'      .nr #USERDEF_HDRFTR_RECTO_QUAD 1
.    if '\\$1'LEFT'   .nr #USERDEF_HDRFTR_RECTO_QUAD 1
.    if '\\$1'C'      .nr #USERDEF_HDRFTR_RECTO_QUAD 2
.    if '\\$1'CENTER' .nr #USERDEF_HDRFTR_RECTO_QUAD 2
.    if '\\$1'CENTRE' .nr #USERDEF_HDRFTR_RECTO_QUAD 2
.    if '\\$1'R'      .nr #USERDEF_HDRFTR_RECTO_QUAD 3
.    if '\\$1'RIGHT'  .nr #USERDEF_HDRFTR_RECTO_QUAD 3
.    shift
.    ie '\\$1'CAPS' \{\
.       nr #HDRFTR_RECTO_CAPS 1
.       ds $USERDEF_HDRFTR_RECTO \\$2
.    \}
.    el .ds $USERDEF_HDRFTR_RECTO \\$1
.END
\#
\# USER DEFINED HDRFTR VERSO
\# -------------------------
\# *Arguments:
\#   L | LEFT | C | CENTER | CENTER | R | RIGHT <hdrftr_verso_string>
\# *Function:
\#   Toggles #USERDEF_HDRFTR on, stores quad as #USERDEF_HDRFTR_VERSO_QUAD,
\#   stores string in $USERDEF_HDRFTR_VERSO.
\# *Notes:
\#   For use when users don't want 3-part headers/footers, but rather
\#   want to design their own headers/footers and need different
\#   headers/footers on recto and verso pages.
\#
.MAC HDRFTR_VERSO END
.    nr #USERDEF_HDRFTR 1
.    if '\\$1'L'      .nr #USERDEF_HDRFTR_VERSO_QUAD 1
.    if '\\$1'LEFT'   .nr #USERDEF_HDRFTR_VERSO_QUAD 1
.    if '\\$1'C'      .nr #USERDEF_HDRFTR_VERSO_QUAD 2
.    if '\\$1'CENTER' .nr #USERDEF_HDRFTR_VERSO_QUAD 2
.    if '\\$1'CENTRE' .nr #USERDEF_HDRFTR_VERSO_QUAD 2
.    if '\\$1'R'      .nr #USERDEF_HDRFTR_VERSO_QUAD 3
.    if '\\$1'RIGHT'  .nr #USERDEF_HDRFTR_VERSO_QUAD 3
.    shift
.    ie '\\$1'CAPS' \{\
.       nr #HDRFTR_VERSO_CAPS 1
.       ds $USERDEF_HDRFTR_VERSO \\$2
.    \}
.    el .ds $USERDEF_HDRFTR_VERSO \\$1
.END
\#
\# PRINT FOOTER ON FIRST PAGE
\# --------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #PRINT_FOOTER_ON_PAGE_1
\# *Notes:
\#   Lets user choose whether to print footer on first
\#   page of doc.
\#
.MAC FOOTER_ON_FIRST_PAGE END
.    ie '\\$1'' .nr #PRINT_FOOTER_ON_PAGE_1 1
.    el .rr #PRINT_FOOTER_ON_PAGE_1
.END
\#
\# PRINT PAGE NUMBER ON FIRST PAGE
\# -------------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #PRINT_PAGENUM_ON_PAGE_1
\# *Notes:
\#   Lets user choose whether to print page number on first
\#   page of doc and after collate when footers are on or page numbering
\#   has been user set at top of page.
\#
.MAC PAGENUM_ON_FIRST_PAGE END
.    ie '\\$1'' .nr #PRINT_PAGENUM_ON_PAGE_1 1
.    el .rr #PRINT_PAGENUM_ON_PAGE_1
.END
\#
\# PRINT HEADER/FOOTER
\# -------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Based on defaults or values entered by user, prints a
\#   three-part title at either the top or the bottom of the page.
\# *Notes:
\#   Called from within either HEADER or FOOTER.
\#
.MAC PRINT_HDRFTR END
.    if \\n[#DOC_TYPE]=4 .nr #SUITE \En[.pn]
.    if \\n[#FOOTERS_ON] \{\
.       if \\n[#START_FOR_FOOTERS] \{\
.          rr #START_FOR_FOOTERS
.          if !\\n[#PRINT_FOOTER_ON_PAGE_1] \{\
.             ie !\\n[#HDRFTR_BOTH] .return
.             el \{\
.                rr #FOOTERS_ON
.                nr #HEADERS_ON 1
.                ie \\n[#HEADER_RULE]=1 .HEADER_RULE
.                el .HEADER_RULE OFF
.                ie \\n[#HDRFTR_BOTH] .HEADER_VERSO \\*[$HDR_VERSO_QUAD] "\\*[$HDR_VERSO_STRING]"
.                el .HEADER_RECTO \\*[$HDR_RECTO_QUAD] "\\*[$HDR_RECTO_STRING]"
.                return
.             \}
.          \}
.       \}
.    \}
.    if \\n[#USERDEF_HDRFTR] \{\
.       PRINT_USERDEF_HDRFTR
.       return
.    \}
.    if \\n[#SWITCH_HDRFTR] \{\
.       ds $HDRFTR_TMP_SWITCH             \\*[$HDRFTR_LEFT]
.       ds $HDRFTR_LEFT                   \\*[$HDRFTR_RIGHT]
.       ds $HDRFTR_RIGHT                  \\*[$HDRFTR_TMP_SWITCH]
.       ds $HDRFTR_TMP_SIZE_CHANGE_SWITCH \\*[$HDRFTR_LEFT_SIZE_CHANGE]
.       ds $HDRFTR_LEFT_SIZE_CHANGE       \\*[$HDRFTR_RIGHT_SIZE_CHANGE]
.       ds $HDRFTR_RIGHT_SIZE_CHANGE      \\*[$HDRFTR_TMP_SIZE_CHANGE_SWITCH]
.       nr #HDRFTR_TMP_CAPS_SWITCH        \\n[#HDRFTR_LEFT_CAPS]
.       nr #HDRFTR_LEFT_CAPS              \\n[#HDRFTR_RIGHT_CAPS]
.       nr #HDRFTR_RIGHT_CAPS             \\n[#HDRFTR_TMP_CAPS_SWITCH]
.       ds $HDRFTR_TMP_COLOR_SWITCH       \\*[$HDRFTR_LEFT_COLOR]
.       ds $HDRFTR_LEFT_COLOR             \\*[$HDRFTR_RIGHT_COLOR]
.       ds $HDRFTR_RIGHT_COLOR            \\*[$HDRFTR_TMP_COLOR_SWITCH]
.       rr #HDRFTR_TMP_CAPS_SWITCH
.       rm $HDRFTR_TMP_SWITCH
.       rm $HDRFTR_TMP_SIZE_CHANGE_SWITCH
.       rm $HDRFTR_TMP_COLOR_SWITCH
.       nr #SWITCH_HDRFTR 0
.    \}
.    nr #PAGENUMBER \\n%+\\n[#PAGE_NUM_ADJ]
.    if \\n[#ENDNOTES] .PAGENUM_STYLE \\*[$EN_PN_STYLE]
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #LEFT_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       if o .RIGHT
.       if e .LEFT
.       if \\n[#RECTO_VERSO]=0    .LEFT
.       if \\n[#HDRFTR_LEFT_CAPS] .CAPS
.       ie '\\*[$HDRFTR_LEFT]'#' .PRINT \\n[#PAGENUMBER]
.       el \{\
.          ie !'\\*[$HDRFTR_LEFT]'' .PRINT \\*[$HDRFTR_LEFT]
.          el .PRINT \&
.       \}
.       if \\n[#HDRFTR_LEFT_CAPS]   .CAPS OFF
.       CENTER
.       if \\n[#HDRFTR_CENTER_CAPS] .CAPS
.       rt \\n[y]u
.       ie '\\*[$HDRFTR_CENTER]'#' .PRINT \
\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\n[#PAGENUMBER]\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'
.       el \{\
.          ie !'\\*[$HDRFTR_CENTER]'' .PRINT \
\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\*[$HDRFTR_CENTER]\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'
.          el .PRINT \&
.       \}
.       if \\n[#HDRFTR_CENTER_CAPS] .CAPS OFF
.       if o .LEFT
.       if e .RIGHT
.       if \\n[#RECTO_VERSO]=0     .RIGHT
.       if \\n[#HDRFTR_RIGHT_CAPS] .CAPS
.       rt \\n[y]u
.       ie '\\*[$HDRFTR_RIGHT]'#' .PRINT \\n[#PAGENUMBER]
.       el \{\
.          ie !'\\*[$HDRFTR_RIGHT]'' .PRINT \\*[$HDRFTR_RIGHT]
.          el .PRINT \&
.       \}
.       if \\n[#HDRFTR_RIGHT_CAPS] .CAPS OFF
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       if \\n[#HDRFTR_COLOR]=1 \{\
.          nf
\m[\\*[$HDRFTR_COLOR]]
.       \}
.       fam \\*[$HDRFTR_LEFT_FAM]
.       ft  \\*[$HDRFTR_LEFT_FT]
.       ps  \\n[#HDRFTR_PT_SIZE]u\\*[$HDRFTR_LEFT_SIZE_CHANGE]
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #LEFT_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       if o .LEFT
.       if e .RIGHT
.       if \\n[#RECTO_VERSO]=0 .LEFT
.       if \\n[#HDRFTR_LEFT_CAPS] .CAPS
.       ie '\\*[$HDRFTR_LEFT]'#' \{\
.          ie \\n[#HDRFTR_LEFT_COLOR]=1 \
.             PRINT \m[\\*[$HDRFTR_LEFT_COLOR]]\\n[#PAGENUMBER]\m[]
.          el \
.             PRINT \\n[#PAGENUMBER]
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_LEFT]'' \{\
.             ie \\n[#HDRFTR_LEFT_COLOR]=1 \
.                PRINT \m[\\*[$HDRFTR_LEFT_COLOR]]\\*[$HDRFTR_LEFT]\m[]
.             el \
.                PRINT \\*[$HDRFTR_LEFT]
.          \}
.          el .nop \&
.       \}
.       if \\n[#HDRFTR_LEFT_CAPS] .CAPS OFF
.       fam     \\*[$HDRFTR_CENTER_FAM]
.       ft      \\*[$HDRFTR_CENTER_FT]
.       ps      \\n[#HDRFTR_PT_SIZE]u\\*[$HDRFTR_CENTER_SIZE_CHANGE]
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #CENTER_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       CENTER
.       if \\n[#HDRFTR_CENTER_CAPS] .CAPS
.       rt \\n[y]u
.       ie '\\*[$HDRFTR_CENTER]'#' \{\
.          ie \\n[#HDRFTR_CENTER_COLOR]=1 .PRINT \
\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\m[\\*[$HDRFTR_CENTER_COLOR]]\
\\n[#PAGENUMBER]\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'\m[]
.          el .PRINT \
\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\n[#PAGENUMBER]\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_CENTER]'' \{\
.             ie \\n[#HDRFTR_CENTER_COLOR]=1 .PRINT \
\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\m[\\*[$HDRFTR_CENTER_COLOR]]\
\\*[$HDRFTR_CENTER]\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'\m[]
.             el .PRINT \
\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\*[$HDRFTR_CENTER]\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'
.          \}
.          el .PRINT \&
.       \}
.       if \\n[#HDRFTR_CENTER_CAPS] .CAPS OFF
.       fam \\*[$HDRFTR_RIGHT_FAM]
.       ft  \\*[$HDRFTR_RIGHT_FT]
.       ps  \\n[#HDRFTR_PT_SIZE]u\\*[$HDRFTR_RIGHT_SIZE_CHANGE]
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #RIGHT_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       if o .RIGHT
.       if e .LEFT
.       if \\n[#RECTO_VERSO]=0 .RIGHT
.       if \\n[#HDRFTR_RIGHT_CAPS] .CAPS
.       rt \\n[y]u
.       ie '\\*[$HDRFTR_RIGHT]'#' \{\
.          ie \\n[#HDRFTR_RIGHT_COLOR]=1 \
.             PRINT \m[\\*[$HDRFTR_RIGHT_COLOR]]\\n[#PAGENUMBER]\m[]
.          el \
.             PRINT \\n[#PAGENUMBER]
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_RIGHT]'' \{\
.             ie \\n[#HDRFTR_RIGHT_COLOR]=1 \
.                PRINT \m[\\*[$HDRFTR_RIGHT_COLOR]]\\*[$HDRFTR_RIGHT]\m[]
.             el \
.                PRINT \\*[$HDRFTR_RIGHT]
.          \}
.          el .PRINT \&
.       \}
.       if \\n[#HDRFTR_RIGHT_CAPS] .CAPS OFF
.    \}
.    if \\n[#HDRFTR_RULE] .HDRFTR_RULE_INTERNAL
.    br
.END
\#
\# PRINT USER DEFINED HEADER/FOOTER
\# --------------------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Based on defaults or values entered by user, prints a single part
\#   (i.e. not 3-part) title at either the top or the bottom of the page.
\# *Notes:
\#   Called from within PRINT_HDRFTR.
\#
.MAC PRINT_USERDEF_HDRFTR END
.    nr #PAGENUMBER \\n%+\\n[#PAGE_NUM_ADJ]
.    fc ^ #
.    if \\n[#PRINT_STYLE]=2 \{\
.       fam \\*[$HDRFTR_FAM]
.       ft  R
.       ps \\n[#HDRFTR_PT_SIZE]u
.       if \\n[#HDRFTR_COLOR]=1 \{\
.          nf
.          COLOR \\*[$HDRFTR_COLOR]
.       \}
.    \}
.    ie \\n[#RECTO_VERSO] \{\
.       if o \{\
.          if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=1 .LEFT
.          if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=2 .CENTER
.          if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=3 .RIGHT
.          if \\n[#HDRFTR_RECTO_CAPS]=1 .CAPS
.          if '\\n[.ev]'FOOTER' .vs 0
.          PRINT \\*[$USERDEF_HDRFTR_RECTO]
.          if '\\n[.ev]'FOOTER' .vs
.          if \\n[#HDRFTR_RECTO_CAPS]=1 .CAPS OFF
.          EOL
.          if \\n[#FOOTERS_ON] \{\
.             di NULL
.             SIZESPECS
.             nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.             di
.          \}
.       \}
.       if e \{\
.          ie !'\\*[$USERDEF_HDRFTR_VERSO]'' \{\
.             if \\n[#USERDEF_HDRFTR_VERSO_QUAD]=1 .LEFT
.             if \\n[#USERDEF_HDRFTR_VERSO_QUAD]=2 .CENTER
.             if \\n[#USERDEF_HDRFTR_VERSO_QUAD]=3 .RIGHT
.             if \\n[#HDRFTR_VERSO_CAPS]=1 .CAPS
.             if '\\n[.ev]'FOOTER' .vs 0
.             PRINT \\*[$USERDEF_HDRFTR_VERSO]
.             if '\\n[.ev]'FOOTER' .vs
.             if \\n[#HDRFTR_VERSO_CAPS]=1 .CAPS OFF
.             EOL
.             if \\n[#FOOTERS_ON] \{\
.                di NULL
.                SIZESPECS
.                nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.                di
.             \}
.          \}
.          el \{\
.             if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=1 .LEFT
.             if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=2 .CENTER
.             if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=3 .RIGHT
.             if \\n[#HDRFTR_RECTO_CAPS]=1 .CAPS
.             if '\\n[.ev]'FOOTER' .vs 0
.             PRINT \\*[$USERDEF_HDRFTR_RECTO]
.             if '\\n[.ev]'FOOTER' .vs
.             if \\n[#HDRFTR_RECTO_CAPS]=1 .CAPS OFF
.             EOL
.             if \\n[#FOOTERS_ON] \{\
.                di NULL
.                SIZESPECS
.                nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.                di
.             \}
.          \}
.       \}
.    \}
.    el \{\
.       if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=1 .LEFT
.       if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=2 .CENTER
.       if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=3 .RIGHT
.       if \\n[#HDRFTR_RECTO_CAPS]=1 .CAPS
.       if '\\n[.ev]'FOOTER' .vs 0
.       PRINT \\*[$USERDEF_HDRFTR_RECTO]
.       if '\\n[.ev]'FOOTER' .vs
.       if \\n[#HDRFTR_RECTO_CAPS]=1 .CAPS OFF
.       EOL
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.    \}
.    fc
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#HDRFTR_COLOR]=1 \m[\\*[$HDRFTR_COLOR]]
.       el \m[black]
.    \}
.    if \\n[#HDRFTR_RULE] \{\
.       HDRFTR_RULE_INTERNAL
.    \}
.END
\#
\# +++HEADERS+++
\#
\# HEADERS (off or on)
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns headers at the top of the page off or on.
\# *Notes:
\#   Default is on.
\#
.MAC HEADERS END
.    ie '\\$1'' .nr #HEADERS_ON 1
.    el .nr #HEADERS_ON 0
.END
\#
\# HEADER MARGIN
\# -------------
\# *Argument:
\#   <amount of space between top of page and header>
\# *Function:
\#   Creates or modifies register #HEADER_MARGIN to hold amount
\#   of space between top of page and header.
\# *Notes:
\#   Requires unit of measure.  Default is 4P+6p, measured top-of-page
\#   to baseline.
\#
.MAC HEADER_MARGIN END
.    nr #HEADER_MARGIN (\\$1)
.END
\#
\# HEADER GAP
\# ----------
\# *Argument:
\#   <amount of space between header and running text>
\# *Function:
\#   Creates or modifies register #HEADER_GAP to hold amount
\#   of space between header and running text.
\# *Notes:
\#   Default is 1P+6p.
\#
.MAC HEADER_GAP END
.    nr #HEADER_GAP (\\$1)
.END
\#
\# HEADER
\# ------
\# *Arguments:
\#   <none>
\# *Function:
\#   Prints header appropriate to DOC_TYPE, PRINTSTYLE, and COPYSTYLE.
\# *Notes:
\#   In order to convert the title string to caps in the header
\#   (in the event that the user enters .TITLE in caps/lc), I've
\#   used quad left, quad centre, and quad right to arrange the
\#   three bits of the header, rather than .tl.  This allows the
\#   use of the CAPS macro.  The downside is that I have to add
\#   \\v'-(\\n[#LEAD]u*<n>) in order for -Tlatin1 output to align
\#   the header/footer strings on the baseline.  The console output
\#   still isn't brilliant, but at least it's comprehensible.
\#
.MAC HEADER END
.    vpt 0
.    if \\n[#NEW_DOC_PT_SIZE] .nr #DOC_PT_SIZE \\n[#NEW_DOC_PT_SIZE]
.    rr #NEW_DOC_PT_SIZE
.    if \\n[#RESET_TRAPS] \{\
.       TRAPS
.       if \\n[#REMOVE_ADJ] .nr #DOC_LEAD -\\n[#DOC_LEAD_ADJ]
.    \}
.    rr #REMOVE_ADJ
.    rr #RESET_TRAPS
.    MNtop
.    rr #FROM_FOOTER
.    nr #FROM_HEADER 1
.    nr #LAST_FN_COUNT_FOR_COLS \\n[#FN_COUNT_FOR_COLS]
.    if \\n[#FN_DEPTH] .PROCESS_FN_LEFTOVER
.    rr #RULED
.    if \\n[#RESET_FN_NUMBER] .nr #FN_NUMBER 0 1
.    po \\n[#DOC_L_MARGIN]u
.    if \\n[#RECTO_VERSO] \{\
.          nr #DOC_LR_MARGIN_TMP \\n[#DOC_L_MARGIN]
.          DOC_LEFT_MARGIN  \\n[#DOC_R_MARGIN]u
.          if \\n[#CROPS] .DOC_LEFT_MARGIN  \\n[#DOC_R_MARGIN]u+\\n[cropmarks]u
.          DOC_RIGHT_MARGIN \\n[#DOC_LR_MARGIN_TMP]u
.          if \\n[#CROPS] .DOC_RIGHT_MARGIN \\n[#DOC_LR_MARGIN_TMP]u-\\n[cropmarks]u
.          SWITCH_HDRFTR_CENTER_PAD
.       \}
.    \}
.    ev HEADER
.    if \\n[#PAGE_NUM_V_POS]=1 .vs 0
.    sp |\\n[#HEADER_MARGIN]u-1v
.    mk y
.    ll \\n[#DOC_L_LENGTH]u
.    ta \\n[.l]u
.    if \\n[#PRINT_STYLE]=1 \{\
.       fam \\*[$TYPEWRITER_FAM]
.       ft  R
.       ps  \\*[$TYPEWRITER_PS]\\*[$HDRFTR_SIZE_CHANGE]
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.      fam \\*[$HDRFTR_FAM]
.      ft  R
.      ps  \\n[#DOC_PT_SIZE]u\\*[$HDRFTR_SIZE_CHANGE]
.    \}
.    nr #HDRFTR_PT_SIZE \\n[#PT_SIZE]
.    if \\n[#CAPS_ON] \{\
.       nr #CAPS_WAS_ON 1
.       CAPS OFF
.    \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#ENDNOTES]=1 \{\
.\" Single-spaced endotes have a different lead
.          if \\n[#EN_SINGLESPACE] \{\
.             nr #RESTORE_DOC_LEAD \\n[#DOC_LEAD]
.             nr #DOC_LEAD \\n[#EN_LEAD]u
.          \}
.       \}
.    \}
.    if !n .nop \X'ps: exec 0 setlinejoin'\X'ps: exec 0 setlinecap'
.    sp -1v
.    ie \\n[#HEADERS_ON] .PRINT_HDRFTR
.    el \{\
.       if \\n[#PAGE_NUM_V_POS]=1 \{\
.          if \\n[#PAGINATE] .PRINT_PAGE_NUMBER
.       \}
.    \}
.    sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#ENDNOTES]=1 \{\
.          if \\n[#EN_SINGLESPACE] \{\
.             nr #DOC_LEAD \\n[#RESTORE_DOC_LEAD]u
.             rr #RESTORE_DOC_LEAD
.          \}
.       \}
.    \}
.    nr #PAGE_TOP \\n[nl]
.    ev
.    po \\n[#L_MARGIN]u
.    if \\n[#RECTO_VERSO] .nr #L_MARGIN +\\n[#L_MARGIN_DIFF]
.    if \\n[#CAPS_WAS_ON] \{\
.       CAPS
.       rr #CAPS_WAS_ON
.    \}
.    if \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.    if \\n[#QUOTE] \{\
.       ie \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.       el \{\
.          ie \\n[#Q_OFFSET_VALUE] .nr #Q_OFFSET \
\\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.          el .nr #Q_OFFSET \\n[#L_MARGIN]+\\*[$Q_OFFSET_VALUE]
.          po \\n[#Q_OFFSET]u
.       \}
.       if \\n[#PRINT_STYLE]=2 .sp \\n[#Q_LEAD_DIFF]u
.    \}
.    if \\n[#EPIGRAPH] \{\
.       ie \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.       el \{\
.          ie r#EPI_OFFSET_VALUE \
.             nr #EPI_OFFSET \
\\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.          el \
.             nr #EPI_OFFSET \\n[#L_MARGIN]+\\*[$EPI_OFFSET_VALUE]
.          po \\n[#EPI_OFFSET]u
.       \}
.    \}
.    ie \\n[#EPIGRAPH] \{\
.       ie !\\n[#EPI_ACTIVE] \{\
.          ns
.          rr #EPI_ACTIVE
.       \}
.       el \{\
.          ie \\n[#EPI_FITS] .ns
.          el .sp \\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u
.       \}
.    \}
.    el .ns
.    if \\n[#COLUMNS] \{\
.       nr #FN_COUNT_FOR_COLS 0 1
.       nr #L_MARGIN \\n[#DOC_L_MARGIN]
.       if \\n[#RECTO_VERSO] .COLUMNS \\n[#NUM_COLS] \\n[#GUTTER]u
.       nr #COL_NUM 0 1
.       mk dc
.       po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.       nr #L_MARGIN \\n[.o]
.       if \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.       ll \\n[#COL_L_LENGTH]u
.       ta \\n[.l]u
.       if \\n[#QUOTE] \{\
.          ie \\n[#Q_OFFSET_VALUE] \
.             po +(\\n[#PP_INDENT]u*\\n[#Q_OFFSET_VALUE]u)
.          el \
.             po +\\*[$Q_OFFSET_VALUE]
.       \}
.       if \\n[#EPIGRAPH] \{\
.          if \\n[#EPI_ACTIVE] \{\
.             ie \\n[#EPI_FITS] .
.             el .nr dc -\\n[#EPI_LEAD_DIFF]
.          \}
.          ie r#EPI_OFFSET_VALUE \{\
.             po \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]u+(\\n[#PP_INDENT]u*\\n[#EPI_OFFSET_VALUE]u)
.          \}
.          el .po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u+\\*[$EPI_OFFSET_VALUE]
.       \}
.    \}
.    if \\n[#RESET_FN_COUNTERS]=1 \{\
.       rr #RESET_FN_COUNTERS
.       PROCESS_FN_IN_DIVER
.       nr #FN_COUNT \\n[#SAVED_FN_COUNT] 1
.       if \\n[#COLUMNS]=1 .nr #FN_COUNT_FOR_COLS \\n[#SAVED_FN_COUNT_FOR_COLS] 1
.       ie \\n[#RESET_FN_NUMBER]=1 .nr #FN_NUMBER \\n[#SAVED_FN_NUMBER] 1
.       el .nr #FN_NUMBER \\n[#FN_NUMBER] 1
.       rm FN_IN_DIVER
.       if dRUNON_FN_IN_DIVER .rm RUNON_FN_IN_DIVER
.    \}
.    rr #FROM_HEADER
.    rr #DEFER_SPACE_ADDED
.    if !\\n[#FN_DEPTH] .if r #DIVERTED .rr #DIVERTED
.    if \\n[#MN_OVERFLOW_LEFT]=1 \{\
.       MN LEFT
.       nf
.       MN_OVERFLOW_LEFT
.       MN
.    \}
.    if \\n[#MN_OVERFLOW_RIGHT]=1 \{\
.       MN RIGHT
.       nf
.       MN_OVERFLOW_RIGHT
.       MN
.    \}
.    rm MN_OVERFLOW_LEFT
.    rr #MN_OVERFLOW_LEFT
.    rr #no-repeat-MN-left
.    rm MN_OVERFLOW_RIGHT
.    rr #MN_OVERFLOW_RIGHT
.    rr #no-repeat-MN-right
.    if \\n[#PRE_COLLATE]=1 .rr #PRE_COLLATE
.    if \\n[#UNDERLINE_WAS_ON]=1 \{\
.       vs 0
.       ie !n \
.          nop \R'#UNDERLINE_ON 1'\X'ps: exec \\n[_w] \\n[_d] decorline'
.       el .ul 1000
.       br
.       ns
.       rr #UNDERLINE_WAS_ON
.    \}
.    if \\n[#RESTORE_PAGINATION] \{\
.       PAGINATE
.       rr #RESTORE_PAGINATION
.    \}
.    ch RR_@TOP
.    ie \\n[tbl*have-header] .rr @TOP
.    el .wh \\n[nl]u+1u RR_@TOP
.    ie \\n[defer] .PROCESS_FLOATS
.    el \{\
.       if \\n[tbl*have-caption] \{\
.          RESTORE_SPACE
.          ie \\n[#MLA] .sp \n[tbl*label-lead-diff]u
.          el .sp \n[tbl*caption-lead-diff]u
.       \}
.    \}
.\" So tables without TH that don't fit don't overprint first row
.\" at top of page
.    ie \\n[tbl*no-header] \{\
.       rs
.       nop \&
.       vpt
.       rr \\n[tbl*no-header]
.       SHIM
.    \}
.    el .vpt
.    if \\n[#NEWPAGE] .rr #NEWPAGE
.    ie \\n[tbl*interrupted] \{\
.       tbl*print-header
.       rr tbl*interrupted
.      \}
.    el .tbl@top-hook
.END
\#
\# ====================================================================
\#
\# +++FOOTERS+++
\#
\# FOOTERS (off or on)
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns footers at the bottom of the page off or on.
\# *Notes:
\#   Default is off.  If on, page numbers automatically go at
\#   the top, centered, unless pagination has been turned off,
\#   or the pagenumber position has been changed to left or right.
\#
.MAC FOOTERS END
.    ie '\\$1'' \{\
.       rr #HEADERS_ON
.       nr #FOOTERS_ON 1
.       PAGENUM_POS TOP CENTER
.    \}
.    el .nr #FOOTERS_ON 0
.END
\#
\# FOOTER MARGIN
\# -------------
\# *Argument:
\#   <footer margin>
\# *Function:
\#   Creates or modifies register #FOOTER_MARGIN which holds the
\#   amount of space to leave between the page number and the bottom
\#   of the page.
\# *Notes:
\#   Unit of measure required.  Default is 3P.
\#
.MAC FOOTER_MARGIN END
.    ie \\n%>0 .nr #FOOTER_MARGIN (\\$1)
.    el .
.END
\#
\# FOOTER GAP
\# ----------
\# *Argument:
\#   <distance from end of running text to page # or footer>
\# *Function:
\#   Creates or modifies register #FOOTER_GAP which holds the
\#   amount of space to leave between running text and the page number.
\# *Notes:
\#   Requires unit of measure.  Default is 3P.  Measured baseline to
\#   baseline.
\#
.MAC FOOTER_GAP END
.    ie \\n%>0 .nr #FOOTER_GAP (\\$1)
.    el .
.END
\#
\# FOOTER
\# ------
\# *Arguments:
\#   <none>
\# *Function:
\#   Places footer at bottom of page if #FOOTERS=1, otherwise
\#   places page number at bottom of page (if #PAGINATE=1).
\#   Page numbers are in arabic or roman according to COPYSTYLE.
\#   DRAFT starts the document at page 1 regardless of PAGENUMBER.
\#   FINAL respects PAGENUMBER.
\#
.MAC FOOTER END
.    vpt 0
.    rr #LB_4_HD
.    rr #QUOTE_4_HD
.    nr #SAVED_LEAD \\n[.v]
.    ev PAGE_TRANSITION
.    pdfmarksuspend
.    ie !n .nop \X'ps: exec decornone'
.    el .ul 0
.    br
.    if \\n[#UNDERLINE_ON]=1 .nr #UNDERLINE_WAS_ON 1
.    if \\n[MN-left]>0 \{\
.       if !\\n[#no-repeat-MN-left]=1 \{\
.          MNbottom-left
.          nr #no-repeat-MN-left 1
.       \}
.       if '\\n[.z]'MN_OVERFLOW_LEFT' \{\
.          di
.          nr #MN_OVERFLOW_LEFT 1
.          rr #OVERFLOW_LEFT
.       \}
.    \}
.    if \\n[MN-right]>0 \{\
.       if (\\n[MN-right] > 0) \
.          if !\\n[#no-repeat-MN-right]=1 .MNbottom-right
.       if '\\n[.z]'MN_OVERFLOW_RIGHT' \{\
.          di
.          nr #MN_OVERFLOW_RIGHT 1
.          rr #OVERFLOW_RIGHT
.       \}
.    \}
\# Table bottom hook, draws the table borders in
\# multipage boxed tables.
.    tbl@bottom-hook
.    ch MN_OVERFLOW_TRAP
.    nr #L_MARGIN_DIFF \\n[#L_MARGIN]-\\n[#DOC_L_MARGIN]
.    if !\\n[#FN_DEFER] \{\
.       nr #DIVER_DEPTH 0
.       if \\n[#FN_DEPTH] \{\
.          if \\n[#DIVERTED]=3 .nr #FN_DEPTH +\\n[#VFP_DIFF]
.          vpt 0
.          sp \
|\\n[#PAGE_LENGTH]u-(\\n[#B_MARGIN]u+\\n[#FN_DEPTH]u-\\n[#DOC_LEAD]u)
.          vpt 1
.          po \\n[#DOC_L_MARGIN]u
.          if \\n[#COLUMNS] \{\
.             po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.             nr #L_MARGIN \\n[.o]
.             nr #FROM_FOOTER 1
.          \}
.          nf
.          FOOTNOTES
.          rm FOOTNOTES
.          if d RUNON_FOOTNOTES    .rm RUNON_FOOTNOTES
.          if \\n[#PRINT_STYLE]=1 .vs \\n[#SAVED_LEAD]u
.          if \\n[#PRINT_STYLE]=2 .LS \\n[#SAVED_LEAD]u
.          if '\\n[.z]'FN_OVERFLOW' \{\
.              di
.              nr #FN_OVERFLOW_DEPTH \\n[#DIVER_DEPTH]
.          \}
.          nr #FN_COUNT_AT_FOOTER \\n[#FN_COUNT]
.          nr #FN_COUNT 0
.          if \\n[#COL_NEXT] \{\
.             ie !\\n[#COL_NUM]=\\n[#NUM_COLS] .nr #COL_NUM \\n-[#COL_NUM]
.             el .nr #COL_NUM \\n[#NUM_COLS] 1
.          \}
.       \}
.       rr #DIVERTED
.    \}
.    nr @TOP 1
.    ie \\n[#COLUMNS]=1 \{\
.       ie \\n[#COL_NUM]=\\n[#NUM_COLS] .DO_FOOTER
.       el \{\
.          ie (\\n[#ENDNOTES]=1):(\\n[#BIBLIOGRAPHY]=1) \{\
.             if \\n[#ENDNOTES] .sp |\\n[ec]u-\\n[#EN_LEAD]u
.             if \\n[#BIBLIOGRAPHY] .sp |\\n[bc]u-\\n[#BIB_LEAD]u
.          \}
.          el \{\
.            vs \\n[#SAVED_LEAD]u
.            sp |\\n[dc]u
.          \}
.          po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n[.o]
.          if \\n[#FN_DEPTH] .PROCESS_FN_LEFTOVER
.          vs \\n[#SAVED_LEAD]u
.          if \\n[#PREV_FN_DEFERRED] .nr #PREV_FN_DEFERRED 2
.          rr #RULED
.          if !\\n[#EPIGRAPH] .rr #COL_NEXT
.          if !\\n[#QUOTE] .rr #COL_NEXT
.          if \\n[#RESET_FN_COUNTERS]=1 \{\
.             rr #RESET_FN_COUNTERS
.             PROCESS_FN_IN_DIVER
.             LS \\n[#SAVED_LEAD]u
.             nr #FN_COUNT \\n[#FN_COUNT] 1
.             nr #FN_COUNT_FOR_COLS \\n[#FN_COUNT_FOR_COLS] 1
.             rm FN_IN_DIVER
.             if dRUNON_FN_IN_DIVER .rm RUNON_FN_IN_DIVER
.          \}
.          rr #DEFER_SPACE_ADDED
.          if \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.          if \\n[#QUOTE] \{\
.             ie \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.             el \{\
.                ie \\n[#Q_OFFSET_VALUE] \
.                   nr #Q_OFFSET \
\\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.                el \
.                   nr #Q_OFFSET \\n[#L_MARGIN]+\\*[$Q_OFFSET_VALUE]
.                if \\n[#COLUMNS] \{\
.                   ie \\n[#Q_OFFSET_VALUE] .nr #Q_OFFSET \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.                   el .nr #Q_OFFSET \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]+\\*[$Q_OFFSET_VALUE]
.                \}
.                po \\n[#Q_OFFSET]u
.             \}
.          \}
.          if \\n[#EPIGRAPH] \{\
.             ie \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.             el \{\
.                ie r#EPI_OFFSET_VALUE .nr #EPI_OFFSET \
\\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.                el .nr #EPI_OFFSET \
\\n[#L_MARGIN]+\\*[$EPI_OFFSET_VALUE]
.                if \\n[#COLUMNS] \{\
.                   ie r#EPI_OFFSET_VALUE .nr #EPI_OFFSET \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.                   el .nr #EPI_OFFSET \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]+\\*[$EPI_OFFSET_VALUE]
.                \}
.                po \\n[#EPI_OFFSET]u
.             \}
.          \}
.          ie \\n[#EPIGRAPH] \{\
.             ie !\\n[#EPI_ACTIVE] \{\
.                ns
.                rr #EPI_ACTIVE
.             \}
.             el \{\
.                sp |\\n[dc]u+(\\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u)
.                rr #EPI_ACTIVE
.             \}
.          \}
.          el .ns
.          ev
.       \}
.       ns
.       rr #DIVERTED
.       ch RR_@TOP
.       wh \\n[nl]u+1u RR_@TOP
.       if \\n[tbl*have-header] .tbl@bottom-hook
.       if \\n[defer] .PROCESS_FLOATS
.       ie \\n[tbl*no-header] \{\
.          rs
.          nop \&
.          vpt
.          rr \\n[tbl*no-header]
.          SHIM
.       \}
.       el .vpt
.       if \\n[tbl*interrupted] .tbl*print-header
.       rr tbl*interrupted
.    \}
.    el .DO_FOOTER
.    pdfmarkrestart
.END
\#
\# PROCESS FOOTER
\# --------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Prints footer (page number, or 3-part footer).
\#   Resets CAPS and UNDERLINE if they were on.
\#
.MAC DO_FOOTER END
.\" Part of workaround for refer spitting out a blank page if the
.\" last reference falls on the bottom line.
.    if \\n[num*refs] \{\
.       if \\n[ref*num]=\\n[num*refs] \{\
.          rr num*refs
.          nr ref*last 1
.       \}
.    \}
.    PRINT_FOOTER
.    if !\\n[ref*last] \{\
.       ie \\n[defer]>0 \{\
\c
'       bp
.       \}
.       el 'bp
.    \}
.    if !'\\n[.ev]'0' .ev
.    rr ref*last
.    po \" Ensure reset to last value
.END
\#
.MAC PRINT_FOOTER END
.   br
.\" Have to change position of FN_OVERFLOW_TRAP or it screws up the
.\" placement of page numbers (or footers).  It's reset to its original
.\" position at the end of the macro.
.    if r #SAVED_FOOTER_POS .ch FOOTER \\n[#SAVED_FOOTER_POS]u
.    rr #SAVED_FOOTER_POS
.    ie (\\n[#FOOTER_MARGIN]+\\n[.v]>\\n[#B_MARGIN]) .nr #SKIP_FOOTER 1
.    el \{\
.       ev FOOTER
.       vpt 0
.       ie n \
.          sp |\\n[#PAGE_LENGTH]u-\\n[#FOOTER_MARGIN]u
.       el \
.          sp |\\n[#PAGE_LENGTH]u-\\n[#FOOTER_MARGIN]u-\\n[#FOOTER_ADJ]u
.       mk y
.    \}
.    UNDERLINE OFF
.    po \\n[#DOC_L_MARGIN]u
.    ll \\n[#DOC_L_LENGTH]u
.    ta \\n[.l]u
.    if \\n[#PRINT_STYLE]=1 .TYPEWRITER
.    if \\n[#PRINT_STYLE]=2 \{\
.       fam  \\*[$HDRFTR_FAM]
.       ft      R
.       ps \\n[#DOC_PT_SIZE]u\\*[$HDRFTR_SIZE_CHANGE]
.    \}
.    nr #HDRFTR_PT_SIZE \\n[#PT_SIZE]
.    if \\n[#CAPS_ON] \{\
.       nr #CAPS_WAS_ON 1
.       CAPS OFF
.    \}
.    ie \\n[#FOOTERS_ON] \{\
.       if !\\n[#SKIP_FOOTER]=1 .PRINT_HDRFTR
.    \}
.    el \{\
.       if \\n[#PAGINATE] \{\
.          if \\n[#PAGE_NUM_V_POS]=2 \
.             if !\\n[#SKIP_FOOTER]=1 .PRINT_PAGE_NUMBER
.       \}
.    \}
.    rr #SKIP_FOOTER
.    if \\n[#CAPS_WAS_ON] \{\
.       CAPS
.       rr #CAPS_WAS_ON
.    \}
.    ev
.    vpt 1
.END
\#
\# ====================================================================
\#
\# +++HEADERS AND FOOTERS+++
\#
\# HEADERS_AND_FOOTERS
\# -------------------
\# *Arguments:
\#   HEADER_RECTO_QUAD \
\#   HEADER_RECTO_STRING \
\#   FOOTER_RECTO_QUAD \
\#   FOOTER_RECTO_STRING \
\#   HEADER_VERSO_QUAD \
\#   HEADER_VERSO_STRING \
\#   FOOTER_VERSO_QUAD \
\#   FOOTER_VERSO_STRING
\#   | <anything>
\# *Function:
\#   Allows having both headers and footers.  Sets register
\#   #HDRFTR_BOTH to 1; collects HEADER/FOOTER_RECTO/VERSO
\#   information; appends FOOTER_RECTO and FOOTER_VERSO to
\#   START and turns off pagination; appends to macros
\#   PRINT_USERDEF_HDRFTR and HEADER the necessary number
\#   register manipulations and redefinitions of the
\#   HEADER/FOOTER_RECTO/VERSO strings so that both
\#   headers and footers get printed, with the appropriate
\#   strings for each
\# *Notes:
\#   Works in conjunction with HDRFTR_RECTO and HDRFTR_VERSO (qqv.),
\#   ergo all style changes must be done inline in the strings
\#   passed as arguments.
\#
.MAC HEADERS_AND_FOOTERS END
.    ie \\n[#NUM_ARGS]>1 \{\
.    nr #HDRFTR_BOTH 1
.    nr #FOOTERS_ON  1
.    if !r#HEADER_RULE .nr #HEADER_RULE 1
.    if !r#FOOTER_RULE .nr #FOOTER_RULE 1
.    ds $HDR_RECTO_QUAD   \\$1
.    ds $HDR_RECTO_STRING \\$2
.    ds $FTR_RECTO_QUAD   \\$3
.    ds $FTR_RECTO_STRING \\$4
.    ds $HDR_VERSO_QUAD   \\$5
.    ds $HDR_VERSO_STRING \\$6
.    ds $FTR_VERSO_QUAD   \\$7
.    ds $FTR_VERSO_STRING \\$8
.am START DONE
.   if \\\\n[#HDRFTR_BOTH]=1 \{\
.      FOOTER_RECTO \\*[$FTR_RECTO_QUAD] "\\*[$FTR_RECTO_STRING]"
.      FOOTER_VERSO \\*[$FTR_VERSO_QUAD] "\\*[$FTR_VERSO_STRING]"
.      if \\\\n[#HEADER_RULE]=1 .HEADER_RULE
.      ie \\\\n[#FOOTER_RULE]=1 .FOOTER_RULE
.      el .FOOTER_RULE OFF
.      if r #PAGINATE .rr #PAGINATE
.      if r #PAGE_NUM_V_POS .rr #PAGE_NUM_V_POS
.   \}
.DONE
.am PRINT_USERDEF_HDRFTR DONE
.   if \\\\n[#HDRFTR_BOTH]=1 \{\
.      if \\n[#FOOTERS_ON]=1 \{\
.         if !\\\\n[#COLLATE]=1 \{\
.            HEADER_RECTO \\*[$HDR_RECTO_QUAD] "\\*[$HDR_RECTO_STRING]"
.            HEADER_VERSO \\*[$HDR_VERSO_QUAD] "\\*[$HDR_VERSO_STRING]"
.            rr #FOOTERS_ON
.            nr #HEADERS_ON 1
.            ie \\\\n[#HEADER_RULE]=1 .HEADER_RULE
.            el .HEADER_RULE OFF
.         \}
.      \}
.      if \\n[#HEADERS_ON]=1 \{\
.         FOOTER_RECTO \\*[$FTR_RECTO_QUAD] "\\*[$FTR_RECTO_STRING]"
.         FOOTER_VERSO \\*[$FTR_VERSO_QUAD] "\\*[$FTR_VERSO_STRING]"
.      \}
.   \}
.DONE
.am HEADER DONE
.   if \\\\n[#HDRFTR_BOTH]=1 \{\
.      if r #START_FOR_FOOTERS .rr #START_FOR_FOOTERS
.      rr #HEADERS_ON
.      nr #FOOTERS_ON 1
.      FOOTER_RECTO \\*[$FTR_RECTO_QUAD] "\\*[$FTR_RECTO_STRING]"
.      FOOTER_VERSO \\*[$FTR_VERSO_QUAD] "\\*[$FTR_VERSO_STRING]"
.      ie \\\\n[#FOOTER_RULE]=1 .FOOTER_RULE
.      el .FOOTER_RULE OFF
.   \}
.DONE
.    \}
.    el \{\
.       rr #HDRFTR_BOTH
.       rr #USERDEF_HDRFTR
.       rm $USERDEF_HDRFTR_RECTO
.       rm $USERDEF_HDRFTR_VERSO
.       FOOTERS OFF
.       HEADERS
.       if \\n[#COLLATE]=1 \{\
.          nr #HEADER_STATE 1
.          nr #PAGINATION_STATE 1
.       \}
.       PAGINATE
.       PAGENUM_POS BOTTOM CENTER
.       nr #HF_OFF 1
.    \}
.END
\#
\# ====================================================================
\#
\# +++HEADS+++
\#
.char \[hd-num-spacer]     \0
.char \[parahead-spacer]   \~\~
.char \[toc-hd-num-spacer] \h'\w'\[en]'u'
.ds toc-word-space \ \" ie an unbreakable space
\#
\# HEADING
\# -------
\# *Arguments:
\#   <heading level> [PARAHEAD] [NAMED <pdf-id>] <heading text>
\# *Function:
\#   Assigns a heading level to the heading text and prints heading
\#   in the style set up for that level.  If PARAHEAD given, the
\#   heading is attached to the body of the paragraph.  If NAMED
\#   given, creates a target for pdf links.  Collects the heading
\#   for the TOC and sets TOC indenting appropriate for the level.
\# *Notes:
\#   If PARAHEAD given, HEADING must come after PP.
\#
.MAC HEADING END
.    if !\B'\\$1' \{\
.       tm1 "[mom]: The first argument to \\$0 must be a numeric heading level.
.       ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.    \}
.    if r #QUOTE     .rr #QUOTE
.    if r #END_QUOTE .rr #END_QUOTE
.    if r #EPIGRAPH  .rr #EPIGRAPH
.    vs \\n[#DOC_LEAD]u
.    if \\$1<\\n[#LEVEL] \
.       nr #ACTIVE_LEVELS \\n[#LEVEL] \" loop count for resetting numbering registers
.    nr #LAST_LEVEL \\n[#LEVEL]       \" used during TOC collection, if SPACE_TOC_ITEMS
.    nr #LEVEL \\$1                   \" reset #LEVEL to arg
.    shift
.    nr #ARG_NUM 0 1
.    while \\n+[#ARG_NUM]<=2 \{\
.      if '\\$1'NAMED' \{\
.         ds PDF_NM "\\$1 \\$2
.         shift 2 \" \\$1 is now heading text
.      \}
.      if '\\$1'PARAHEAD' \{\
.         nr #PARAHEAD 1
.         shift \" \\$1 is now NAMED, if we have it; otherwise heading text
.      \}
.    \}
.\" Spacing
.    if \\n[#Q_LEAD_DIFF_CHECK] .sp -1v
.    ie \\n[#PARAHEAD] 'br
.    el .br
.    ie !\\n[#PARAHEAD] \{\
.       if !\\n[@TOP] \{\
.          nr #HEAD 1
.          ie \\n[#HEAD_\\n[#LEVEL]_SPACE_AFTER] .ne \\n[#NUM_ARGS]+2
.          el .ne \\n[#NUM_ARGS]+1
.          vpt 0
.          ie !\\n[#START] \
.             if !\\n[#SPACE_ADDED] .if !\\n[#LINEBREAK] .sp
.          el \{\
.             ie !\\n[#PP] .rr #START
.             el .sp
.          \}
.          if \\n[#EPIGRAPH] \
.             if \\n[#SINGLE_SPACE] .sp
.       \}
.       if \\n[#PP_SPACE] \
.          if \\n[#QUOTE_4_HD] .sp .5v
.       if !\\n[#SPACE_ADDED] .SHIM
.       if \\n[#SPACE_ADDED] .rr #SPACE_ADDED
.    \}
.    el \{\
.       if \\n[#NUM_ARGS]>1 \{\
.          tm1 "[mom]: Error at line \\n[.c], \\$0.
.          tm1 "       PARAHEAD may not be given more than 1 line of text.
.          ab  Aborting '\\n[.F]' at \\$0, line \\n[.c].
.       \}
.       vpt 0
.       if !(\\n[#PRINT_STYLE]=1)&(\\n[#SINGLE_SPACE]=1) .sp -1v
.       if \\n[#QUOTE_4_HD] \{\
.          sp -1v
.          if \\n[#PP_SPACE] \{\
.             sp .5v
.             SHIM
.         \}
.       \}
.       if (\\n[#QUOTE_4_HD]=0)&(\\n[#LB_4_HD]=0)&(\\n[#START]=0) \
.          if !\\n[#LB_4_PARAHEAD] .sp -1v
.    \}
.    ev HEADING
.    evc 0
.\" Style
.    if \\n[#PRINT_STYLE]=2 \{\
.       fam \\*[$HEAD_\\n[#LEVEL]_FAM]
.       ft  \\*[$HEAD_\\n[#LEVEL]_FT]
.       ps  \\n[#DOC_PT_SIZE]u+\\*[$HEAD_\\n[#LEVEL]_SIZE]
.       nf
.    \}
.\" Numbering
.    ds $TOC_HD_NUM_PREV \\*[$TOC_HD_NUM]
.    rm $TOC_HD_NUM
.    rm $PDF_HD_NUM
.    ie \\n[#NUMBER_HEAD_\\n[#LEVEL]] \{\
.       if \\n[#PREFIX_CH_NUM] .ds $HD_NUM \\n[#CH_NUM].
.       nr #HEAD_\\n[#LEVEL]_NUM +1       \" incremented manually here; still auto-increments
.\" Reset numbering registers for headings beneath current level
.       nr @LEVEL \\n[#LEVEL] 1           \" loop step
.       nr #LOOP \\n[#ACTIVE_LEVELS]      \" loop count
.       while \\n+[@LEVEL]<=\\n[#LOOP] \
.          if \\n[#HEAD_\\n[@LEVEL]_NUM] \
.             nr #HEAD_\\n[@LEVEL]_NUM 0 1
.\" Build numbering strings for body and toc
.       nr @LEVEL 0 1                     \" loop step
.       nr #LOOP \\n[#LEVEL]              \" loop count
.       while \\n+[@LEVEL]<=\\n[#LOOP] \
.          if \\n[#HEAD_\\n[@LEVEL]_NUM] \
.             as $HD_NUM \\n[#HEAD_\\n[@LEVEL]_NUM].
.       ie \\n[#TRUNC_TOC_HD_NUM] \
.          ds $TOC_HD_NUM \\n[#HEAD_\\n[#LEVEL]_NUM].
.       el .ds $TOC_HD_NUM \\*[$HD_NUM]
.       if \\n[#LEVEL]=1 \
.          ds $TOC_HD_NUM_PREV \\*[$TOC_HD_NUM]
.       if \\n[#TOC_NO_HD_NUM] .rm $TOC_HD_NUM
.       if !\\n[#HEAD_\\n[#LEVEL]_NUM]] .rm $TOC_HD_NUM
.       as $HD_NUM \[hd-num-spacer]
.       ds $PDF_HD_NUM \\*[$TOC_HD_NUM]
.       if !'\\*[$TOC_HD_NUM]'' .as $TOC_HD_NUM \[toc-hd-num-spacer]
.       if !'\\*[$PDF_HD_NUM]'' .as $PDF_HD_NUM " "
.    \}
.    el .nr @LEVEL \\n[#LEVEL] 1
.\" TOC collection and formatting
.    nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.    af #TOC_ENTRY_PN \\g[#PAGENUMBER]
.    nr #ARG_NUM 0 1
.    while \\n[#ARG_NUM]<\\n[#NUM_ARGS] \{\
.       as $TOC_HEAD_\\n[#LEVEL]_ITEM "\\$[\\n+[#ARG_NUM]]
.       if \\n[#NUM_ARGS]>\\n[#ARG_NUM] \
.          as $TOC_HEAD_\\n[#LEVEL]_ITEM "\\*[toc-word-space]
.    \}
.    PDF_BOOKMARK \
        \\*[PDF_NM] \\n[#LEVEL]+1 \
        \\*[$PDF_HD_NUM] \\*[$TOC_HEAD_\\n[#LEVEL]_ITEM]
.    rm PDF_NM
.    rm $PDF_HD_NUM
.    ev TOC_EV
.    ie \\n[#PRINT_STYLE]=1 \{\
.       fam \\*[$TYPEWRITER_FAM]
.       ft  R
.       ps  \\*[$TYPEWRITER_PS]
.    \}
.    el \{\
.       FAMILY  \\*[$TOC_HEAD_\\n[#LEVEL]_FAM]
.       FT      \\*[$TOC_HEAD_\\n[#LEVEL]_FT]
.       ps \\n[#TOC_PS]u\\*[$TOC_HEAD_\\n[#LEVEL]_SIZE]
.    \}
.\" Indents for TOC heading levels.
.\" First, numbered heads.  @LEVEL here is #LEVEL+1
.    ie \\n[#NUMBER_HEAD_\\n[#LEVEL]] \{\
.       ie !\\n[#TOC_NO_HD_NUM] \{\
.          ie \\n[#TRUNC_TOC_HD_NUM] \{\
.             if !\\n[#TOC_HEAD_\\n[@LEVEL]_INDENT_SET] \{\
.                ie !\\n[#FROM_STYLE_\\n[@LEVEL]] \{\
.                   ie !\\n[#NUMBER_HEAD_\\n[@LEVEL]] \
.                      nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+\w'\\*[$TOC_HD_NUM]'+1.5m
.                   el \
.                      nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+\w'\\*[$TOC_HD_NUM]'
.                \}
.                el \
.                   nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
                      \\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]
.             \}
.          \}
.          el \{\
.             if !\\n[#TOC_HEAD_\\n[@LEVEL]_INDENT_SET] \{\
.                ie !\\n[#FROM_STYLE_\\n[@LEVEL]] \{\
.                   ie \\n[#NUMBER_HEAD_\\n-[@LEVEL]] \{\
.                      ie !\\n[#NUMBER_HEAD_\\n+[@LEVEL]] \
.                         nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+\w'\\*[$TOC_HD_NUM_PREV]'+1.5m
.                      el \
.                         nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+\w'.\[toc-hd-num-spacer]'
.                   \}
.                   el \
.                      nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+\w'\\n[#TOC_HD_NUM].'
.                   ie \\n[#LEVEL]=1 \
.                      nr #TOC_HEAD_\\n+[@LEVEL]_INDENT +\w'\0'
.                   el \{\
.                      if !\\n[#NUMBER_HEAD_\\n[@LEVEL]] \{\
.                         nr @LEVEL \\n+[@LEVEL] 1
.                         nr #TOC_HEAD_\\n+[@LEVEL]_INDENT +\w'\0'
.                      \}
.                   \}
.                \}
.                el \
.                   nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+\\n[#TOC_HEAD_\\n+[@LEVEL]_INDENT]
.             \}
.             if \\n[#LEVEL]=1 \{\
.                if \\n[#NUMBER_HEAD_\\n[@LEVEL]] \{\
.                   if \\n[#PREFIX_CH_NUM] \
.                      nr #TOC_HEAD_\\n[@LEVEL]_INDENT \w'\\*[$TOC_HD_NUM]'
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          ie !\\n[#FROM_STYLE_\\n[@LEVEL]] \{\
.             if !\\n[#TOC_HEAD_\\n[@LEVEL]_INDENT_SET] \
.                nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
                    \\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+1.5m
.          \}
.          el \{\
.             if !\\n[#TOC_HEAD_\\n[@LEVEL]_INDENT_SET] \
.                nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+\\n[#TOC_HEAD_\\n+[@LEVEL]_INDENT]
.          \}
.       \}
.    \}
.\" Non-numbered heads
.    el \{\
.       nr @LEVEL \\n[#LEVEL] 1
.       ie \\n[#FROM_STYLE_\\n+[@LEVEL]] \{\    \" increments @LEVEL even if false
.          if !\\n[#TOC_HEAD_\\n[@LEVEL]_INDENT_SET] \{\
.             nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n[#LEVEL]_INDENT]+\\n[#TOC_HEAD_\\n[@LEVEL]_INDENT]
.             if !\\n[#LEVEL]=\\n[#LAST_LEVEL] \{\
.                if \\n[#NUMBER_HEAD_\\n[@LEVEL]] \
.                   nr #TOC_HEAD_\\n[#LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n[@LEVEL]_INDENT]+\w'\\*[$TOC_HD_NUM_PREV]'
.             \}
.          \}
.       \}
.       el \{\
.          nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
              \\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+1.5m
.          if \\n[#LEVEL]=1 \{\
.             if !\\n[#FROM_STYLE_1] \
.                nr #TOC_HEAD_1_INDENT 0
.          \}
.       \}
.    \}
.    nr #TOC_HEAD_\\n[@LEVEL]_INDENT_SET 1
.    HD_TO_TOC
.    rm $TOC_HEAD_\\n[#LEVEL]_ITEM
.\" Print heading
.    if !\\n[#PARAHEAD] .\\*[$HEAD_\\n[#LEVEL]_QUAD]
.    if \\n[#CAPS_ON] \{\
.       CAPS OFF
.       nr #CAPS_RESTORE 1
.    \}
.    if \\n[#HEAD_\\n[#LEVEL]_CAPS] \{\
.       CAPS 
.       nr #CAPS_OFF 1
.    \}
.    if !'\\*[$HEAD_\\n[#LEVEL]_COLOR]'' \
.       COLOR \\*[$HEAD_\\n[#LEVEL]_COLOR]
.    nop \X'ps: exec decornone'\c
.    nr #ARG_NUM 0 1
.    while \\n+[#ARG_NUM]<=\\n[#NUM_ARGS] \{\
.       if \\n[#PARAHEAD] \
.          nr #PP_TEXT_OFFSET \
              \w'\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]'+\w'\[parahead-spacer]'
.       if (\\n[#HEAD_\\n[#LEVEL]_UNDERSCORE]=0)&(\\n[#HEAD_\\n[#LEVEL]_UNDERSCORE2]=0) \{\
.          ie \\n[#HD_NUM_INDENT] \{\
.             if !'\\*[$HEAD_\\n[#LEVEL]_QUAD]'CENTER' \
.                ti \\n[#HD_NUM_INDENT]u 
.             PRINT \
"\v'-\\*[$HEAD_\\n[#LEVEL]_BASELINE_ADJ]'\\$[\\n[#ARG_NUM]]
.             br
.          \}
.          el \{\
.             ie !\\n[#PARAHEAD] \{\
.                PRINT \
"\v'-\\*[$HEAD_\\n[#LEVEL]_BASELINE_ADJ]'\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]
.                br
.             \}
.             el \{\
.                if (\\n[#PP]>0):(\\n[#INDENT_FIRST_PARAS]) \{\
.                   if !\\n[#LB_4_PARAHEAD] \{\
.                      if !\\n[#START] \{\
.                         if \\n[#PP_ACTIVE] \{\
.                            ie \\n[#PP]=1 .br
.                            el \{\
.                               nr #PP_TEXT_OFFSET +\\n[#PP_INDENT]
.                               ti \\n[#PP_INDENT]u
.                            \}
.                         \}
.                      \}
.                   \}
.                \}
.                ie \\n[#PRINT_STYLE]=1 \
.                   PRINT "\\*[UL]\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]\\*[ULX]
.                el .PRINT "\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]
.                rr #LB_4_PARAHEAD
.                sp -1v
.             \}
.          \}
.       \}
.       if \\n[#HEAD_\\n[#LEVEL]_UNDERSCORE] \{\
.          nr #SAVED_UL_WEIGHT \\n[#UNDERSCORE_WEIGHT]
.          UNDERSCORE_WEIGHT \\*[$HEAD_\\n[#LEVEL]_UL_WEIGHT]
.          ie \\n[#HD_NUM_INDENT] \{\
.             if !'\\*[$HEAD_\\n[#LEVEL]_QUAD]'CENTER' \
.                ti \\n[#HD_NUM_INDENT]u 
.             UNDERSCORE \\*[$HEAD_\\n[#LEVEL]_UL_GAP] \
                "\v'-\\*[$HEAD_\\n[#LEVEL]_BASELINE_ADJ]'\\$[\\n[#ARG_NUM]]
.             br
.          \}
.          el \{\
.             ie !\\n[#PARAHEAD] \{\
.                UNDERSCORE \\*[$HEAD_\\n[#LEVEL]_UL_GAP] \
"\v'-\\*[$HEAD_\\n[#LEVEL]_BASELINE_ADJ]'\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]
.                br
.             \}
.             el \{\
.                if (\\n[#PP]>0):(\\n[#INDENT_FIRST_PARAS]) \{\
.                   if !\\n[#LB_4_HD] \{\
.                      if !\\n[#START] \{\
.                         if \\n[#PP_ACTIVE] \{\
.                   nr #PP_TEXT_OFFSET +\\n[#PP_INDENT]
.                   if (\\n[#PRINT_STYLE]=1)&(\\n[#SINGLE_SPACE]=1) .sp -1v
.                   ti \\n[#PP_INDENT]u
.                         \}
.                      \}
.                   \}
.                \}
.                UNDERSCORE \\*[$HEAD_\\n[#LEVEL]_UL_GAP] \
                   "\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]
.                sp -1v
.             \}
.          \}
.          nr #UNDERSCORE_WEIGHT \\n[#SAVED_UL_WEIGHT]
.       \}
.       if \\n[#HEAD_\\n[#LEVEL]_UNDERSCORE2] \{\
.          nr #SAVED_UL2_WEIGHT \\n[#UNDERSCORE_WEIGHT]
.          UNDERSCORE_WEIGHT \\*[$HEAD_\\n[#LEVEL]_UL2_WEIGHT]
.          ie \\n[#HD_NUM_INDENT] \{\
.             if !'\\*[$HEAD_\\n[#LEVEL]_QUAD]'CENTER' \
.                ti \\n[#HD_NUM_INDENT]u 
.             UNDERSCORE2 \\*[$HEAD_\\n[#LEVEL]_UL2_GAP_1] \
                \\*[$HEAD_\\n[#LEVEL]_UL2_GAP_2] \
                "\v'-\\*[$HEAD_\\n[#LEVEL]_BASELINE_ADJ]'\\$[\\n[#ARG_NUM]]
.             br
.          \}
.          el \{\
.             ie !\\n[#PARAHEAD] \{\
.                UNDERSCORE2 \\*[$HEAD_\\n[#LEVEL]_UL2_GAP_1] \
                   \\*[$HEAD_\\n[#LEVEL]_UL2_GAP_2] \
"\v'-\\*[$HEAD_\\n[#LEVEL]_BASELINE_ADJ]'\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]
.                br
.             \}
.             el \{\
.                if (\\n[#PP]>0):(\\n[#INDENT_FIRST_PARAS]) \{\
.                   if !\\n[#LB_4_HD] \{\
.                      if !\\n[#START] \{\
.                         if \\n[#PP_ACTIVE] \{\
.                            nr #PP_TEXT_OFFSET +\\n[#PP_INDENT]
.                            if (\\n[#PRINT_STYLE]=1)&(\\n[#SINGLE_SPACE]=1) \
.                               sp -1v
.                            ti \\n[#PP_INDENT]u
.                         \}
.                      \}
.                   \}
.                \}
.                UNDERSCORE2 \\*[$HEAD_\\n[#LEVEL]_UL2_GAP_1] \
\\*[$HEAD_\\n[#LEVEL]_UL2_GAP_2] "\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]
.                sp -1v
.             \}
.          \}
.          nr #UNDERSCORE_WEIGHT \\n[#SAVED_UL2_WEIGHT]
.       \}
.       if !\\n[#HD_NUM_INDENT] .nr #HD_NUM_INDENT \w'\\*[$HD_NUM]'
.    \}
.    if !\\n[#PARAHEAD] \{\
.       if \\n[#HEAD_\\n[#LEVEL]_SPACE_AFTER] .sp
.    \}
.    if \\n[#CAPS_OFF] \{\
.       CAPS OFF
.       rr #CAPS_OFF
.    \}
.    if \\n[#CAPS_RESTORE] \{\
.       CAPS
.       rr #CAPS_RESTORE
.    \}
.    ev
.    rm $HD_NUM
.    rr #HD_NUM_INDENT
.    if \\n[#PARAHEAD]   .ti \\n[#PP_TEXT_OFFSET]u
.    if !\\n[#PARAHEAD]  .nr #PP 0
.    rr #PARAHEAD
.    if \\n[#LB_4_HD]    .rr #LB_4_HD
.    if \\n[#QUOTE_4_HD] .rr #QUOTE_4_HD
.    if \\n[@TOP] \{\
.       ch RR_@TOP
.       rr @TOP
.       rs
.       nop \&
.       sp -1
.    \}
.    vpt
.END
\#
\# HEADING_STYLE
\# -------------
\# *Arguments:
\#   <level>
\#   FAMILY <family>
\#   FONT   <font>
\#   SIZE   <+|-n>
\#   COLOR  <color>
\#   CAPS | NO_CAPS
\#---when called as HEADING_STYLE, these are also available---
\#   QUAD   <direction>
\#   NUMBER | NO_NUMBER
\#   SPACE_AFTER | NO_SPACE_AFTER
\#   UNDERSCORE <weight> <gap> | UNDERSCORE2 <weight> <gap1> <gap2> 
\#   NO_UNDERSCORE | NO_UNDERSCORE2
\#   BASELINE_ADJUST
\#---when called as TOC_ENTRY_STYLE this is also available---
\#   INDENT
\# *Function:
\#   Sets up complete style parameters for HEADING <level>.  If
\#   invoked as TOC_ENTRY_STYLE, sets up parameters for the
\#   corresponding TOC entry at <level>.
\# *Notes:
\#   Arguments may be given in any order.  Any not given retain
\#   their current values.  Defaults for an initial 9 levels of
\#   heading are set up in PRINTSTYLE.
\#
\#   NUMBER indicates that hierarchic numbering of <level> should be
\#   prepended to heading text.  If invoked as TOC_ENTRY_STYLE,
\#   prepend numbering to TOC entries at <level> (only works if
\#   NUMBER is given to the corresponding HEADING <level>).
\#
\#   INDENT refers to the indent for <level> in the TOC.  It is
\#   measured from the left offset of the entry level above it
\#   (including numbering, if present).  TOC entry levels beneath
\#   <level> will have their indents adjusted accordingly.
\#
.MAC HEADING_STYLE END
.    if !\B'\\$1' \{\
.       tm1 "[mom]: The first argument to \\$0 must be a numeric heading level.
.       ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.    \}
.    nr #LEVEL \\$1
.    if \\n[#FROM_OLDSTYLE] .nr #LEVEL_\\n[#LEVEL]_SET 1
.    shift
.\" Prepend TOC_ to style strings if called as TOC_ENTRY_STYLE
.    if '\\$0'TOC_ENTRY_STYLE' .ds $TOC TOC_
.    nr #ARG_NUM 0 1
.    nr #ATTRIB \\n[#NUM_ARGS]
.    while \\n+[#ARG_NUM]<=\\n[#ATTRIB] \{\
.       if '\\$1'UNDERSCORE' \{\
.          nr #HEAD_\\n[#LEVEL]_UNDERSCORE 1
.          shift
.          if '\\$1'' \{\
.             tm1 "[mom]: The UNDERSCORE argument to \\$0 requires a rule weight.
.             ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.          \}
.          ds $HEAD_\\n[#LEVEL]_UL_WEIGHT \\$1
.          shift
.          if '\\$1'' \{\
.             tm1 "[mom]: The UNDERSCORE argument to \\$0 requires a rule gap.
.             ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.          \}
.          ds $HEAD_\\n[#LEVEL]_UL_GAP    \\$1
.          shift
.       \}
.       if '\\$1'NO_UNDERSCORE' \{\
.          rr #HEAD_\\n[#LEVEL]_UNDERSCORE
.          shift
.       \}
.       if '\\$1'UNDERSCORE2' \{\
.          nr #HEAD_\\n[#LEVEL]_UNDERSCORE2 1
.          shift
.          if '\\$1'' \{\
.             tm1 "[mom]: The UNDERSCORE2 argument to \\$0 requires a rule weight.
.             ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.          \}
.          ds $HEAD_\\n[#LEVEL]_UL2_WEIGHT \\$1
.          shift
.          if '\\$1'' \{\
.             tm1 "[mom]: The UNDERSCORE2 argument to \\$0 requires a rule gap.
.             ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.          \}
.          ds $HEAD_\\n[#LEVEL]_UL2_GAP_1  \\$1
.          shift
.          if '\\$1'' \{\
.             tm1 "[mom]: The UNDERSCORE2 argument to \\$0 requires an inter-rule gap.
.             ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.          \}
.          ds $HEAD_\\n[#LEVEL]_UL2_GAP_2  \\$1
.          shift
.       \}
.       if '\\$1'NO_UNDERSCORE2' \{\
.          rr #HEAD_\\n[#LEVEL]_UNDERSCORE2
.       \}
.       if '\\$1'SPACE_AFTER' \{\
.          nr #HEAD_\\n[#LEVEL]_SPACE_AFTER 1
.          shift
.       \}
.       if '\\$1'NO_SPACE_AFTER' \{\
.          rr #HEAD_\\n[#LEVEL]_SPACE_AFTER
.          shift
.       \}
.       if '\\$1'FAMILY' \{\
.          shift
.          ds $\\*[$TOC]HEAD_\\n[#LEVEL]_FAM  \\$1
.          shift
.       \}
.       if '\\$1'FONT' \{\
.          shift
.          ds $\\*[$TOC]HEAD_\\n[#LEVEL]_FT   \\$1
.          shift
.       \}
.       if '\\$1'SIZE' \{\
.          shift
.          ds $\\*[$TOC]HEAD_\\n[#LEVEL]_SIZE \\$1
.          shift
.       \}
.       if '\\$1'QUAD' \{\
.          shift
.          if '\\$1'L'      .ds $HEAD_\\n[#LEVEL]_QUAD LEFT
.          if '\\$1'LEFT'   .ds $HEAD_\\n[#LEVEL]_QUAD LEFT
.          if '\\$1'C'      .ds $HEAD_\\n[#LEVEL]_QUAD CENTER
.          if '\\$1'CENTRE' .ds $HEAD_\\n[#LEVEL]_QUAD CENTER
.          if '\\$1'CENTER' .ds $HEAD_\\n[#LEVEL]_QUAD CENTER
.          if '\\$1'R'      .ds $HEAD_\\n[#LEVEL]_QUAD RIGHT
.          if '\\$1'RIGHT'  .ds $HEAD_\\n[#LEVEL]_QUAD RIGHT
.          shift
.       \}
.       if '\\$1'COLOR' \{\
.          shift
.          ds $\\*[$TOC]HEAD_\\n[#LEVEL]_COLOR \\$1
.          shift
.       \}
.       if '\\$1'BASELINE_ADJUST' \{\
.          shift
.          ds $HEAD_\\n[#LEVEL]_BASELINE_ADJ \\$1
.          shift
.       \}
.       if '\\$1'CAPS' \{\
.          nr #\\*[$TOC]HEAD_\\n[#LEVEL]_CAPS 1
.          shift
.       \}
.       if '\\$1'NO_CAPS' \{\
.          rr #HEAD_\\n[#LEVEL]_CAPS
.          shift
.       \}
.       if '\\$1'NUMBER' \{\
.          nr #NUMBER_HEAD_\\n[#LEVEL] 1
.          nr #HEAD_\\n[#LEVEL]_NUM 0 1
.          shift
.       \}
.       if '\\$1'NO_NUMBER' \{\
.          rr #NUMBER_HEAD_\\n[#LEVEL]
.          shift
.       \}
.       if '\\$1'INDENT' \{\
.          shift
.          nr #TOC_HEAD_\\n[#LEVEL]_INDENT \\$1
.          nr #FROM_STYLE_\\n[#LEVEL] 1
.          shift
.       \}
.    \}
.    rr #LEVEL
.    if d$TOC .rm $TOC
.END
\#
.ALIAS TOC_ENTRY_STYLE HEADING_STYLE
\#
\# OLDSTYLE HEADINGS
\# -----------------
\# *Arguments:
\#   None.
\# *Function:
\#   Called from HEAD, SUBHEAD, and SUBSUBHEAD, sets style
\#   parameters for HEADINGs 1-3 to former mom defaults for those macros.
\#   Any styles already assigned to those levels are retained.
\#
\#   Called by user with no argument, allows use of old style HEAD,
\#   SUBHEAD, and SUBSUBHEAD without generating the deprecated msg.
\# *Notes:
\#   For backward compatibility, and to ease the transition to
\#   the HEADING scheme for heads.
\#
\#   Paraheads must be set with .HEADING <level> PARAHEAD; attempts
\#   to call PARAHEAD abort with an instructive message.
\#
.MAC OLDSTYLE_HEADINGS END
.    if '\\$1'' .nr #SKIP_MSG 1
.    nr #FROM_OLDSTYLE 1 \" Used in HEADING
.    if \\n[#PRINT_STYLE]=1 \{\
.       if !\\n[#LEVEL_1_SET] \{\
.          HEADING_STYLE 1 \
             FONT R \
             SIZE +0 \
             QUAD C \
             CAPS \
             UNDERSCORE .5 2p \
             BASELINE_ADJUST 0 \
             SPACE_AFTER
.            nr #OLDSTYLE_HD 1
.            return
.       \}
.       if !\\n[#LEVEL_2_SET] \{\
.          HEADING_STYLE 2 \
             FONT R \
             SIZE +0 \
             UNDERSCORE .5 2p \
             BASELINE_ADJUST \\n[.v]/8
.            nr #OLDSTYLE_SH 1
.            return
.       \}
.       if !\\n[#LEVEL_3_SET] \{\
.          HEADING_STYLE 3 \
             FONT R \
             SIZE +0 \
             BASELINE_ADJUST \\n[.v]/8
.            nr #OLDSTYLE_SSH 1
.            return
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       if !\\n[#LEVEL_1_SET] \{\
.          HEADING_STYLE 1 \
             FAMILY \E*[$DOC_FAM] \
             FONT B \
             SIZE +1 \
             QUAD C \
             CAPS \
             UNDERSCORE .5 2p \
             BASELINE_ADJUST 0 \
             SPACE_AFTER
.            nr #OLDSTYLE_HD 1
.            return
.       \}
.       if !\\n[#LEVEL_2_SET] \{\
.          HEADING_STYLE 2 \
             FAMILY \E*[$DOC_FAM] \
             FONT B \
             SIZE +.5 \
             BASELINE_ADJUST \\n[.v]/8
.            nr #OLDSTYLE_SH 1
.            return
.       \}
.       if !\\n[#LEVEL_3_SET] \{\
.          HEADING_STYLE 3 \
             FAMILY \E*[$DOC_FAM] \
             FONT I \
             SIZE +.5 \
             BASELINE_ADJUST \\n[.v]/8
.            nr #OLDSTYLE_SSH 1
.            return
.       \}
.    \}
.    rr #FROM_OLDSTYLE
.END
\#
\# "Deprecated" message
\#
.MAC DEPRECATED END
.    if !\\n[#SKIP_MSG] \{\
.       tm1 "[mom]: Macro '\\$1' at line \\n[.c] is deprecated.
.       tm1 "       Invoking HEADING \\$2 instead and assigning style defaults
.       tm1 "          from former \\$1 as described in the documentation.
.       tm1 "       If another style is desired, use HEADING_STYLE \\$2 to
.       tm1 "          create it (see docs).
.       tm1 "       Further warnings will not be emitted for \\$1.
.       tm1 "       To avoid this message when using the deprecated HEAD,
.       tm1 "          SUBHEAD, and SUBSUBHEAD macros, add '.OLDSTYLE_HEADINGS'
.       tm1 "          after PRINTSTYLE before START.
.       rm $MACRO
.    \}
.END
\#
\# Wrappers around old-style headings.
\#
.MAC HEAD END
.    if !\\n[#OLDSTYLE_HD] \{\
.       DEPRECATED HEAD 1
.       OLDSTYLE_HEADINGS HEAD
.    \}
.    HEADING 1 \\$@
.END
\#
.MAC SUBHEAD END
.    if !\\n[#OLDSTYLE_SH] \{\
.       DEPRECATED SUBHEAD 2
.       OLDSTYLE_HEADINGS SUBHEAD
.    \}
.     HEADING 2 \\$@
.END
\#
.MAC SUBSUBHEAD END
.    if !\\n[#OLDSTYLE_SSH] \{\
.       DEPRECATED SUBSUBHEAD 3
.       OLDSTYLE_HEADINGS SUBSUBHEAD
.    \}
.    HEADING 3 \\$@
.END
\#
.MAC PARAHEAD END
.    tm1 "[mom]: \\$0 is no longer a valid macro.
.    tm1 "       Use 'HEADING <level> PARAHEAD <text>' instead.
.    tm1 "       You will probably want to invoke HEADING_STYLE to set
.    tm1 "       the type parameters for the parahead.  See docs.
.    ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.END
\#
\# Wrapper macro for oldstyle NUMBER_HEADS, NUMBER_SUBHEADS...
\#
.MAC HEADING_NUMBERS END
.    if '\\$0'NUMBER_PARAHEADS' \{\
.       tm1 "[mom]: \\$0 is no longer a valid macro.
.       tm1 "       Use 'HEADING_STYLE <level> NUMBER' instead.  See docs.
.       ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.       return
.    \}
.    if '\\$0'NUMBER_HEADS'       .nr level 1
.    if '\\$0'NUMBER_SUBHEADS'    .nr level 2
.    if '\\$0'NUMBER_SUBSUBHEADS' .nr level 3
.    ds mom "[mom]:\"
.    ie '\\$1'' .ds $PARAM NUMBER
.    el \{\
.       ds $PARAM NO_NUMBER
.       ds $SWITCH " \\$1
.    \}
.    HEADING_STYLE \\n[level] \\*[$PARAM]
.    if (\\n[#OLDSTYLE_HD]=1):(\\n[#OLDSTYLE_SH]=1):(\\n[#OLDSTYLE_SSH]=1) \{\
.       tm1 "\\*[mom] OLDSTYLE_HEADINGS detected.
.       ds mom "      \"
.    \}
.    tm1 "\\*[mom] Setting HEADING_STYLE \\n[level] to '\\*[$PARAM]' at '\\$0\\*[$SWITCH]', line \\n[.c].
.    rm $PARAM
.    rm $SWITCH
.END
\#
.ALIAS NUMBER_HEADS       HEADING_NUMBERS
.ALIAS NUMBER_SUBHEADS    HEADING_NUMBERS
.ALIAS NUMBER_SUBSUBHEADS HEADING_NUMBERS
.ALIAS NUMBER_PARAHEADS   HEADING_NUMBERS
\#
\# PREFIX CHAPTER NUMBERS TO HEADINGS/TOC ENTRIES
\# ----------------------------------------------------------------
\# *Arguments:
\#   <none> | <chapter number> | <anything>
\# *Function:
\#   Toggles register #PREFIX_CH_NUM. Sets register #CH_NUM from
\#   string $CHAPTER if $CHAPTER is a digit; if <chapter number> arg
\#   given, sets #CH_NUM to arg.
\# *Notes:
\#   Default is OFF.
\#
.MAC PREFIX_CHAPTER_NUMBER END
.    ie '\\$1'' \{\
.       ie r#CH_NUM \{\
.          nr #PREFIX_CH_NUM 1
.          if \\n[#CHAPTER_CALLED] \{\
.             ie \B'\\*[$CHAPTER]' .nr #CH_NUM \\*[$CHAPTER]
.             el .PREFIX_CH_NUM_WARNING
.             rr #CHAPTER_CALLED
.          \}
.       \}
.       el \{\
.          ie \B'\\*[$CHAPTER]' \{\
.             nr #PREFIX_CH_NUM 1
.             nr #CH_NUM \\*[$CHAPTER]
.          \}
.          el .PREFIX_CH_NUM_WARNING
.       \}
.    \}
.    el \{\
.       ie \B'\\$1' \{\
.          nr #CH_NUM \\$1
.          nr #PREFIX_CH_NUM 1
.       \}
.       el .rr #PREFIX_CH_NUM
.    \}
.END
\#
.MAC PREFIX_CH_NUM_WARNING END
.    tm1 "[mom]: PREFIX_CHAPTER_NUMBER cannot determine a chapter number.
.    tm1 "       Enter the current chapter number as a digit after
.    tm1 "       PREFIX_CHAPTER_NUMBER.
.    ab Aborting '\\n[.F]', line \\n[.c].
.END
\#
\# ====================================================================
\#
\# +++LINE BREAKS+++
\#
\# LINEBREAK CHARACTER
\# -------------------
\# *Arguments:
\#   [character] [iterations] [vertical adjustment]
\# *Function:
\#   Allows user to specify a line break character and the number
\#   of times to repeat it horiontally.
\# *Notes:
\#   Without an argument, LINEBREAK_CHAR will deposit a blank line.
\#
\#   Vertical adjustment requires a unit of measure (most likely
\#   "p"), and has to be preceded by +|-
\#
.MAC LINEBREAK_CHAR END
.    nr #REPEAT 1
.    ds $LINEBREAK_CHAR \\$1
.    if !'\\$2'' .nr #LB_CHAR_ITERATIONS \\$2
.    if !'\\$3'' .ds $LINEBREAK_CHAR_V_ADJ \\$3
.    if '\\*[$LINEBREAK_CHAR_V_ADJ]'' .ds $LINEBREAK_CHAR_V_ADJ +0
.    if \\n[#LB_CHAR_ITERATIONS] \{\
.       while (\\n[#LB_CHAR_ITERATIONS]>\\n[#REPEAT]) \{\
.          as $LINEBREAK_CHAR "\\ \\$1
.          nr #REPEAT \\n[#REPEAT]+1
.       \}
.    \}
.    rr #REPEAT
.    rr #LB_CHAR_ITERATIONS
.END
\#
\# LINE BREAK
\# ----------
\# *Arguments:
\#   <none>
\# *Function:
\#   Deposits line break character.
\# *Notes:
\#   If $LINEBREAK_CHAR is blank, simply advances 2 line spaces.
\#
.MAC LINEBREAK END
.    if r #Q_AT_TOP .rr #Q_AT_TOP
.    ie  '\\*[$LINEBREAK_CHAR]'' .sp 2
.    el \{\
.       ie \\n[#END_QUOTE] .
.       el .sp
.       ev LINEBREAK
.       evc 0
.       CENTER
.       PRINT \
\m[\\*[$LINEBREAK_COLOR]]\v'\\*[$LINEBREAK_CHAR_V_ADJ]'\
\\*[$LINEBREAK_CHAR]\m[]
.       sp
.       ev
.       QUAD \\*[$DOC_QUAD]
.    \}
.    nr #LINEBREAK 1
.    if r #QUOTE .rr #QUOTE
.    if r #END_QUOTE .rr #END_QUOTE
.    nr #PP 0
.    nr #LB_4_HD       1
.    nr #LB_4_PARAHEAD 1
.END
\#
\# ====================================================================
\#
\# +++PARAGRAPHS+++
\#
\# PARAGRAPH FONT
\# --------------
\# *Argument:
\#   <font of running text>
\# *Function:
\#   Creates or modifies string $PP_FT.
\# *Notes:
\#   Affects all paragraphs.
\#
.MAC PP_FONT END
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#ITALIC_MEANS_ITALIC] .nop
.       el .return
.    \}
.    if \\n[#COLLATE]=1 \
.       if !'\\*[$SAVED_PP_FT]'' .rm $SAVED_PP_FT
.    ds $PP_FT \\$1
.    FT \\*[$PP_FT]
.END
\#
\# PARAGRAPH INDENT
\# ----------------
\# *Argument:
\#   <amount to indent paragraphs in running text (ipPcm)>
\# *Function:
\#   Allows user to change the default para indent.  The change will
\#   affect the indent of QUOTEs and BLOCKQUOTEs as well.
\# *Notes:
\#   Default for printstyle TYPEWRITE is 1/2-inch.  Default for
\#   printstyle TYPESET is 2 ems.  The defaults are set in
\#   PRINTSTYLE, not DEFAULTS.
\#
.MAC PARA_INDENT END
.    ie \B'\\$1' \{\
.       nr #PP_INDENT (\\$1)
.       nr #SAVED_PP_INDENT \\n[#PP_INDENT]
.    \}
.    el \{\
.       ie '\\$1'' \{\
.          nr #PP_INDENT \\n[#SAVED_PP_INDENT]
.          rr #SAVED_PP_INDENT
.       \}
.       el \{\
.          nr #SAVED_PP_INDENT \\n[#PP_INDENT]
.          rr #PP_INDENT
.       \}
.    \}
.END
\#
\# INDENT FIRST PARAGRAPHS
\# -----------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   By default, the first para of a document, as well as the first
\#   paras of blockquotes and block-style epigraphs are not indented.
\#   When invoked, this macro will indent all paras.
\# *Notes:
\#   Default is OFF.
\#
.MAC INDENT_FIRST_PARAS END
.    ie '\\$1'' .nr #INDENT_FIRST_PARAS 1
.    el .rr #INDENT_FIRST_PARAS
.END
\#
\# INTER-PARAGRAPH SPACING
\# -----------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Adds a line space between paragraphs in body text.  Block quotes
\#   are unaffected.
\# *Notes:
\#   Default is OFF.  PARA_SPACE is not recommended for use with
\#   PRINTSTYLE TYPEWRITE without SINGLESPACE.
\#
.MAC PARA_SPACE END
.    ie '\\$1'' \{\
.       nr #PP_SPACE 1
.    \}
.    el \{\
.       ie \B'\\$1' \{\
.          nr #PP_SPACE 1
.          ds $PP_SPACE_AMOUNT \\$1
.       \}
.       el .rr #PP_SPACE
.    \}
.END
\#
\# PARAGRAPH
\# ---------
\# *Arguments:
\#   <none>
\# *Function:
\#   Figures out what to do with paragraphs under differing conditions.
\# *Notes:
\#   Note the use of transparent line break (\!.br) to get
\#   PP to work within blockquotes and epigraphs.
\#
\#   PP_STYLE 1 = regular paras; 2 = blockquotes, epigraphs
\#
.MAC PP END
.    if \\n[#DOC_TYPE]=4 \{\
.       if !'\\n[.z]'' .di
.       nr #TOTAL_FIELDS \\n[#FIELD]
.       nr #FIELD        0 1
.       nr #NUM_FIELDS   0 1
.       if \\n[#TOTAL_FIELDS]>0 \{\
.          while \\n+[#NUM_FIELDS]<=\\n[#TOTAL_FIELDS] \{\
.             nf
.             LETTERHEAD\\n+[#FIELD]
.             QUAD \\*[$DOC_QUAD]
.             ALD \\n[#DOC_LEAD]u
.             if \\n[#DATE_FIRST]=1 .ALD \\n[#DOC_LEAD]u
.             rr #DATE_FIRST
.             rm LETTERHEAD\\n[#FIELD]
.          \}
.          rr #FIELD
.          rr #NUM_FIELDS
.          rr #TOTAL_FIELDS
.       \}
.    \}
.    rr #PP_ACTIVE
.    if r #Q_AT_TOP .rr #Q_AT_TOP
.    if \\n[#PP_STYLE]=1 \{\
.       if \\n[#ENDNOTE] \{\
.          nr #RESET_PARA_SPACE \\n[#PP_SPACE]
.          ie \\n[#EN_PP_SPACE] .PARA_SPACE
.          el .PARA_SPACE OFF
.       \}
.       if !\\n[#ENDNOTE] .po \\n[#L_MARGIN]u
.       if \\n[#COLUMNS] \{\
.          if !\\n[#ENDNOTE] \{\
.             po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.             nr #L_MARGIN \\n[.o]
.          \}
.       \}
.       if \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.       ie \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          ie \\n[#ENDNOTE] .vs \\n[#EN_LEAD]u
.          el .vs \\n[#DOC_LEAD]u
.          QUAD \\*[$DOC_QUAD]
.          if \\n[#SLANT_ON] \{\
.             if \\n[#UNDERLINE_SLANT] .UNDERLINE
.          \}
.          if '\\*[$PP_FT]'I' \
.             if \\n[#ITALIC_MEANS_ITALIC] .FT I
.       \}
.       el \{\
.          ie \\n[#ENDNOTE] \{\
.             FAMILY  \\*[$EN_FAM]
.             FT      \\*[$EN_FT]
.             ps \\n[#EN_PS]u
.             vs \\n[#EN_LEAD]u
.             QUAD    \\*[$EN_QUAD]
.          \}
.          el \{\
.             FAMILY  \\*[$DOC_FAM]
.             if !'\\*[$SAVED_PP_FT]'' \{\
.                ds $PP_FT \\*[$SAVED_PP_FT]
.                rm $SAVED_PP_FT
.             \}
.             FT \\*[$PP_FT]
.             ps \\n[#DOC_PT_SIZE]u
.             vs      \\n[#DOC_LEAD]u
.             QUAD    \\*[$DOC_QUAD]
.          \}
.       \}
.       ie \\n[#PP]=0 \{\
.          if \\n[#INDENT_FIRST_PARAS] \{\
.             ie \\n[#INDENT_ACTIVE] .ti \\n[#INDENT]u+\\n[#PP_INDENT]u
.             el .ti \\n[#PP_INDENT]u
.             if '\\n[.z]'END_NOTES' \
.                ti \\n[#EN_PP_INDENT]u+\\n[#EN_TEXT_INDENT]u
.          \}
.          if r #END_QUOTE \{\
.             if \\n[#END_QUOTE] \{\
.                if !\\n[#LINEBREAK] \{\
.                   ie \\n[#INDENT_ACTIVE] .ti \\n[#INDENT]u+\\n[#PP_INDENT]u
.                   el .ti \\n[#PP_INDENT]u
.                   if '\\n[.z]'END_NOTES' \
.                      ti \\n[#EN_PP_INDENT]u+\\n[#EN_TEXT_INDENT]u
.                \}
.             \}
.          \}
.       \}
.       el \{\
\#.          br
.          if \\n[#PP_SPACE] \{\
.             ie \\n[#END_QUOTE] \{\
.                ie !'\\*[$PP_SPACE_AMOUNT]'' .ALD \\*[$PP_SPACE_AMOUNT]
.                el .sp
.                rr #END_QUOTE
.                nr #NO_SPACE 1
.                nr #BASELINE_MARK \\n[nl]
.             \}
.             el \{\
.                if \\n[#NO_SPACE]=1 .rr #NO_SPACE
.                if !\\n[nl]=\\n[#BASELINE_MARK] \{\
.                ie !'\\*[$PP_SPACE_AMOUNT]'' .ALD \\*[$PP_SPACE_AMOUNT]
.                el .sp
.                   rr #BASELINE_MARK
.                \}
.             \}
.          \}
.          ie \\n[#INDENT_ACTIVE] .ti \\n[#INDENT]u+\\n[#PP_INDENT]u
.          el .ti \\n[#PP_INDENT]u
.          if '\\n[.z]'END_NOTES' \
.             ti \\n[#EN_PP_INDENT]u+\\n[#EN_TEXT_INDENT]u
.       \}
.       if r #START     .rr #START
.       if r #QUOTE     .rr #QUOTE
.       if r #END_QUOTE .rr #END_QUOTE
.       if r #HEAD      .rr #HEAD
.       if r #SUBHEAD   .rr #SUBHEAD
.       if r #EPIGRAPH  .rr #EPIGRAPH
.       if r #Q_FITS    .rr #Q_FITS
.       if r #LINEBREAK .rr #LINEBREAK
.       if \\n[#ENDNOTE] \{\
.          ie \\n[#RESET_PARA_SPACE] .PARA_SPACE
.          el .PARA_SPACE OFF
.       \}
.       if \\n[#CONDENSE] \{\
\E*[COND]\c
.       \}
.       if \\n[#EXTEND]=1 \{\
\E*[EXT]\c
.       \}
.       nr #PP +1
.    \}
.    if \\n[#PP_STYLE]=2 \{\
\!.     br
.       if \\n[#BROKEN_QUOTE] \{\
.          ie \\n[nl]=\\n[#PAGE_TOP] .nr #Q_PP 1
.          el .nr #Q_PP 0
.          rr #BROKEN_QUOTE
.       \}
.       ie \\n[#Q_PP]=0 \{\
.          if \\n[#INDENT_FIRST_PARAS] \
.             ti \\n[#PP_INDENT]u/2u
.          if \\n[#ENDNOTE] \{\
.             ie \\n[#INDENT_FIRSTS] .ti \\n[#PP_INDENT]u/2u
.             el .ti 0
.          \}
.       \}
.       el \{\
.          ti \\n[#PP_INDENT]u/2u
.          if \\n[#PP_SPACE]=1 \{\
.             ie !'\\*[$PP_SPACE_AMOUNT]'' .ALD \\*[$PP_SPACE_AMOUNT]
.             el .sp
.          \}
.       \}
.       if \\n[#CONDENSE] \{\
\E*[COND]\c
.       \}
.       if \\n[#EXTEND]=1 \{\
\E*[EXT]\c
.       \}
.    nr #Q_PP +1
.    \}
.\" This takes care of multi-paragraph dialogue, where each para
.\" is introduced by an open quote whereas the previous para has
.\" no close quote.
.    if \\n[#OPEN_CLOSE]=1 .nr #OPEN_CLOSE 0
.    nr #PP_ACTIVE 1
.    UNDERLINE OFF
.    if r #QUOTE_4_HD .rr #QUOTE_4_HD
.    if r #LB_4_HD .rr #LB_4_HD
.END
\# ====================================================================
\#
\# +++QUOTES+++
\#
\# ---Line for line quotes, i.e. poetry or code snippets---
\#
\# UNDERLINE QUOTES
\# ----------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #UNDERLINE_QUOTES (toggle).
\#   If on, line for line quotes are underlined when printstyle
\#   is TYPEWRITE.
\# *Notes:
\#   Default is ON for printstyle TYPEWRITE.
\#
.MAC UNDERLINE_QUOTES END
.    ie '\\$1'' .nr #UNDERLINE_QUOTES 1
.    el .rr #UNDERLINE_QUOTES
.END
\#
\# QUOTE INDENT
\# ------------
\# *Argument:
\#   <integer> | <integer with unit of measure appended>
\# *Function:
\#   Creates or modifies register #Q_OFFSET_VALUE or string
\#   $Q_OFFSET_VALUE.
\# *Notes:
\#   If just an integer given, value by which to multiply PARA_INDENT
\#   to get quote indent.  If integer with a unit of measure appended,
\#   absolute value of quote indent.
\#
\#  Default is 3 for typeset; 2 for typewrite.
\#
.MAC QUOTE_INDENT END
.    rr #Q_OFFSET_VALUE
.    rm $Q_OFFSET_VALUE
.    ds $EVAL_QI_ARG \\$1
.    substring $EVAL_QI_ARG -1
.    ie \B'\\*[$EVAL_QI_ARG]' .nr #Q_OFFSET_VALUE \\$1
.    el .ds $Q_OFFSET_VALUE \\$1
.    rm $EVAL_QI_ARG
.END
\#
\# QUOTE_AUTOLEAD
\# --------------
\# *Arguments:
\#   <autolead value>
\# *Function:
\#   Sets autolead for quotes and/or blockquotes.
\#
.MAC QUOTE_AUTOLEAD END
.    rr #\\$0_DEFAULT
.    if '\\$0'QUOTE_AUTOLEAD'              .nr #Q_AUTOLEAD (p;\\$1)
.    if '\\$0'BLOCKQUOTE_AUTOLEAD'         .nr #BQ_AUTOLEAD (p;\\$1)
.    if '\\$0'ENDNOTE_QUOTE_AUTOLEAD'      .nr #EN_Q_AUTOLEAD (p;\\$1)
.    if '\\$0'ENDNOTE_BLOCKQUOTE_AUTOLEAD' .nr #EN_BQ_AUTOLEAD (p;\\$1)
.END
\#
.ALIAS BLOCKQUOTE_AUTOLEAD         QUOTE_AUTOLEAD
.ALIAS ENDNOTE_QUOTE_AUTOLEAD      QUOTE_AUTOLEAD
.ALIAS ENDNOTE_BLOCKQUOTE_AUTOLEAD QUOTE_AUTOLEAD
\#
\# ALWAYS FULLSPACE QUOTES
\# -----------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #FULLSPACE_QUOTES.
\# *Notes:
\#   If user doesn't like the default 1/2 line space above and below
\#   quotes, s/he can turn it off here.  Has no effect in TYPEWRITE.
\#
.MAC ALWAYS_FULLSPACE_QUOTES END
.    if '\\$1'' .nr #FULLSPACE_QUOTES 1
.    el .rr #FULLSPACE_QUOTES
.END
\#
\# QUOTE
\# -----
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Indents quoted text on a line for line basis, or turns QUOTE off.
\# *Notes:
\#   Owing to the need to bottom align TYPESET pages, quoted text gets
\#   diverted so its depth can be measured (in DO_QUOTE) for determining
\#   how much space to put before and after.
\#
\# QUOTE
\# -----
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Indents quoted text on a line for line basis, or turns QUOTE off.
\# *Notes:
\#   Owing to the need to bottom align TYPESET pages, quoted text gets
\#   diverted so its depth can be measured (in DO_QUOTE) for determining
\#   how much space to put before and after.
\#
.MAC QUOTE END
.    br
.    if \\n[#PP]>0 .rr #START
.    if \\n[#LINENUMBERS]=1 \{\
.       nr #LINENUMBERS 2
.       nr #NEXT_LN \\n[ln]
.       nm
.    \}
.    ie '\\$1'' \{\
.       ev QUOTE
.       evc 0
.       if \\n[#LINENUMBERS]=2 \{\
.          if \\n[#SILENT_QUOTE_LN]=1 .nm \\n[#NEXT_LN] 1000 -4
.       \}
.       nr #IN_DIVER 1
.       nr #QUOTE 1
.       di P_QUOTE
.       ie !'\\*[$Q_OFFSET_VALUE]'' .ll \\n[#L_LENGTH]u-(\\*[$Q_OFFSET_VALUE]*2u)
.       el .ll \\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.       ta \\n[.l]u
.       if \\n[#COLUMNS] \{\
.          ie \\n[#Q_OFFSET_VALUE] \
.             ll \\n[#COL_L_LENGTH]u-(\\n[#PP_INDENT]u*\\n[#Q_OFFSET_VALUE]u)
.          el .ll \\n[#COL_L_LENGTH]u-\\*[$Q_OFFSET_VALUE]
.          ta \\n[.l]u
.       \}
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          vs \\n[#DOC_LEAD]u
.          LEFT
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY  \\*[$QUOTE_FAM]
.          FT      \\*[$QUOTE_FT]
.          ps \\n[#DOC_PT_SIZE]u\\*[$QUOTE_SIZE_CHANGE]
.          ie !r #Q_AUTOLEAD .vs \\n[#DOC_LEAD]u
.          el \{\
.             vs \\n[.ps]u+\\n[#Q_AUTOLEAD]u
.             nr #Q_LEAD \\n[.v]
.          \}
.          if \\n[#ENDNOTE] \{\
.             ps \\n[#EN_PS]u\\*[$QUOTE_SIZE_CHANGE]
.             ie !r #EN_Q_AUTOLEAD .vs \\n[#EN_Q_LEAD]u
.             el \{\
.                vs \\n[.ps]u+\n[#EN_Q_AUTOLEAD]u
.                nr #EN_Q_LEAD \\n[.v]
.             \}
.          \}
.          nr #Q_LEAD_REAL \\n[.v]
.          LEFT
.          if \\n[#QUOTE_COLOR]=1 \{\
.             nf
\m[\\*[$QUOTE_COLOR]]
.             EOL
.          \}
.       \}
.       if \\n[#LINENUMBERS]=2 \{\
.          ie \\n[#QUOTE_LN]=1 \{\
.             if '\\n[#Q_LN_GUTTER]'' .nr #Q_LN_GUTTER \\n[#LN_GUTTER]
.             LN_PARAMS
.             nm \\n[ln] "" \\n[#Q_LN_GUTTER] -3-\\n[#Q_LN_GUTTER]
.             RESTORE_PARAMS
.          \}
.          el \{\
.             if !\\n[#SILENT_QUOTE_LN] .NUMBER_LINES OFF
.          \}
.       \}
.       nr #Q_TOP \\n[nl]
.       if \\n[#PRINT_STYLE]=1 \
.          if \\n[#UNDERLINE_QUOTES] .FT I
.    \}
.    el .DO_QUOTE
.END
\#
\# CODE
\# ----
\# *Arguments:
\#   <none> [ BR | BREAK | SPREAD ]
\#    or
\#   <anything> [ BR | BREAK | SPREAD ]
\# *Function:
\#   Takes care of administrivia associated with setting code snippets.
\#
.MAC CODE END
\c
.    if '\\$1'BR' \{\
.       br
.       nr #BREAK_OR_SPREAD 1
.       shift
.    \}
.    if '\\$1'BREAK' \{\
.       nr #BREAK_OR_SPREAD 1
.       br
.       shift
.    \}
.    if '\\$1'SPREAD' \{\
.       nr #BREAK_OR_SPREAD 2
.       brp
.       shift
.    \}
.    ie '\\$1'' \{\
.       ds $RESTORE_FAM \\n[.fam]
.       ds $RESTORE_FT  \\n[.sty]
.       ie \\n[#PRINT_STYLE]=1 \{\
.          CODE_FAMILY C
.          ie \\n[#CODE_FT]=1 .ft \\*[$CODE_FT]
.          el \{\
.             CODE_FONT R
.             ft R
.             char ' \[aq]
.          \}
.          if \\n[#UNDERLINE_QUOTES]=1 \{\
.             nr #RESTORE_UNDERLINE 1
.             UNDERLINE_QUOTES OFF
.             FT \\*[$CODE_FT]
.             char ' \[aq]
.          \}
.       \}
.       el \{\
.          ie \\n[#CODE_FAM]=1 .fam \\*[$CODE_FAM]
.          el \{\
.             CODE_FAMILY C
.             fam \\*[$CODE_FAM]
.          \}
.          ie \\n[#CODE_FT]=1 .ft \\*[$CODE_FT]
.          el \{\
.             CODE_FONT R
.             ft \\*[$CODE_FT]
.          \}
.          if \\n[#CODE_COLOR]=1 .COLOR \\*[$CODE_COLOR]
.          char ' \[aq]
.          if !\\n[#CODE_SIZE_ADJ]=0 .ps \\n[#PT_SIZE]u*\\n[#CODE_SIZE_ADJ]u/100u
.          if \\n[#SQ_ON] \{\
.             nr #SQ_WAS_ON 1
.             SMARTQUOTES OFF
.          \}
.       \}
.    \}
.    el \{\
.       fam \\*[#RESTORE_FAM]
.       ft  \\*[#RESTORE_FT]
.       rm $RESTORE_FAM
.       rm $RESTORE_FT
.       if !\\n[#CODE_SIZE_ADJ]=0 .ps
.       char ' \[aq]
.       if !'\\n[.z]'' \
.          if \\n[#LINENUMBERS] .nn
.       if \\n[#CODE_COLOR]=1 .gcolor
.       if \\n[#RESTORE_UNDERLINE]=1 \{\
.          rr #RESTORE_UNDERLINE
.          UNDERLINE_QUOTES
.       \}
.       if \\n[#SQ_WAS_ON]=1 \{\
.          rr #SQ_WAS_ON
.          SMARTQUOTES
.       \}
.       if \\n[#QUOTE] .sp 1v
.    \}
.END
\#
\# CODE_FAMILY
\# -----------
\# *Arguments:
\#   <family>
\# *Function:
\#   Creates register #CODE_FAM and string $CODE_FAM for use by CODE.
\#
.MAC CODE_FAMILY END
.    nr #CODE_FAM 1
.    ds $CODE_FAM \\$1
.END
\#
\# CODE_FONT
\# ---------
\# *Arguments:
\#   <font>
\# *Function:
\#   Creates register #CODE_FT and string $CODE_FT for use by CODE.
\#
.MAC CODE_FONT END
.    nr #CODE_FT 1
.    ds $CODE_FT \\$1
.END
\#
\# CODE_SIZE
\# ---------
\# *Arguments:
\#   <percentage to zoom code font>
\# *Function:
\#   Creates register #CODE_SIZE_ADJ, used in CODE to zoom the
\#   CODE_FONT to a percentage of the current point size.
\#
.MAC CODE_SIZE END
. nr #CODE_SIZE_ADJ \\$1
.END
\#
\# ---Blockquotes---
\#
\# BLOCKQUOTE
\# ----------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Indents quoted text in fill mode and shortens line length
\#   equivalently, or turns BLOCKQUOTE off.
\# *Notes:
\#   Owing to the need to bottom align TYPESET pages, quoted text gets
\#   diverted so its depth can be measured (in DO_QUOTE) for determining
\#   how much space to put before and after.
\#
\#   .PP after blockquote is optional if there's only one para,
\#   but required if there's more than one.
\#
.MAC BLOCKQUOTE END
.    br
.    if \\n[#LINENUMBERS]=1 \{\
.       nr #LINENUMBERS 2
.       nr #NEXT_LN \\n[ln]
.       nm
.    \}
.    ie '\\$1'' \{\
.       ev BLOCKQUOTE
.       evc 0
.       nr #IN_DIVER 1
.       nr #QUOTE    2
.       nr #PP_STYLE 2
.       nr #Q_PP     0
.       di B_QUOTE
.       ie !'\\*[$Q_OFFSET_VALUE]'' .ll \\n[#L_LENGTH]u-(\\*[$Q_OFFSET_VALUE]*2u)
.       el .ll \\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.       if \\n[#ENDNOTE] \{\
.          if \\n[#EN_NUMBERS_ALIGN_RIGHT] \{\
.             ie r#Q_OFFSET_VALUE \
.                ll \
\\n[#RESET_L_LENGTH]u-\\n[#EN_TEXT_INDENT]u-(\\n[#EN_PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.             el \
.                ll \
\\n[#RESET_L_LENGTH]u-\\n[#EN_TEXT_INDENT]u-(\\*[$Q_OFFSET_VALUE]*2u)
.          \}
.          if \\n[#EN_NUMBERS_ALIGN_LEFT] \{\
.             ie r#Q_OFFSET_VALUE \
.                ll \\n[#L_LENGTH]u-(\\n[#EN_PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.             el \
.                ll \\n[#L_LENGTH]u-(\\*[$Q_OFFSET_VALUE]u*2u)
.          \}
.       \}
.       ta \\n[.l]u
.       CHECK_INDENT
.       if \\n[#COLUMNS] \{\
.          ie r#Q_OFFSET_VALUE \
.             ll \
\\n[#COL_L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.          el \
.             ll \\n[#COL_L_LENGTH]u-(\\*[$Q_OFFSET_VALUE]*2u)
.          if \\n[#ENDNOTE] \{\
.             if \\n[#EN_NUMBERS_ALIGN_RIGHT] \{\
.                ie r#Q_OFFSET_VALUE \
.                   ll \
\\n[#RESET_L_LENGTH]u-\\n[#EN_TEXT_INDENT]u-(\\n[#EN_PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.                el \
.                   ll \
\\n[#RESET_L_LENGTH]u-\\n[#EN_TEXT_INDENT]u-(\\*[$Q_OFFSET_VALUE]*2u)
.             \}
.             if \\n[#EN_NUMBERS_ALIGN_LEFT] \{\
.                ie r#Q_OFFSET_VALUE \
.                   ll \
\\n[#COL_L_LENGTH]u-(\\n[#EN_PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.                el \
.                   ll \\n[#COL_L_LENGTH]u-(\\*[$Q_OFFSET_VALUE]*2u)
.             \}
.          \}
.          ta \\n[.l]u
.       \}
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          vs \\n[#DOC_LEAD]u
.          QUAD LEFT
.          HY OFF
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY  \\*[$BQUOTE_FAM]
.          FT      \\*[$BQUOTE_FT]
.          ps \\n[#DOC_PT_SIZE]u\\*[$BQUOTE_SIZE_CHANGE]
.          ie !r #BQ_AUTOLEAD .vs \\n[#DOC_LEAD]u
.          el \{\
.             vs \\n[.ps]u+\\n[#BQ_AUTOLEAD]u
.             nr #BQ_LEAD \\n[.v]
.          \}
.          if \\n[#ENDNOTE] \{\
.             ps \\n[#EN_PS]u\\*[$BQUOTE_SIZE_CHANGE]
.             ie !r#EN_BQ_AUTOLEAD .vs \\n[#EN_BQ_LEAD]u
.             el \{\
.                vs \\n[.ps]u+\\n[#EN_BQ_AUTOLEAD]u
.                nr #EN_BQ_LEAD \\n[.v]
.             \}
.          \}
.          nr #Q_LEAD_REAL \\n[.v]
.          if \\n[#BQUOTE_COLOR]=1 \{\
.             nf
\m[\\*[$BQUOTE_COLOR]]
.             EOL
.          \}
.          QUAD \\*[$BQUOTE_QUAD]
.          nr #DIVERSIONS_HY_MARGIN (p;\\n[.ps]u*2.75)/1000
.          HY_SET 1 \\n[#DIVERSIONS_HY_MARGIN]u (\\n[#PT_SIZE]u/1000u/8u)p
.          hy 14
.       \}
.       if \\n[#LINENUMBERS]=2 \{\
.          ie \\n[#BQUOTE_LN]=1 \{\
.             if '\\n[#BQ_LN_GUTTER]'' .nr #BQ_LN_GUTTER \\n[#LN_GUTTER]
.             LN_PARAMS
.             nm \\n[ln] "" \\n[#BQ_LN_GUTTER] -3-\\n[#BQ_LN_GUTTER]
.             RESTORE_PARAMS
.          \}
.          el \
.             if !\\n[#SILENT_BQUOTE_LN] .NUMBER_LINES OFF
.       \}
.       nr #Q_TOP \\n[nl]
.       if \\n[#INDENT_FIRST_PARAS] \{\
.          ie !\\n[#ENDNOTE] \{\
.             if \\n[#PRINT_STYLE]=1 .ti \\n[#PP_INDENT]u/2u
.             if \\n[#PRINT_STYLE]=2 .ti \\n[#PP_INDENT]u/2u
.          \}
.          el \{\
.             if \\n[#INDENT_FIRSTS]=1 \{\
.                if \\n[#PRINT_STYLE]=1 .ti \\n[#EN_PP_INDENT]u/2u
.                if \\n[#PRINT_STYLE]=2 .ti \\n[#EN_PP_INDENT]u/2u
.             \}
.          \}
.       \}
.    \}
.    el .DO_QUOTE
.END
\#
\# DO QUOTE
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Ends the diversion P_QUOTE or B_QUOTE.  Spaces them according to
\#   PRINTSTYLE, whether there's inter-paragraph spacing, and page
\#   position.  TYPEWRITE treats spacing the same way in all circumstance
\#   (viz. an extra line space).  TYPESET puts in only half
\#   line spaces if the entire quote plus 1 line of body under the quote
\#   fits on the the page; otherwise it puts in a full extra blank
\#   line.  (This is to ensure the page remains bottom aligned).
\#
.MAC DO_QUOTE END
.    br
.    if \\n[#DIVER_LN_OFF] \{\
\!.     NUMBER_LINES OFF
.       rr #DIVER_LN_OFF
.    \}
.    di
.    rr #IN_DIVER
.    if \\n[#RESET_FN_COUNTERS]=2 \{\
.       if !\\n[#FN_COUNT]=1 \{\
.          if ((\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS])+\\n[#DIVER_DEPTH])>(\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS]) \{\
.             DIVER_FN_2_POST
.             rr #RESET_FN_COUNTERS
.          \}
.       \}
.    \}
.    nr #SAVED_FN_NUMBER \\n[#FN_NUMBER]
.    nr #DONE_ONCE 0 1
.    REMOVE_INDENT
.    ev
.    nr #Q_DEPTH (\\n[#DIVER_DEPTH]-\\n[#Q_LEAD_REAL])
.    nr #Q_LEAD_DIFF \\n[#LEAD]-\\n[#Q_LEAD_REAL]
.    if !\\n[.v]=\\n[#Q_LEAD_REAL] \{\
.       SILENT
.       br
.       nf
.       nr #CURRENT_V_POS \
\\n[nl]+\\n[#Q_LEAD_DIFF]+(\\n[#DIVER_DEPTH]-\\n[#Q_DEPTH_REAL])
.       SHIM
.       SILENT OFF
.       nr #Q_SPACE_ADJ \\n[#SHIM]/2
.       nr #TRAP \\n[.t]-1
.    \}
.    if \\n[#ENDNOTE] \{\
.       nr #RESET_QUOTE_SPACING \\n[#FULLSPACE_QUOTES]
.       ALWAYS_FULLSPACE_QUOTES
.    \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#START]=1 .
.       if \\n[#START]=0 \
.          if !\\n[#LINEBREAK] .ALD \\n[#DOC_LEAD]u
.       if \\n[#HEAD] \
.          if \\n[#HEAD]=1 .RLD \\n[#DOC_LEAD]u
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#PP_SPACE] \{\
.          ie \\n[#HEAD] .
.          el \{\
.             ie \\n[#START] .
.             el \{\
.                ie \\n[#FULLSPACE_QUOTES] .ALD \\n[#DOC_LEAD]u
.                el .ALD \\n[#DOC_LEAD]u/2u
.             \}
.          \}
.       \}
.       el \{\
.          ie \\n[#Q_DEPTH]<(\\n[#TRAP_DISTANCE]-1) \{\
.             ie ((\\n[#TRAP_DISTANCE]-1)-\\n[#Q_DEPTH])<\\n[#DOC_LEAD] \
.                Q_NOFIT
.             el \{\
.                ie (\\n[#TRAP_DISTANCE]-\\n[#DOC_LEAD])<\\n[#DOC_LEAD] .Q_NOFIT
.                el \{\
.                   ie (\\n[#Q_DEPTH]+\\n[.v])=(\\n[#TRAP_DISTANCE]-1) .Q_NOFIT
.                   el .Q_FITS
.                \}
.             \}
.          \}
.          el .Q_NOFIT
.       \}
.       if \\n[#LINEBREAK] \{\
.          ie !\\n[@TOP] .RLD \\n[#DOC_LEAD]u
.          el \{\
.             nop
.             sp |\\n[#T_MARGIN]u-\\n[#BQ_LEAD]u
.          \}
.       \}
.    \}
.    ie !'\\*[$Q_OFFSET_VALUE]'' .nr #Q_OFFSET \\n[#L_MARGIN]+\\*[$Q_OFFSET_VALUE]
.    el \
.       nr #Q_OFFSET \\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.    if \\n[#COLUMNS] \{\
.       ie r#Q_OFFSET_VALUE \
.          nr #Q_OFFSET \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.       el .nr #Q_OFFSET \\n[#COL_\\n[#COL_NUM]_L_MARGIN]+\\*[$Q_OFFSET_VALUE]
.    \}
.    if !\\n[#ENDNOTE] \{\
.       po \\n[#Q_OFFSET]u
.       if '\\n[.z]'FLOAT*DIV' \!.po \\n[#Q_OFFSET]u
.    \}
.    if \\n[#ENDNOTE] \{\
.       ie \\n[#Q_OFFSET_VALUE] .in +\\n[#EN_PP_INDENT]u*\\n[#Q_OFFSET_VALUE]u
.       el .in +\\*[$Q_OFFSET_VALUE]
.    \}
.    ie \\n[#START]=1 \{\
.       ie !\\n[#Q_LEAD_DIFF]<0 .ALD \\n[#Q_SPACE_ADJ]u
.       el .RLD 0-\\n[#Q_LEAD_DIFF]u
.    \}
.    el \{\
.       if \\n[#PRINT_STYLE]=2 \{\
.           if !\\n[.v]=\\n[#Q_LEAD] .ALD \\n[#Q_SPACE_ADJ]u
.       \}
.    \}
.    if \\n[#QUOTE]=1 \{\
.       nf
.       P_QUOTE
.       br
.       if !\\n[#START] .rr #QUOTE
.    \}
.    if \\n[#QUOTE]=2 \{\
.       nf
.       B_QUOTE
.       br
.    \}
.    if \\n[#PRINT_STYLE]=1 \
.       if !\\n[.v]=\\n[#DOC_LEAD] .SHIM
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#START] \{\
.          ie \\n[#PP_SPACE] .
.          el \{\
.             ALD \\n[#DOC_LEAD]u
.             SHIM
.          \}
.       \}
.       el \{\
.          ie \\n[#HEAD]=1 \{\
.             ALD \\n[#DOC_LEAD]u
.             SHIM
.          \}
.          el \{\
.             ie \\n[#FULLSPACE_QUOTES] \{\
.                ie \\n[#ENDNOTE] .ALD \\n[#EN_LEAD]u
.                el .ALD \\n[#DOC_LEAD]u
.             \}
.             el .ALD (\\n[#DOC_LEAD]/2)u
.             ie \\n[#Q_FITS] \{\
.                ie (\\n[#Q_TOP]=\\n[#PAGE_TOP]):(\\n[@TOP]=1) \{\
.                   nr #Q_AT_TOP 1
.                   nr #DELAY_SHIM 1
.                \}
.                el \
.                   if !\\n[.v]=\\n[#Q_LEAD_REAL] .SHIM
.             \}
.             el \{\
.                SHIM
.\" Make sure that Q_LEAD_DIFF is not added to the first line of
.\" normal text at the top of any page following output of a quote
.\" whose last line falls on B_MARGIN of the previous page.
.                if \\n[#Q_LEAD_DIFF] \{\
.                   if \\n[nl]=(\\n[#T_MARGIN]-\\n[#DOC_LEAD]+\\n[#Q_LEAD_DIFF]) \{\
.                      PRINT \&
.                      br
.                      sp -1v-\\n[#Q_LEAD_DIFF]u
.                      nr #Q_LEAD_DIFF_CHECK 1
.                   \}
.                \}
.             \}
.          \}
.       \}
.    \}
.    rr #Q_SPACE_ADJ
.    if \\n[#LINENUMBERS]=2 \{\
.       nr #LINENUMBERS 1
.       if !\\n[#ENDNOTE] \{\
.          ie \\n[#RESTORE_LN_NUM]=1 \{\
.             LN_PARAMS
.             nm \\n[#NEXT_LN]
.             RESTORE_PARAMS
.          \}
.          el \{\
.             LN_PARAMS
.             nm +0
.             RESTORE_PARAMS
.          \}
.       \}
.    \}
.    if \\n[#ENDNOTE] .nr #FULLSPACE_QUOTES \\n[#RESET_QUOTE_SPACING]
.    if r #HEAD .rr #HEAD
.    if r #EPIGRAPH .rr #EPIGRAPH
.    rr #Q_PP
.    rr #LINEBREAK
.    nr #PP_STYLE  1
.    nr #END_QUOTE 1
.    if !\\n[#ENDNOTE] \{\
.       po \\n[#L_MARGIN]u
.       if '\\n[.z]'FLOAT*DIV' \!.po \\n[#L_MARGIN]u
.    \}
.    if \\n[#ENDNOTE]  .in \\n[#EN_TEXT_INDENT]u
.    if \\n[#COLUMNS] \{\
.       if !\\n[#ENDNOTE] \{\
.          po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n[.o]
.       \}
.       if \\n[#ENDNOTE] .in \\n[#EN_TEXT_INDENT]u
.    \}
.    ie !\\n[#ENDNOTE] .QUAD \\*[$DOC_QUAD]
.    el .QUAD \\*[EN_QUAD]
.    if r #DELAY_SHIM \{\
.       SHIM
.       rr #DELAY_SHIM
.    \}
.    if \\n[#PRINT_STYLE]=1 \
.       if \\n[#UNDERLINE_QUOTES] .FT R
.    nr #QUOTE_4_HD 1
.END
\#
\# Utility macros for DO_QUOTE
\# ---------------------------
\#
.MAC Q_FITS END
.    nr #Q_FITS 1
.    ie \\n[#HEAD]=1 .ALD \\n[#Q_LEAD_DIFF]u
.    el \{\
.       ie \\n[#START] .
.       el \{\
.          ie \\n[#FULLSPACE_QUOTES] \{\
.             ie \\n[#ENDNOTE] .ALD \\n[#EN_LEAD]u+\\n[#Q_LEAD_DIFF]u
.             el .ALD \\n[#DOC_LEAD]u+\\n[#Q_LEAD_DIFF]u
.          \}
.          el \{\
.\" This seems to be the only way to get the baseline of quotes that
.\" start at the top of the page to fall on the first line of the
.\" grid (ie. on the first valid baseline of the page).
.             ie \\n[#Q_TOP]=\\n[#PAGE_TOP] \{\
.                if \\n[#QUOTE]=1 \{\
.                   rn P_QUOTE Q_TEMP
.                   di P_QUOTE
.                   nf
.                   vs \\n[#Q_LEAD]u
.                   PRINT \&
.                   sp -1v+\\n[#Q_LEAD_DIFF]u
.                   Q_TEMP
.                   di
.                \}
.                if \\n[#QUOTE]=2 \{\
.                   rn B_QUOTE Q_TEMP
.                   di B_QUOTE
.                   nf
.                   vs \\n[#BQ_LEAD]u
.                   PRINT \&
.                   sp -1v+\\n[#Q_LEAD_DIFF]u
.                   Q_TEMP
.                   di
.                \}
.                rm Q_TEMP
.             \}
.             el .ALD (\\n[#DOC_LEAD]u/2u)+\\n[#Q_SPACE_ADJ]u
.          \}
.       \}
.       if \\n[#DIVER_FN]=2 .rr #DIVER_FN
.    \}
.END
\#
.MAC Q_NOFIT END
.    rr #Q_FITS
.    ie r#HEAD \
.       if \\n[#HEAD]=1 .
.    el \{\
.       if \\n[#Q_DEPTH]=0 \
.          if \\n[.ns] .rs
.       ie \\n[#FULLSPACE_QUOTES] \{\
.          ie \\n[#ENDNOTE] .ALD \\n[#EN_LEAD]u+\\n[#Q_LEAD_DIFF]u
.          el .ALD \\n[#DOC_LEAD]u+\\n[#Q_LEAD_DIFF]u
.       \}
.       el \{\
.          ALD \\n[#DOC_LEAD]u+\\n[#Q_LEAD_DIFF]
.          if \\n[@TOP] .rs
.       \}
.       nr #Q_PARTIAL_DEPTH 0 \\n[#Q_LEAD_REAL]
.       while \\n+[#Q_PARTIAL_DEPTH]<(\\n[#TRAP_DISTANCE]-1) \{\
.
.       \}
.       nr #Q_PARTIAL_DEPTH -\\n[#Q_LEAD_REAL]
.       nr #Q_SPACE_ADJ \
(\\n[#TRAP_DISTANCE]-1)-\\n[#Q_PARTIAL_DEPTH]+\\n[#Q_LEAD_DIFF]u
.       if \\n[#FN_COUNT]>0 .nr #Q_SPACE_ADJ (\\n[#Q_SPACE_ADJ] / 2u)
.\" Hack to deal with the fact that even though the above routine
.\" makes the bottom line of the quote fall exactly on the bottom
.\" margin when traps are disabled, it refuses to do so when traps
.\" are on.  The difference by which it's off is #Q_LEAD_DIFF
.\" (the +\\n[#Q_LEAD_DIFF] at the end of the line, above).  Hack
.\" solution: temporarily lower the FOOTER trap position.
.       if !\\n[#Q_DEPTH]=0 \{\
.          nr #SAVED_FOOTER_POS \\n[#VARIABLE_FOOTER_POS]
.          ch FOOTER \\n[#VARIABLE_FOOTER_POS]u+.25v
.       \}
.    \}
.END
\#
\# ====================================================================
\#
\# +++PAGINATION+++
\#
\# PAGINATE
\# --------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns page numbering off or on during document processing.
\# *Notes:
\#   Default is on.
\#
.MAC PAGINATE END
.    ie '\\$1'' .nr #PAGINATE 1
.    el \{\
.      nr #PAGINATE 0
.      if !\\n[#COLLATE] .rr #PAGE_NUM_V_POS
.    \}
.    if \\n[#HF_OFF]=1 \{\
.       rr #PAGINATION_STATE
.       rr #HF_OFF
.    \}
.END
\#
\# SUSPEND PAGINATION (before ENDNOTES)
\# ------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Creates register #SUSPEND_PAGINATION
\# *Notes:
\#   Useful only to suspend pagination before outputting endnotes.
\#
.MAC SUSPEND_PAGINATION END
.    nr #SUSPEND_PAGINATION 1
.END
\#
\# RESTORE PAGINATION (after ENDNOTES)
\# ------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Removes register #SUSPEND_PAGINATION.  Creates register
\#   #DEFER_PAGINATION
\# *Notes:
\#   Useful only to restore pagination after outputting endnotes.
\#
.MAC RESTORE_PAGINATION END
.    rr #SUSPEND_PAGINATION
.    if \\n[#PAGE_NUM_V_POS]=1 .PAGINATE
.    if \\n[#PAGE_NUM_V_POS]=2 .nr #DEFER_PAGINATION 1
.END
\#
\# PAGE NUMBER FORMAT
\# ------------------
\# *Arguments:
\#   DIGIT | ROMAN | roman | ALPHA | alpha
\# *Function:
\#   Assigns user entered format to #PAGENUMBER.
\#
.MAC PAGENUM_STYLE END
.    nr #PAGENUM_STYLE_SET 1
.    if '\\$1'DIGIT' \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER 1
.    \}
.    if '\\$1'ROMAN' \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER I
.    \}
.    if '\\$1'roman' \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER i
.    \}
.    if '\\$1'ALPHA' \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER A
.    \}
.    if '\\$1'alpha' \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER a
.    \}
.END
\#
\# HYPHENS AROUND PAGE NUMBERS
\# ---------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #PAGE_NUM_HYPHENS.
\#   Used to dis/enable hyphens on either side of page numbers.
\# *Notes:
\#   Default is on.
\#
.MAC PAGENUM_HYPHENS END
.    nr #PAGE_NUM_HYPHENS_SET 1
.    ie '\\$1'' .nr #PAGE_NUM_HYPHENS 1
.    el .rr #PAGE_NUM_HYPHENS
.END
\#
\# PAGENUMBER POSITION
\# -------------------
\# *Arguments:
\#   TOP | BOTTOM  LEFT | CENTER | RIGHT
\# *Function:
\#   Creates or modifies various PAGE_NUM_H | V_POS registers.
\#   Used to position page numbers.
\# *Notes:
\#   Default is center/bottom.
\#
.MAC PAGENUM_POS END
.    nr #PAGE_NUM_POS_SET 1
.    if '\\$1'TOP'    .nr #PAGE_NUM_V_POS 1
.    if '\\$1'BOTTOM' .nr #PAGE_NUM_V_POS 2
.    if '\\$2'LEFT'   .nr #PAGE_NUM_H_POS 1
.    if '\\$2'CENTER' .nr #PAGE_NUM_H_POS 2
.    if '\\$2'CENTRE' .nr #PAGE_NUM_H_POS 2
.    if '\\$2'RIGHT'  .nr #PAGE_NUM_H_POS 3
.END
\#
.MAC PN_WITH_HYPHENS END
.    nr #HYPHEN_ADJ \\n[#CAP_HEIGHT]/12
.    ds $HYPHEN \v'-\En[#HYPHEN_ADJ]u'-\v'\En[#HYPHEN_ADJ]u'
.    ds $PN_FOR_KN \\n[#PAGENUMBER]
.\"  Check for initial or terminal 1's or 7's, and apply a little kerning
.    substring $PN_FOR_KN 0 0 \" 1st digit
.    if '\\*[$PN_FOR_KN]'1' .ds $PRE_HY_KN \*[BU3]
.    if '\\*[$PN_FOR_KN]'7' .ds $PRE_HY_KN \*[BU3]
.    ds $PN_FOR_KN \\n[#PAGENUMBER]
.    substring $PN_FOR_KN -1 -1 \" last digit
.    if '\\*[$PN_FOR_KN]'1' .ds $POST_HY_KN \*[BU3]
.    if '\\*[$PN_FOR_KN]'7' .ds $POST_HY_KN \*[BU3]
.    PRINT \
\m[\\*[$PAGENUM_COLOR]]\
\\*[$HYPHEN]\|\\*[$PRE_HY_KN]\\n[#PAGENUMBER]\\*[$POST_HY_KN]\|\\*[$HYPHEN]
.    br
.    rm $PRE_HY_KERN
.    rm $POST_HY_KERN
.END
\#
\# PRINT PAGE NUMBER
\# -----------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Prints page number if PAGINATE=1.
\#
.MAC PRINT_PAGE_NUMBER END
.    ev PAGENUMBER
.    nf
.    po  \\n[#DOC_L_MARGIN]u
.    ll  \\n[#DOC_L_LENGTH]u
.    ta  \\n[.l]u
.    fam \\*[$PAGE_NUM_FAM]
.    ft  \\*[$PAGE_NUM_FT]
.    ps  \\n[#DOC_PT_SIZE]u\\*[$PAGE_NUM_SIZE_CHANGE]
.    if  \\n[#PRINT_STYLE]=1 .TYPEWRITER
.    if  \\n[#PAGE_NUM_V_POS]=1 .vs 0
.    if o \{\
.       ie \\n[#PAGE_NUM_H_POS]=1 .LEFT
.       el .RIGHT
.    \}
.    if e \{\
.       ie \\n[#PAGE_NUM_H_POS]=1 .RIGHT
.       el .LEFT
.    \}
.    if \\n[#PAGE_NUM_H_POS]=2 .CENTER
.    if \\n[#RECTO_VERSO]=0 \{\
.       if \\n[#PAGE_NUM_H_POS]=1 .LEFT
.       if \\n[#PAGE_NUM_H_POS]=2 .CENTER
.       if \\n[#PAGE_NUM_H_POS]=3 .RIGHT
.    \}
.    nr #PAGENUMBER \\n%+\\n[#PAGE_NUM_ADJ]
.    if \\n[#EN_FIRST_PAGE] \{\
.       if \\n[#EN_FIRST_PN] .PAGENUMBER \\n[#EN_FIRST_PN]
.       rr #EN_FIRST_PAGE
.    \}
.    if \\n[#BIB_FIRST_PAGE] \{\
.       if \\n[#BIB_FIRST_PN] .PAGENUMBER \\n[#BIB_FIRST_PN]
.       rr #BIB_FIRST_PAGE
.    \}
.    ie \\n[#DRAFT_WITH_PAGENUM] \{\
.       ie '\\*[$REVISION]'' \
.          PRINT "\\*[$DRAFT_STRING]\\*[$DRAFT] / \\n[#PAGENUMBER]"
.       el \{\
.          ie '\\*[$DRAFT]'' \
.             PRINT "\\*[$REVISION_STRING] \\*[$REVISION] / \\n[#PAGENUMBER]"
.          el \
.             PRINT \
"\\*[$DRAFT_STRING]\\*[$DRAFT], \\*[$REVISION_STRING] \\*[$REVISION] / \
\\n[#PAGENUMBER]"
.       \}
.    \}
.    el \{\
.       ie \\n[#PAGE_NUM_HYPHENS] \{\
.          if '\\*[$PAGENUM_STYLE]'DIGIT' \{\
.             di NULL
1\\R'#CAP_HEIGHT \\n[.cht]'
.             di
.             PN_WITH_HYPHENS
.          \}
.          if '\\*[$PAGENUM_STYLE]'ROMAN' \{\
.             di NULL
I\\R'#CAP_HEIGHT \\n[.cht]'
.             di
.             PN_WITH_HYPHENS
.          \}
.          if '\\*[$PAGENUM_STYLE]'ALPHA' \{\
.             di NULL
E\\R'#CAP_HEIGHT \\n[.cht]'
.             di
.             PN_WITH_HYPHENS
.          \}
.          if '\\*[$PAGENUM_STYLE]'roman' \
.             PRINT \m[\\*[$PAGENUM_COLOR]]-\|\\n[#PAGENUMBER]\|-
.          if '\\*[$PAGENUM_STYLE]'alpha' \
.             PRINT \m[\\*[$PAGENUM_COLOR]]-\|\\n[#PAGENUMBER]\|-
.       \}
.       el .PRINT \m[\\*[$PAGENUM_COLOR]]\\n[#PAGENUMBER]
.    \}
.    ev
.    nr #DIVER_DEPTH 0
.END
\#
\# ====================================================================
\#
\# +++FOOTNOTES+++
\#
\# Mom's footnote handling is baroque, to say the least.  There are
\# redundancies in a number of the macros involved, as well as some
\# registers that probably don't get used anymore.  The baggage is left
\# in in case some new footnote oddity/challenge gets thrown at her.
\#
\# The macros are heavily commented.
\#
\# FOOTNOTE AUTOLEAD
\# -----------------
\# *Arguments:
\#   <autolead value for footnotes>
\# *Function:
\#   Creates or modifies register #FN_AUTOLEAD.
\# *Notes:
\#   Default is #DOC_LEAD/2 for TYPEWRITE; 2 for TYPESET
\#
.MAC FOOTNOTE_AUTOLEAD END
.    nr #FN_AUTOLEAD (p;\\$1)
.END
\#
\# FOOTNOTE MARKERS
\# ----------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns generation of footnote markers on or off.
\# *Notes:
\#   Default is on.
\#
.MAC FOOTNOTE_MARKERS END
.    ie '\\$1'' .nr #FN_MARKERS 1
.    el .nr #FN_MARKERS 0
.END
\#
\# FOOTNOTE MARKER STYLE
\# ---------------------
\# *Arguments:
\#   STAR | NUMBER | LINE
\# *Function:
\#   Sets register #FN_MARKER_STYLE, used in FOOTNOTE to determine
\#   the style of footnote markers.
\# *Notes:
\#   1=STAR; 2=NUMBER; 3=LINE.  LINE means "use output line numbers".
\#   Default is STAR.
\#
.MAC FOOTNOTE_MARKER_STYLE END
.    if '\\$1'STAR' \{\
.       if \\n[#FN_MARKER_STYLE]=3 \{\
.          if !\\n[#NEWPAGE]=1 \{\
.             tm1 "[mom]: Your current FOOTNOTE_MARKER STYLE is LINE.
.             tm1 "       You cannot change footnote marker style without
.             tm1 "       first breaking to a new page with NEWPAGE.
.             tm1 "       Ignoring request FOOTNOTE_MARKER_STYLE STAR at line \\n[.c].
.             return
.          \}
.       \}
.       if \\n[#RUN_ON]=1 \{\
.          tm1 "[mom]: FOOTNOTE_MARKER_STYLE STAR at line \\n[.c] is incompatible
.          tm1 "       with RUN_ON footnotes.  Ignoring request.
.          return
.       \}
.       nr #FN_MARKER_STYLE 1
.       if \\n[#NEWPAGE]=1 .rr #NEWPAGE
.       FOOTNOTE_MARKERS
.    \}
.    if '\\$1'NUMBER' \{\
.       if \\n[#FN_MARKER_STYLE]=3 \{\
.          if !\\n[#NEWPAGE]=1 \{\
.             tm1 "[mom]: Your current FOOTNOTE_MARKER STYLE is NUMBER.
.             tm1 "       You cannot change footnote marker style without
.             tm1 "       first breaking to a new page with NEWPAGE.
.             tm1 "       Ignoring request FOOTNOTE_MARKER_STYLE NUMBER at line \\n[.c].
.             return
.          \}
.       \}
.       if \\n[#RUN_ON]=1 \{\
.          tm1 "[mom]: FOOTNOTE_MARKER_STYLE NUMBER at line \\n[.c] is incompatible
.          tm1 "       with RUN_ON footnotes.  Ignoring request.
.          return
.       \}
.       nr #FN_MARKER_STYLE 2
.       shift
.       if '\\$1'NO_SUPERSCRIPT' .nr #NO_SUPERSCRIPT 1
.       if \\n[#NEWPAGE]=1 .rr #NEWPAGE
.       FOOTNOTE_MARKERS
.    \}
.    if '\\$1'LINE' \{\
.       nr #FN_MARKER_STYLE 3
.       FOOTNOTE_MARKERS OFF
.       if !\\n[#FN_LN_SEP] \
.          if !\\n[#FN_LN_BRACKETS] .FOOTNOTE_LINENUMBER_BRACKETS SQUARE
.    \}
.END
\#
\# FOOTNOTE NUMBER PLACEHOLDERS
\# ----------------------------
\# *Argument:
\#   <number of placeholders>
\# *Function:
\#   Sets register #FN_NUMBER_PLACEHOLDERS, used to establish whether to
\#   right pad a footnote number (in the footnote itself, not body copy).
\# *Notes:
\#   No default is set for this; user must determine if, and where, it's
\#   required
\#
.MAC FOOTNOTE_NUMBER_PLACEHOLDERS END
.    nr #FN_NUMBER_PLACEHOLDERS \\$1
.END
\#
\# FOOTNOTE LINENUMBER MARK
\# ------------------------
\# *Function:
\#   This string, when called inline, stores the current output line
\#   number in register #FN_MARK for use with FOOTNOTE.
\#
.ds FN_MARK \R'#FN_MARK \En[ln]'
\#
\# FOOTNOTE LINENUMBER SEPARATOR
\# -----------------------------
\# *Argument:
\#   <user-defined separator>
\# *Function:
\#   Stores user-defined separator (for use then
\#   FOOTNOTE_MARKER_STYLE is LINE) in string $FN_LN_SEP.  The
\#   separator is intended to be used when the user wishes a
\#   separator, rather than the choice of brackets offered by
\#   FOOTNOTE_LINENUMBER_BRACKETS.
\#
.MAC FOOTNOTE_LINENUMBER_SEPARATOR END
.    rr #FN_LN_BRACKETS
.    nr #FN_LN_SEP 1
.    ds $FN_LN_SEP "\\$1
.END
\#
\# FOOTNOTE LINENUMBER BRACKETS
\# ----------------------------
\# *Argument:
\#   PARENS | SQUARE | BRACES or ( | [ | {
\# *Function:
\#   Sets register #FN_LN_BRACKETS to 1, and creates strings
\#   $FN_OPEN_BRACKET and $FN_CLOSE_BRACKET according to the given
\#   argument.
\#
.MAC FOOTNOTE_LINENUMBER_BRACKETS END
.    rr #FN_LN_SEP
.    nr #FN_LN_BRACKETS 1
.    if '\\$1'PARENS' \{\
.       ds $FN_OPEN_BRACKET (
.       ds $FN_CLOSE_BRACKET )
.    \}
.    if '\\$1'(' \{\
.       ds $FN_OPEN_BRACKET (
.       ds $FN_CLOSE_BRACKET )
.    \}
.    if '\\$1'SQUARE' \{\
.       ds $FN_OPEN_BRACKET [
.       ds $FN_CLOSE_BRACKET ]
.    \}
.    if '\\$1'[' \{\
.       ds $FN_OPEN_BRACKET [
.       ds $FN_CLOSE_BRACKET ]
.    \}
.    if '\\$1'BRACES' \{\
.       ds $FN_OPEN_BRACKET {
.       ds $FN_CLOSE_BRACKET }
.    \}
.    if '\\$1'{' \{\
.       ds $FN_OPEN_BRACKET {
.       ds $FN_CLOSE_BRACKET }
.    \}
.END
\#
\# RESET FOOTNOTE NUMBER
\# ---------------------
\# *Arguments:
\#   <none> | PAGE
\# *Function:
\#   Resets register #FN_NUMBER to 1.  If argument is PAGE, creates
\#   toggle #RESET_FN_NUMBER which is checked in HEADER.  If 1,
\#   numbered footnotes on every page start at 1.
\#
.MAC RESET_FOOTNOTE_NUMBER END
.    ie '\\$1'' .nr #FN_NUMBER 0 1
.    el .nr #RESET_FN_NUMBER 1
.END
\#
\# FOOTNOTE RULE LENGTH
\# --------------------
\# *Arguments:
\#   <length of rule used to separate footnotes from running text>
\# *Function:
\#   Creates or modifies registers #FN_RULE_LENGTH.
\# *Notes:
\#   Requires unit of measure (iPpcm).
\#   Default is 4P for both PRINTSTYLEs.
\#
.MAC FOOTNOTE_RULE_LENGTH END
.    nr #FN_RULE_LENGTH (\\$1)
.END
\#
\# FOOTNOTE_RULE_ADJ
\# -----------------
\# *Arguments:
\#   <number of points to raise footnote rule from it's baseline position>
\# *Function:
\#   Creates or modifies register #FN_RULE_ADJ.
\# *Notes:
\#   Default is 3p for both TYPESTYLES.
\#
\#   Requires unit of measure.
\#
.MAC FOOTNOTE_RULE_ADJ END
.    nr #FN_RULE_ADJ (\\$1)
.END
\#
\# FOOTNOTE RULE
\# -------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns printing of footnote separator rule on or off.  If invoked as
\#   PRINT_FOOTNOTE_RULE, prints footnote separator rule.
\# *Notes:
\#   Default is on.
\#
\#   Invoked in FOOTNOTE (as PRINT_FOOTNOTE_RULE) as 1st line of a footnote
\#   if the footnote number (#FN_COUNT) is 1.
\#
.MAC FOOTNOTE_RULE END
.    ie '\\$0'PRINT_FOOTNOTE_RULE' \{\
.       if \\n[#FN_RULE]=0 .RLD 1v
.       RLD 1v
.       LEFT
\v'-\\n[#FN_RULE_ADJ]u-\\n[#FN_RULE_WEIGHT_ADJ]u'\
\D't \\n[#FN_RULE_WEIGHT]'\
\h'-\\n[#FN_RULE_WEIGHT]u'\
\D'l \\n[#FN_RULE_LENGTH]u 0'\
\v'+\\n[#FN_RULE_ADJ]u+\\n[#FN_RULE_WEIGHT_ADJ]u'
\!.     ps \\n[#DOC_PT_SIZE]u\\*$[FN_SIZE_CHANGE]
.       QUAD \\*[$FN_QUAD]
.    \}
.    el \{\
.       ie '\\$1'' .nr #FN_RULE 1
.       el .nr #FN_RULE 0
.    \}
.END
\#
\# FOOTNOTE SPACING
\# ----------------
\# *Arguments:
\#   <per item post footnote spacing> | <anything>
\# *Function:
\#   Enables printing of post footnote spacing.
\# *Notes:
\#   Default is no space.
\#
.MAC FOOTNOTE_SPACING END
.    ie \B'\\$1' .ds $FN_SPACE \\$1
.    el .rm $FN_SPACE
.END
\#
\# RUN ON FOOTNOTES
\# ----------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles run-on footnotes on or off.
\#
.MAC FOOTNOTES_RUN_ON END
.    ie '\\$1'' \{\
.       if \\n[#FN_COUNT]>0 \{\
.          tm1 "[mom]: Switching to run-on footnotes at line \\n[.c] will cause
.          tm1 "       you to loose footnotes already formatted for this page.
.          tm1 "       Ignoring request FOOTNOTES_RUN_ON.
.          rr #RUN_ON
.          return
.       \}
.       nr #RUN_ON 1
.       if \\n[#FN_MARKER_STYLE]=1 .RUNON_WARNING
.       if \\n[#FN_MARKER_STYLE]=2 .RUNON_WARNING
.    \}
.    el \{\
.       if \\n[#FN_COUNT]>0 \{\
.          if \\n[#RUN_ON]=1 \{\
.             tm1 "[mom]: Switching off run-on footnotes at line \\n[.c] will cause
.             tm1 "       you to loose footnotes already formatted for this page.
.             tm1 "       Ignoring request FOOTNOTES_RUN_ON \\$1.
.             return
.          \}
.       \}
.       rr #RUN_ON
.    \}
.END
\#
.MAC RUNON_WARNING END
.    if \\n[#FN_MARKER_STYLE]=1 \{\
.       tm1 "[mom]: The footnote marker style active at line \\n[.c] is STAR,
.       tm1 "       which is incompatible with run-on footnotes.  Please change
.       tm1 "       the footnote marker style to LINE.  Continuing to process,
.       tm1 "       but ignoring request FOOTNOTES_RUN_ON.
.       rr #RUN_ON
.    \}
.    if \\n[#FN_MARKER_STYLE]=2 \{\
.       tm1 "[mom]: The footnote marker style active at line \\n[.c] is NUMBER,
.       tm1 "       which is incompatible with run-on footnotes.  Please change
.       tm1 "       the footnote marker style to LINE.  Continuing to process,
.       tm1 "       but ignoring request FOOTNOTES_RUN_ON.
.       rr #RUN_ON
.    \}
.END
\#
\# FOOTNOTE
\# --------
\# *Arguments:
\#   <none> | INDENT  L|LEFT|R|RIGHT|B|BOTH  <indent value> | <anything>
\# *Function:
\#   Begins collecting and diverting footnote text if no argument
\#   given.  Otherwise, ends diversion FOOTNOTES, measures footnote
\#   depth, and sets footnote trap.
\# *Notes:
\#   The input line preceding a footnote call MUST terminate with \c
\#   or the footnote marker will be spaced away from the word it
\#   should be joined to.
\#
\#   If FOOTNOTE is invoked with INDENT, the footnote will
\#   be indented.  An indent style and an indent value must be given.
\#   Subsequent footnotes will NOT be indented; INDENT must be given
\#   for each footnote the user wants indented.
\#
.MAC FOOTNOTE END
.    ie '\\$1'' \{\
.       if \\n[#UNDERLINE_ON] \{\
.          UNDERLINE OFF
.          nr #UNDERLINE_WAS_ON_FN 1
.       \}
.       if \\n[#FN_MARKER_STYLE]=3 \{\
.          if !\\n[#LINENUMBERS] \{\
.             tm1 "[mom]: Line numbering must be enabled with NUMBER_LINES when
.             tm1 "       FOOTNOTE_MARKER_STYLE is LINE.
.             ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.          \}
.          if \\n[#FN_MARK]=0 .nr #FN_MARK \\n[ln]
.          nr #FN_MARK_2 \\n[ln]
.          if '\\n[.z]'P_QUOTE' \{\
.             nr #FN_MARK -1
.             nr #FN_MARK_2 -1
.          \}
.          if \\n[#IN_DIVER]=1 \{\
.             if '\\n[.z]'P_QUOTE' \{\
.                if !\\n[#QUOTE_LN]=1 \{\
.                   if !\\n[#SILENT_QUOTE_LN]=1 \{\
.                      tm1 "[mom]: You have requested a line-numbered footnote inside a
.                      tm1 "       QUOTE at line \\n[.c], but line-numbering has not been enabled
.                      tm1 "       for QUOTES.  Printing footnote with label "0".
.                      rr #FN_MARK
.                      rr #FN_MARK_2
.                   \}
.                \}
.             \}
.             if '\\n[.z]'B_QUOTE' \{\
.                if !\\n[#BQUOTE_LN]=1 \{\
.                   if !\\n[#SILENT_BQUOTE_LN]=1 \{\
.                      tm1 "[mom]: You have requested a line-numbered footnote inside a
.                      tm1 "       BLOCKQUOTE at line \\n[.c], but line-numbering has not been enabled
.                      tm1 "       for BLOCKQUOTES.  Printing footnote with label "0".
.                      rr #FN_MARK
.                      rr #FN_MARK_2
.                   \}
.                \}
.             \}
.          \}
.       \}
.\" Begin processing footnotes that occur inside QUOTE, BLOCKQUOTE
.\" or EPIGRAPH.
.       if \\n[#IN_DIVER]=1 \{\
.          nr #PAGE_POS \\n[nl]+\\n[.d]+\\n[#DOC_LEAD]
.          nr #FOOTER_POS \\n[#PAGE_LENGTH]+(\\n[#VARIABLE_FOOTER_POS]-1)
.          nr #SPACE_TO_FOOTER \\n[#FOOTER_POS]-\\n[#PAGE_POS]
.\" Are we on a "defer" line?  If so, defer the text of the footnote.
.          ie \\n[#SPACE_TO_FOOTER]<=\\n[#DOC_LEAD] \
.             nr #DIVER_FN 2 \" treat like a normal deferred footnote
.          el \
.             nr #DIVER_FN 2 \" treat like a normal footnote
.          if \\n[#PAGE_POS]>\\n[#FOOTER_POS] \
.             nr #DIVER_FN 1 \" move this footnote
.\" Test for situation where, because a final line of QUOTE, BLOCKQUOTE
.\" or EPIGRAPH isn't yet adjusted at this point, the last word on the
.\" line may *seem* to belong to the final line of the page, but will,
.\" in fact, become the first word of the subsequent page.  In such
.\" circumstances, we want the the footnote to be treated as a "moved"
.\" diversion footnote.
.          if \\n[.k]>\\n[.l] .nr #DIVER_FN 1
.          if r #DIVER_FN \{\
.             if !\\n[#DIVER_FN]=2 .\\n+[#DONE_ONCE]
.\" A footnote inside a diversion will become the 1st footnote on the
.\" following page/column.
.             if \\n[#DIVER_FN]=1 .DIVER_FN_1_PRE
.\" A footnote inside a diversion that should be treated like a
.\" normal footnote (including defers.)
.             if \\n[#DIVER_FN]=2 .DIVER_FN_2_PRE
.          \}
.          nr #SAVED_FN_COUNT \\n[#FN_COUNT]+1
.          nr #SAVED_FN_COUNT_FOR_COLS \\n[#FN_COUNT_FOR_COLS]+1
.       \}
.\" End processing footnotes that occur inside QUOTE, BLOCKQUOTE or
.\" EPIGRAPH.
.\"
.\" Test for situation where, because a final line of running text
.\" isn't yet adjusted at this point, the last word on the line may
.\" *seem* to belong to the final line of the page, but will, in
.\" fact, become the first word of the subsequent page.  In such
.\" circumstances, we want the footnote marker in running text to
.\" be the correct one for the 1st footnote on the page.
.       if \\n[.k]>\\n[.l] \{\
.          if (\\n[nl]+\\n[#DOC_LEAD])>(\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS]) \{\
.             ie \\n[#COLUMNS]=1 \{\
.                if \\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.                   if \\n[#FN_MARKER_STYLE]=1 .nr #FN_COUNT_FOR_COLS 0 1
.                   if \\n[#FN_MARKER_STYLE]=2 \{\
.                      if \\n[#RESET_FN_NUMBER] \{\
.                         nr #FN_NUMBER 0 1
.                         nr #NOT_YET_ADJUSTED 1
.                      \}
.                   \}
.                \}
.             \}
.             el \{\
.                if \\n[#FN_MARKER_STYLE]=1 .nr #FN_COUNT 0 1
.                if \\n[#FN_MARKER_STYLE]=2 \{\
.                   if \\n[#RESET_FN_NUMBER] \{\
.                      nr #FN_NUMBER 0 1
.                      nr #NOT_YET_ADJUSTED 1
.                   \}
.                \}
.             \}
.          \}
.       \}
.       if \\n[#FN_MARKERS] \{\
.\" Housekeeping
.          if \\n[#CONDENSE] \*[CONDX]\c
.          if \\n[#EXTEND] \*[EXTX]\c
.\" Add footnote markers to running text...
.          if !\\n[#NO_FN_MARKER] \{\
.\" ...but not if TERMINATE has not been called
.             if !r#TERMINATE \{\
.\" Marker style star/dagger/double-dagger
.                if \\n[#FN_MARKER_STYLE]=1 \{\
.\" Columnar docs either move col to col, or last col to next page.
.\" They require their own special FN_COUNT because regular FN_COUNT
.\" is used to figure out things like whether or not to put a rule
.\" above footnotes (in addition to keeping track of the footnote
.\" count in non-columnar docs).
.                   ie \\n[#COLUMNS]=1 \{\
.                      if \\n[#FN_COUNT_FOR_COLS]=0 .PRINT \*[BU2]*\c
.                      if \\n[#FN_COUNT_FOR_COLS]=1 .PRINT \*[BU1]\[dg]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=2 .PRINT \[dd]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=3 .PRINT \*[BU2]**\c
.                      if \\n[#FN_COUNT_FOR_COLS]=4 .PRINT \*[BU1]\[dg]\[dg]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=5 .PRINT \[dd]\[dd]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=6 .PRINT \*[BU2]***\c
.                      if \\n[#FN_COUNT_FOR_COLS]=7 .PRINT \*[BU1]\[dg]\[dg]\[dg]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=8 .PRINT \[dd]\[dd]\[dd]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=9 .PRINT \*[BU2]****\c
.                   \}
.                   el \{\
.                      if \\n[#FN_COUNT]=0 .PRINT \*[BU2]*\c
.                      if \\n[#FN_COUNT]=1 .PRINT \*[BU1]\[dg]\c
.                      if \\n[#FN_COUNT]=2 .PRINT \[dd]\c
.                      if \\n[#FN_COUNT]=3 .PRINT \*[BU2]**\c
.                      if \\n[#FN_COUNT]=4 .PRINT \*[BU1]\[dg]\[dg]\c
.                      if \\n[#FN_COUNT]=5 .PRINT \[dd]\[dd]\c
.                      if \\n[#FN_COUNT]=6 .PRINT \*[BU2]***\c
.                      if \\n[#FN_COUNT]=7 .PRINT \*[BU1]\[dg]\[dg]\[dg]\c
.                      if \\n[#FN_COUNT]=8 .PRINT \[dd]\[dd]\[dd]\c
.                      if \\n[#FN_COUNT]=9 .PRINT \*[BU2]****\c
.                   \}
.                \}
.\" Marker style superscript numbers
.                if \\n[#FN_MARKER_STYLE]=2 \{\
.                   if \\n[#PRINT_STYLE]=1 \
.                      PRINT \
"\s-2\v'-\\n[#DOC_LEAD]u/5u'\\n+[#FN_NUMBER]\v'+\\n[#DOC_LEAD]u/5u'\s+2\c"
.                   if \\n[#PRINT_STYLE]=2 \
.                      PRINT \
"\*[SUP]\\n+[#FN_NUMBER]\*[SUPX]\c"
.                \}
.             \}
.          \}
.       \}
.\" More housekeeping
.\"
.\" #SPACE_REMAINING is the space left between where we are
.\" on the page and the bottom margin.  It's used to determine whether
.\" or not the footnote will overflow, and how many lines of
.\" footnotes will fit on the page if some have to overflow.
.       ie \\n[#DIVER_FN]=2 \
.          nr #SPACE_REMAINING (\\n[#PAGE_LENGTH]-\\n[#B_MARGIN])-(\\n[#PAGE_POS])
.       el \
.          nr #SPACE_REMAINING (\\n[#PAGE_LENGTH]-\\n[#B_MARGIN])-\\n[nl]
.       if \\n[#FROM_DIVERT_FN]=1 \{\
.          nr #SPACE_REMAINING \\n[#PAGE_LENGTH]-\\n[#B_MARGIN]
.          rr #FROM_DIVERT_FN
.       \}
.       nr #PP_STYLE_PREV \\n[#PP_STYLE]
.       nr #PP_STYLE 2
.       if \\n[#INDENT_FIRST_PARAS] .nr #INDENT_FIRSTS 1
.       INDENT_FIRST_PARAS
.\" Prepare FOOTNOTE to receive footnote text.
.       ev FOOTNOTES
.       ll \\n[#DOC_L_LENGTH]u
.       ta \\n[.l]u
.       if \\n[#COLUMNS]=1 \{\
.          ll \\n[#COL_L_LENGTH]u
.          ta \\n[.l]u
.       \}
.       if \\n[#FN_R_INDENT] \{\
.          ll -\\n[#FN_R_INDENT]u
.          ta \\n[.l]u
.       \}
.       if \\n[#FN_BR_INDENT] \{\
.          ll -\\n[#FN_BR_INDENT]u
.          ta \\n[.l]u
.       \}
.       FAMILY   \\*[$FN_FAM]
.       FT       \\*[$FN_FT]
.       ps  \\n[#DOC_PT_SIZE]u\\*[$FN_SIZE_CHANGE]
.       vs \\n[.ps]u+\\n[#FN_AUTOLEAD]u
.       QUAD     \\*[$FN_QUAD]
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          ie \\n[#SINGLE_SPACE] .vs \\n[#ORIGINAL_DOC_LEAD]u
.          el .vs \\n[#ORIGINAL_DOC_LEAD]u/2u
.          QUAD LEFT
.          HY OFF
.       \}
.       nr #FN_LEAD \\n[#LEAD]
.\" Begin diversion FOOTNOTES or FN_IN_DIVER
.       ie r#COUNTERS_RESET \{\
.          ie \\n[#DONE_ONCE]=1 \{\
.             ie \\n[#RUN_ON] \{\
.                di RUNON_FN_IN_DIVER
.                nr #RUNON_FN_IN_DIVER 1
.             \}
.             el .di FN_IN_DIVER
.          \}
.          el \{\
.             ie \\n[#RUN_ON] \{\
.                da RUNON_FN_IN_DIVER
.                nr #RUNON_FN_IN_DIVER 1
.             \}
.             el .da FN_IN_DIVER
.          \}
.       \\n+[#DONE_ONCE]
.       \}
.       el \{\
.          ie \\n[#RUN_ON] \{\
.             da RUNON_FOOTNOTES
.             nr #RUNON_FOOTNOTES 1
.          \}
.          el .da FOOTNOTES
.       \}
.       if \\n[#FOOTNOTE_COLOR]=1 \{\
.          TRAP OFF
.          nf
\m[\\*[$FOOTNOTE_COLOR]]
.          EOL
.          fi
.          TRAP
.       \}
.       if \\n[#EPIGRAPH] .nr #FN_FOR_EPI 1
.\" When a deferred footnote is also the 1st footnote on the page,
.\" and when the page it's output on also has footnotes, some
.\" whitespace is needed between the deferred footnote and the
.\" first footnote belonging to the output page so that there's
.\" no confusion when two stars (or two number 1s) appear in
.\" footnotes...
.       if \\n[#FN_DEFER_SPACE] \{\
.\" ...but only add the extra space if TERMINATE has not been called
.          if !r#TERMINATE \{\
.\" ...and not if defer space has already been added
.             if !\\n[#DEFER_SPACE_ADDED] \{\
.\" ...and not if the footnote count the last time we checked for
.\" a defer situation inside a diversion is greater than 1.
.                if !\\n[#SAVED_DIVER_FN_COUNT]>1 \{\
.                   if \\n[#FN_MARKER_STYLE]=1 .ALD 1v
.                   if \\n[#RESET_FN_NUMBER] .ALD 1v
.                   nr #DEFER_SPACE_ADDED 1
.                \}
.             \}
.          \}
.          rr #FN_DEFER_SPACE
.          rr #SAVED_DIVER_FN_COUNT
.       \}
.       if \\n[#DIVERTED]=3 \{\
.          if \\n[#FN_COUNT]>0 \{\
\!.           RLD 1v
.          \}
.       \}
.\" Add footnote rule (or, if no rule, some whitespace).
.\" N.B.- this line increments #FN_COUNT each and every time FOOTNOTE
.\" is run.
.       if \\n+[#FN_COUNT]=1 \{\
.\" If a footnote is called in a diversion, and the footnote has to
.\" be moved, don't put in the rule now (it's taken care of when
.\" FN_IN_DIVER is output into FOOTNOTE in PROCESS_FN_IN_DIVER).
.          if !\\n[#DONT_RULE_ME]=1 \{\
.             if !\\n[#FN_DEPTH] \{\
.                if \\n[#PRINT_STYLE]=1 \{\
.                   if !\\n[#RUN_ON] .sp \\n[#DOC_LEAD]u
.                \}
.                ie \\n[#FN_RULE]=1 \{\
.                   if !\\n[#RUN_ON] \{\
.                      if \\n[#SINGLE_SPACE] .sp \\n[#DOC_LEAD]u
.                      PRINT_FOOTNOTE_RULE
.                      if !'\\*[$FN_SPACE]'' .sp -\\*[$FN_SPACE]
.                   \}
.                \}
.                el .sp 1v
.                nr #RULED 1
.             \}
.          \}
.       \}
.       rr #DONT_RULE_ME
.       ds $RESTORE_SS_VAR \\*[$SS_VAR]
.       SS 0
.\" Add footnote markers to footnote text...
.       ie \\n[#FN_MARKERS] \{\
.          if !'\\*[$FN_SPACE]'' \{\
.             if \\n[#FN_COUNT]>0 .ALD \\*[$FN_SPACE]
.          \}
.          if !\\n[#NO_FN_MARKER] \{\
.\" ...but not if TERMINATE has been called.
.             if !r#TERMINATE \{\
.                if \\n[#REF]=1 \{\
.                   nr #REF_FN_INDENT (u;\\*[$REF_FN_INDENT])
.                   ti \\n[#REF_FN_INDENT]u
.                \}
.                if \\n[#FN_MARKER_STYLE]=1 \{\
.                   ie \\n[#COLUMNS]=1 \{\
.                      \\n+[#FN_COUNT_FOR_COLS]
.                      if \\n[#FN_COUNT_FOR_COLS]=1 .PRINT *\c
.                      if \\n[#FN_COUNT_FOR_COLS]=2 .PRINT \[dg]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=3 .PRINT \[dd]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=4 .PRINT **\c
.                      if \\n[#FN_COUNT_FOR_COLS]=5 .PRINT \[dg]\[dg]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=6 .PRINT \[dd]\[dd]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=7 .PRINT ***\c
.                      if \\n[#FN_COUNT_FOR_COLS]=8 .PRINT \[dg]\[dg]\[dg]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=9 .PRINT \[dd]\[dd]\[dd]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=10 .PRINT ****\c
.                   \}
.                   el \{\
.                      if \\n[#FN_COUNT]=1 .PRINT *\c
.                      if \\n[#FN_COUNT]=2 .PRINT \[dg]\c
.                      if \\n[#FN_COUNT]=3 .PRINT \[dd]\c
.                      if \\n[#FN_COUNT]=4 .PRINT **\c
.                      if \\n[#FN_COUNT]=5 .PRINT \[dg]\[dg]\c
.                      if \\n[#FN_COUNT]=6 .PRINT \[dd]\[dd]\c
.                      if \\n[#FN_COUNT]=7 .PRINT ***\c
.                      if \\n[#FN_COUNT]=8 .PRINT \[dg]\[dg]\[dg]\c
.                      if \\n[#FN_COUNT]=9 .PRINT \[dd]\[dd]\[dd]\c
.                      if \\n[#FN_COUNT]=10 .PRINT ****\c
.                   \}
.                \}
.                if \\n[#FN_MARKER_STYLE]=2 \{\
.                   ds $FN_NUMBER \\n[#FN_NUMBER]
.                   length #FN_NUMBER_LENGTH \\*[$FN_NUMBER]
.                   if \\n[#COLUMNS]=1 \{\
.                      \\n+[#FN_COUNT_FOR_COLS]
.                   \}
.                   if \\n[#NOT_YET_ADJUSTED]=1 \{\
.                      nr #FN_NUMBER 1 1
.                      rr #NOT_YET_ADJUSTED
.                   \}
.                   if \\n[#PRINT_STYLE]=1 \{\
.                      ie \\n[#NO_SUPERSCRIPT] \{\
.                         ie \\n[#FN_NUMBER_LENGTH]<\\n[#FN_NUMBER_PLACEHOLDERS] \
.                            PRINT "\0(\\n[#FN_NUMBER])\|\c"
.                         el \
.                            PRINT "(\\n[#FN_NUMBER])\|\c"
.                      \}
.                      el \{\
.                         ie \\n[#FN_NUMBER_LENGTH]<\\n[#FN_NUMBER_PLACEHOLDERS] \
.                            PRINT \
"\s-2\v'-\\n[.v]u/5u'\0\\n[#FN_NUMBER]\|\v'+\\n[.v]u/5u'\s+2\|\c"
.                         el \
.                            PRINT \
"\s-2\v'-\\n[.v]u/5u'\\n[#FN_NUMBER]\|\v'+\\n[.v]u/5u'\s+2\|\c"
.                      \}
.                   \}
.                   if \\n[#PRINT_STYLE]=2 \{\
.                      ie \\n[#FN_NUMBER_LENGTH]<\\n[#FN_NUMBER_PLACEHOLDERS] \
.                         PRINT "\*[SUP]\0\\n[#FN_NUMBER]\*[SUPX]\*[FU 3]\c"
.                      el \
.                         PRINT "\*[SUP]\\n[#FN_NUMBER]\*[SUPX]\*[FU 3]\c"
.                   \}
.                \}
.             \}
.          \}
.       \}
.       el \{\
.\" Line-numbered footnotes handling
.          if \\n[#FN_MARKER_STYLE]=3 \{\
.             if \\n[#FN_SPACE]>0 \{\
.                if !\\n[#RUN_ON]=1 \
.                   if \\n[#FN_COUNT]>0 .ALD \\n[#FN_SPACE]u
.             \}
.             if \\n[#REF]=1 \{\
.                if !\\n[#RUN_ON]=1 \{\
\!.                 ti +\\n[#REF_FN_INDENT]u
.                \}
.             \}
.             ie \\n[#FN_LN_BRACKETS]=1 \{\
.                ds $FN_LINENUMBER \v'-.085m'\\*[$FN_OPEN_BRACKET]\v'.085m'
.                ie \\n[#FN_MARK_2]=\\n[#FN_MARK] \
.                   as $FN_LINENUMBER \
\\n[#FN_MARK]\v'-.085m'\\*[$FN_CLOSE_BRACKET]\v'.085m'\h'.25m'
.                el \
.                   as $FN_LINENUMBER \
\\n[#FN_MARK]\v'-.1m'-\v'.1m'\\n[#FN_MARK_2]\v'-.085m'\
\\*[$FN_CLOSE_BRACKET]\v'.085m'\h'.25m'
.             \}
.             el \{\
.                ie \\n[#FN_MARK_2]=\\n[#FN_MARK] \
.                   ds $FN_LINENUMBER \\n[#FN_MARK]\\*[$FN_LN_SEP]
.                el \
.                   ds $FN_LINENUMBER \
\\n[#FN_MARK]\v'-.1m'-\v'.1m'\\n[#FN_MARK_2]\\*[$FN_LN_SEP]
.                \}
.             \}
.             if !\\n[#NO_FN_MARKER] \
.                PRINT \\*[$FN_LINENUMBER]\c
.             rm $FN_LINENUMBER
.             nr #FN_MARK 0
.          \}
.       \}
.    \}
.    el \{\
.\" If INDENT arg is passed to FOOTNOTE, calculate the indent...
.       ie '\\$1'INDENT' \{\
.          ev FOOTNOTES
.          if '\\$2'L' .in (\\$3)
.          if '\\$2'LEFT' .in (\\$3)
.          if '\\$2'R' .nr #FN_R_INDENT (\\$3)
.          if '\\$2'RIGHT' .nr #FN_R_INDENT (\\$3)
.          if '\\$2'B' \{\
.             nr #FN_BL_INDENT (\\$3)
.             ie '\\$4'' .nr #FN_BR_INDENT \\n[#FN_BL_INDENT]
.             el .nr #FN_BR_INDENT (\\$4)
.             in \\n[#FN_BL_INDENT]u
.          \}
.          if '\\$2'BOTH' \{\
.             nr #FN_BL_INDENT (\\$3)
.             ie '\\$4'' .nr #FN_BR_INDENT \\n[#FN_BL_INDENT]
.             el .nr #FN_BR_INDENT (\\$4)
.             in \\n[#FN_BL_INDENT]u
.          \}
.          ev
.\" ...then re-run FOOTNOTE without an argument.
.          FOOTNOTE
.       \}
.       el \{\
.          br
.\" Add "defer space" if the previously diverted footnote was the
.\" 1st footnote proper to its page (i.e. it looks like a deferred
.\" footnote but it's really an overflow).
.          if \\n[#DIVERTED] \{\
.             if \\n[#PREV_FN_DEFERRED]=1 \{\
.                if \\n[#FN_MARKER_STYLE]=1 .ALD \\n[#FN_LEAD]u
.                if \\n[#RESET_FN_NUMBER] .ALD \\n[#FN_LEAD]u
.                nr #PREV_FN_DEFERRED 2
.             \}
.          \}
.          if \\n[#REF]=1 \{\
\!.           in
.          \}
.\" Terminate FOOTNOTES or FN_IN_DIVER diversion
.          di
.          HY_SET 1 \\n[#DIVERSIONS_HY_MARGIN]u (\\n[#PT_SIZE]u/1000u/8u)p
.          hy 14
.\" More housekeeping
.\" Turn off indent possibly set by FOOTNOTE INDENT
.          in 0
.          ev
.          if \\n[#UNDERLINE_WAS_ON_FN] \{\
.             UNDERLINE
.             rr #UNDERLINE_WAS_ON_FN
.          \}
.\" Restore sentence spacing
.          if \\n[#PRINT_STYLE]=2 \{\
.             if d $RESTORE_SS_VAR .SS \\*[$RESTORE_SS_VAR]
.             rm $RESTORE_SS_VAR
.          \}
.          rr #FN_R_INDENT
.          rr #FN_BR_INDENT
.          nr #PP_STYLE \\n[#PP_STYLE_PREV]
.          if !\\n[#INDENT_FIRSTS] .INDENT_FIRST_PARAS OFF
.          rr #INDENT_FIRSTS
.\" Calculate footnote depth, but not if #COUNTERS_RESET (created in
.\" DIVER_FN_1_PRE) to instruct FOOTNOTES to skip this step for now
.\" (it's taken care of when FN_IN_DIVER is output into FOOTNOTES in
.\" PROCESS_FN_IN_DIVER).
.          ie r#COUNTERS_RESET .rr #COUNTERS_RESET
.          el \{\
.             nr #GET_DEPTH 1
.\" If the footnote is the 1st on the page and it falls too close
.\" to the bottom margin, defer the footnote text to the next page...
.             if (\\n[#SPACE_REMAINING]-1)<=(\\n[.v]) \{\
.\" ...but not if PROCESS_FN_LEFTOVER has set #PREV_FN_DEFERRED to 1
.                if !\\n[#PREV_FN_DEFERRED]=1 \{\
.                   nr #FN_DEFER 1
.                   nr #FN_DEPTH +\\n[#DIVER_DEPTH]
.                   rr #GET_DEPTH
.\" This is required so that the defer space clause can distinguish
.\" a real #FN_COUNT=1 from one generated if FOOTNOTE is run inside
.\" QUOTE, BLOCKQUOTE or EPIGRAPH
.                   if \\n[#DIVER_FN]=2 \{\
.                      nr #SAVED_DIVER_FN_COUNT \\n[#FN_COUNT]
.                      rr #DIVER_FN
.                   \}
.                \}
.             \}
.\" Calculate the footnote depth.
.             if \\n[#GET_DEPTH]=1 \{\
.\" Save the previous footnote depth (for use when there will be
.\" some overflowed footnote text).
.                nr #SAVED_FN_DEPTH_1 \\n[#FN_DEPTH]
.\" Add the depth of the current footnote to any already existent
.\" footnotes.
.                nr #FN_DEPTH +\\n[#DIVER_DEPTH]
.\" Special handling for run-on footnotes
.                if \\n[#RUN_ON]=1 \{\
.                   if \\n[#RUNON_FOOTNOTES]   .unformat RUNON_FOOTNOTES
.                   if \\n[#RUNON_FN_IN_DIVER] .unformat RUNON_FN_IN_DIVER
.                   ev FOOTNOTES
.\" Recreate FOOTNOTES with rule followed by text of unformatted
.\" run-on footnotes.
.                   di FOOTNOTES
.                   ie \\n[#FN_RULE]=0 .RLD 1v
.                   el \{\
\v'-\\n[#FN_RULE_ADJ]u-\\n[#FN_RULE_WEIGHT_ADJ]u'\
\D't \\n[#FN_RULE_WEIGHT]'\
\h'-\\n[#FN_RULE_WEIGHT]u'\
\D'l \\n[#FN_RULE_LENGTH]u 0'\
\v'+\\n[#FN_RULE_ADJ]u+\\n[#FN_RULE_WEIGHT_ADJ]u'
.                   \}
.                   br
.                   if \\n[#RUNON_FOOTNOTES] \{\
.                      RUNON_FOOTNOTES
.                      rr #RUNON_FOOTNOTES
.                   \}
.                   if \\n[#RUNON_FN_IN_DIVER] \{\
.                      RUNON_FN_IN_DIVER
.                      rr #RUNON_FN_IN_DIVER
.                   \}
.                   br
.                   di
.                   ev
.                   nr #FN_DEPTH \\n[#DIVER_DEPTH]
.                   nr #SAVED_VFP 0+\\n[#VARIABLE_FOOTER_POS]
.                   nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]u
.                \}
.\" Save the new depth
.                nr #SAVED_FN_DEPTH_2 \\n[#FN_DEPTH]
.\" Signal that defer space should be added when PROCESS_FN_LEFTOVER
.\" processes deferred footnotes.
.                if \\n[#FN_DEFER] \{\
.                   if \\n[#FN_COUNT]=2 \{\
.                      ie \\n[#COLUMNS] \{\
.                         if !\\n[#FROM_FOOTER] \{\
.                            if \\n[#FN_DEFER]=1 .nr #FN_DEFER_SPACE 1
.                            if \\n[#FN_COUNT_FOR_COLS]>=1 .rr #FN_DEFER_SPACE
.                            if \\n[#FROM_HEADER] .nr #FN_DEFER_SPACE 1
.                         \}
.                      \}
.                      el .nr #FN_DEFER_SPACE 1
.                   \}
.                   rr #FN_DEFER
.                \}
.\" If the depth of the whole footnote won't fit in the space
.\" between where we are on the page and the bottom margin, calculate
.\" how much of it will fit.
.                if \\n[#FN_DEPTH]>\\n[#SPACE_REMAINING] \{\
.                   nr #FN_LINES 0 1
.                   while (\\n+[#FN_LINES]*\\n[#FN_LEAD])<\\n[#SPACE_REMAINING] \{\
.                      nr #FN_DEPTH (\\n[#FN_LINES]*\\n[#FN_LEAD])
.                   \}
.                   nr #VFP_DIFF \\n[#FN_DEPTH]-\\n[#SAVED_FN_DEPTH_1]
.                   nr #OVERFLOW 1
.\" Very occasionally, #VFP_DIFF, on a 1st footnote that isn't to
.\" be deferred, comes up with a depth equal to exactly 1 line
.\" of footnotes, i.e. enough room to print the rule and nothing
.\" else.  The following tests for such a condition, and rather than
.\" attempting to treat the footnote as an overflow, it tells mom to
.\" treat it as a special kind of deferred footnote (#FN_DEFER 2).
.                   if \\n[#SAVED_FN_DEPTH_1]=0 \{\
.                      if \\n[#FN_DEPTH]=\\n[#FN_LEAD] \{\
.                         nr #FN_DEFER 2
.                         nr #FN_DEPTH \\n[#SAVED_FN_DEPTH_2]
.                         rr #OVERFLOW
.                      \}
.                   \}
.                \}
.\" Calculate VFP based on whether the footnote overflows, or is to
.\" be treated normally.
.                ie \\n[#OVERFLOW]=1 \{\
.                   if \\n[#RUN_ON] \{\
.                      rr #VARIABLE_FOOTER_POS
.                      nr #VARIABLE_FOOTER_POS \\n[#SAVED_VFP]
.                   \}
.                   ie \\n[#FN_COUNT]=1 \{\
.                      ie \\n[#RULED]=1 \{\
.                         ie \\n[#COLUMNS]=1 \{\
.                            ie \\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.                               ie \\n[#FROM_FOOTER] \{\
.                                  ie \\n[#FN_COUNT_FOR_COLS]>1 \{\
.                                     nr #FN_DEPTH -\\n[#FN_DEPTH]
.                                     if \\n[#DIVERTED]=1 .nr #DIVERTED 3
.                                     if !\\n[#PREV_FN_DEFERRED]=1 \
.                                        nr #FN_DEPTH -\\n[#VFP_DIFF]
.                                  \}
.                                  el \{\
.                                     nr #VARIABLE_FOOTER_POS -\\n[#FN_DEPTH]
.                                     if \\n[#DIVERTED]=1 .nr #DIVERTED 3
.                                  \}
.                               \}
.                               el .nr #VARIABLE_FOOTER_POS -(\\n[#FN_DEPTH])
.                            \}
.                            el .nr #VARIABLE_FOOTER_POS -(\\n[#FN_DEPTH])
.                         \}
.                         el .nr #VARIABLE_FOOTER_POS -(\\n[#FN_DEPTH])
.                      \}
.                      el \{\
.                         nr #VARIABLE_FOOTER_POS -\\n[#VFP_DIFF]
.                         if \\n[#DIVERTED]=1 .nr #DIVERTED 3
.                         if !\\n[#PREV_FN_DEFERRED]=1 \{\
.                            ie \\n[#COLUMNS]=1 \{\
.                               if !\\n[#FROM_FOOTER] .
.                            \}
.                            el .nr #FN_DEPTH -\\n[#VFP_DIFF]
.                         \}
.                         if \\n[#DIVERTED]=3 \{\
.                            if !\\n[#PREV_FN_DEFERRED] \{\
.                               if !\\n[#FROM_FOOTER] \{\
.                                  if \\n[#FN_COUNT]=1 \{\
.                                     if !\\n[#VFP_DIFF] \{\
.                                        if \\n[#FN_MARKER_STYLE]=1 \{\
.                                           da FOOTNOTES
\!.                                            ALD \\n[#FN_LEAD]u
.                                           di
.                                        \}
.                                        if \\n[#RESET_FN_NUMBER] \{\
.                                           da FOOTNOTES
\!.                                            ALD \\n[#FN_LEAD]u
.                                           di
.                                        \}
.                                     \}
.                                  \}
.                               \}
.                            \}
.                         \}
.                      \}
.                      nr #FN_DEPTH \\n[#SAVED_FN_DEPTH_1]+\\n[#VFP_DIFF]
.                   \}
.                   el \{\
.                      nr #VARIABLE_FOOTER_POS -\\n[#VFP_DIFF]
.                      nr #FN_DEPTH \\n[#SAVED_FN_DEPTH_1]+\\n[#VFP_DIFF]
.                   \}
.                   rr #OVERFLOW
.                   rr #RULED
.                \}
.                el \{\
.                   nr #VARIABLE_FOOTER_POS -\\n[#DIVER_DEPTH]
.                   if \\n[#PREV_FN_DEFERRED]=1 \{\
.                      if \\n[#DIVERTED] \{\
.                         if !\\n[#FN_DEPTH]=\\n[#SAVED_FN_DEPTH_1] \{\
.                            nr #FN_DEPTH +\\n[#FN_LEAD]
.                            nr #VARIABLE_FOOTER_POS -\\n[#FN_LEAD]
.                            rr #PREV_FN_DEFERRED
.                         \}
.                      \}
.                   \}
.                   if \\n[#FN_COUNT]>1 \{\
.                      nr #NO_BACK_UP 1
.                      rr #DIVERTED
.                      rr #RULED
.                   \}
.                \}
.             \}
.          \}
.          ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.\" If we have a footnote whose text has to be deferred to the next
.\" page, reset the FOOTER trap to its original location.
.          if \\n[#FN_DEFER] \{\
.             nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]u
.             ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.          \}
.       \}
.       nr #NO_FN_MARKER 0
.    \}
.    if \\n[#NUM_ARGS]=2 \{\
.       if '\\$2'BREAK' .BR
.       if '\\$2'BR' .BR
.    \}
.END
\#
\# Utility macros to manage footnotes that occur inside diversions
\# ---------------------------------------------------------------
\#
\# There are some redundancies here; they're left in in case unforeseen
\# footnote situations crop up in the future that might require
\# manipulation of them.
\#
\# 1. Pre-footnote processing for footnotes in diversions
\#
\# a) A footnote inside a diversion will be moved entirely (marker
\# in running text and text of footnote) to the next page/column.
\#
.MAC DIVER_FN_1_PRE END
.    nr #RESET_FN_COUNTERS 1
.    nr #COUNTERS_RESET 1
.    if \\n[#DONE_ONCE]=1 \{\
.       if \\n[#FN_DEFER] \{\
.          if \\n[#SAVED_DIVER_FN_COUNT]=1 \{\
.             ie \\n[#COLUMNS]=1 \
.                if \\n[#COL_NUM]=\\n[#NUM_COLS] .nr #FN_DEFER_SPACE 1
.             el .nr #FN_DEFER_SPACE 1
.          \}
.       \}
.       if \\n[#FN_MARKER_STYLE]=1 \{\
.          if \\n[#FN_COUNT]>0 .nr #FN_COUNT 0 1
.          if \\n[#COLUMNS]=1 \
.             if \\n[#COL_NUM]=\\n[#NUM_COLS] .nr #FN_COUNT_FOR_COLS 0 1
.       \}
.       if \\n[#FN_MARKER_STYLE]=2 \{\
.          if \\n[#RESET_FN_NUMBER]=1 \{\
.             ie \\n[#COLUMNS]=1 \
.                if \\n[#COL_NUM]=\\n[#NUM_COLS] .nr #FN_NUMBER 0 1
.             el .nr #FN_NUMBER 0 1
.          \}
.       \}
.    \}
.END
\#
\# b) Treat as a normal footnote, including defers.
\#
.MAC DIVER_FN_2_PRE END
.    nr #RESET_FN_COUNTERS 2
.END
\#
\# 2. Post-footnote processing for footnotes in diversions
\#
\# Even when a footnote inside a diversion is treated as
\# "normal," some manipulation of registers is required.  The
\# macro is called in DO_QUOTE (i.e. at the termination of
\# quotes and blockquotes) and in DO_EPIGRAPH.
\#
.MAC DIVER_FN_2_POST END
.    if \\n[#DONE_ONCE]=1 \{\
.       if \\n[#FN_MARKER_STYLE]=1 \{\
.          if \\n[#FN_COUNT]=0 .nr #DONT_RULE_ME 1
.          if \\n[#FN_COUNT]>0 .nr #FN_COUNT 0 1
.          if \\n[#COLUMNS]=1 \{\
.             if \\n[#COL_NUM]=\\n[#NUM_COLS] .nr #FN_COUNT_FOR_COLS 0 1
.             if !\\n[#COL_NUM]=\\n[#NUM_COLS] .
.          \}
.       \}
.       if \\n[#FN_MARKER_STYLE]=2 \{\
.          if \\n[#FN_COUNT]=0 .nr #DONT_RULE_ME 1
.          if \\n[#FN_COUNT]>0 .nr #FN_COUNT 0 1
.          if \\n[#RESET_FN_NUMBER]=1 \{\
.             ie \\n[#COLUMNS]=1 \
.                if \\n[#COL_NUM]=\\n[#NUM_COLS] .nr #FN_NUMBER 0 1
.             el .nr #FN_NUMBER 0 1
.          \}
.       \}
.    \}
.END
\#
\# The main macros that handle footnote processing.
\# -----------------------------------------------
\#
\# FN_OVERFLOW_TRAP starts off "underneath" FOOTER, but is revealed
\# as #VARIABLE_FOOTER_POSITION changes the position of FOOTER.
\# FN_OVERFLOW_TRAP simply starts diversion FN_OVERFLOW to "catch"
\# the overflow.  The diversion is ended in FOOTER, immediately after
\# FOOTER outputs the diversion, FOOTNOTES, before PROCESS_FN_LEFTOVER
\# is run (either in HEADER, or in FOOTER if moving col to col).
\#
.MAC FN_OVERFLOW_TRAP END
.    if \\n[#FN_COUNT] \{\
.       di FN_OVERFLOW
.       ie !\\n[#NO_BACK_UP]=1 \{\
.          if \\n[#PREV_FN_DEFERRED] \{\
.             ie \\n[#COLUMNS]=1 \{\
.                if \\n[#FROM_FOOTER] \{\
.                   if \\n[#PREV_FN_DEFERRED] \{\
.                      if !\\n[#COL_NUM]=\\n[#NUM_COLS] \
.                      rr #PREV_FN_DEFERRED
.                   \}
.                \}
.                if !\\n[#FROM_FOOTER] \{\
.                   if !\\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.                      if !\\n[#LAST_FN_COUNT_FOR_COLS]>1 \{\
\!.                       RLD \\n[#FN_LEAD]u
.                      \}
.                   \}
.                \}
.             \}
.             el \{\
\!.              RLD \\n[#FN_LEAD]u
.             \}
.          \}
.       \}
.       el \{\
.          rr #NO_BACK_UP
.          rr #PREV_FN_DEFERRED
.       \}
.    \}
.\" When #FROM_DIVERT_FN is 1, it signals to FOOTNOTE, when run from
.\" within DIVERT_FN_LEFTOVER, to set #SPACE_REMAINING to the total
.\" area allowable for running text.
\#.    nr #FROM_DIVERT_FN 1
.END
\#
\# PROCESS_FN_LEFTOVER is called at the top of HEADER, and in
\# FOOTER if we're moving from one column to the next (i.e. after
\# outputting FOOTNOTES).  It checks for whether we have a "deferred
\# footnote" situation, and resets counters and number registers
\# accordingly.  Lastly, if we have some footnote overflow, it calls
\# DIVERT_FN_OVERFLOW.
\#
.MAC PROCESS_FN_LEFTOVER END
.    if \\n[#PREV_FN_DEFERRED]=2 \
.       if \\n[#FN_COUNT_AT_FOOTER]>1 .rr #PREV_FN_DEFERRED
.    ie !\\n[#FN_DEFER] \{\
.       nr #FN_COUNT 0 1
.       nr #FN_DEPTH 0
.       nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]
.    \}
.    el \{\
.       if \\n[#FN_DEFER]=1 .nr #VARIABLE_FOOTER_POS -\\n[#FN_DEPTH]
.       if \\n[#FN_DEFER]=2 \{\
.          nr #FN_DEPTH 0
.          nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]
.       \}
.    \}
.    nr #SPACE_REMAINING 0
.    ch FOOTER -\\n[#B_MARGIN]u
.    if \\n[#FN_DEFER] \{\
.       nr #NO_FN_MARKER 1
.       FOOTNOTE
.       nf
.       FOOTNOTE OFF
.       ie \\n[#COLUMNS]=1 \{\
.          if \\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.             if !\\n[#FROM_FOOTER] \{\
.                if \\n[#FN_COUNT_FOR_COLS]=1 .nr #PREV_FN_DEFERRED 1
.             \}
.          \}
.       \}
.       el .nr #PREV_FN_DEFERRED 1
.    \}
.    if !\\n[#FN_DEFER] \
.       if \\n[#FN_OVERFLOW_DEPTH] .DIVERT_FN_LEFTOVER
.    ie \\n[#COLUMNS]=1 \{\
.       if \\n[#COL_NUM]>1 \
.          if \\n[#COL_NUM]=\\n[#NUM_COLS] .nr #FN_COUNT 0 1
.    \}
.    el .nr #FN_COUNT 0 1
.    if \\n[#DIVER_FN]=2 .rr #DIVER_FN
.    rr #FROM_DIVERT_FN
.END
\#
\# DIVERT_FN_LEFTOVER is called in PROCESS_FN_LEFTOVER (at
\# the top of HEADER, and in FOOTER if we're moving from one column
\# to the next).
\#
.MAC DIVERT_FN_LEFTOVER END
.    nr #NO_FN_MARKER 1
.    nr #DIVERTED 1
.    FOOTNOTE
.    nf
.    FN_OVERFLOW
.    FOOTNOTE OFF
.    if \\n[#PREV_FN_DEFERRED] \{\
.       nr #FN_DEPTH -\\n[#FN_LEAD]
.       nr #VARIABLE_FOOTER_POS +\\n[#FN_LEAD]
.       ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.       if \\n[#PREV_FN_DEFERRED]=2 \{\
.          nr #PREV_FN_DEFERRED 1
.          rr #DIVERTED
.       \}
.    \}
.    rr #FN_OVERFLOW_DEPTH
.END
\#
\# This is a special macro to deal with footnotes that are set inside
\# diversions (QUOTE, BLOCKQUOTE and EPIGRAPH).  It's called in HEADER
\# (and in FOOTER, if we're moving from column to column), and comes
\# after PROCESS_FOOTNOTE_LEFTOVER in those two macros.
\#
.MAC PROCESS_FN_IN_DIVER END
.    nr #SPACE_REMAINING 0
.    ch FOOTER -\\n[#B_MARGIN]u
.    nr #NO_FN_MARKER 1
.    if !\\n[#RESET_FN_COUNTERS]=2 .rr #RESET_FN_COUNTERS
.    FOOTNOTE
.    if \\n[#FN_OVERFLOW_DEPTH] .nf
.    ie dRUNON_FN_IN_DIVER \{\
.       RUNON_FN_IN_DIVER
.       rm RUNON_FN_IN_DIVER
.    \}
.    el \{\
.       nf
.       FN_IN_DIVER
.    \}
.    FOOTNOTE OFF
.    rr #DIVER_FN
.END
\#
\# ====================================================================
\#
\# +++ENDNOTES+++
\#
\# When endnotes are output, the spacing between the notes is always
\# 1 extra linespace.  This can have bottom margin consequences.  If
\# this doesn't bother you, don't worry about it.  If it does bother
\# you, and you want to adjust the spacing between any two endnotes (as
\# they're output), make the spacing adjustments (.ALD/.RLD) at the
\# *end* of endnotes (i.e. just before .ENDNOTE OFF), not at the top.
\#
\# Endnotes must be output manually with .ENDNOTES. This allows user
\# the flexibility to output endnotes at the end of each collated
\# document, or to output them at the end of the entire document.
\#
\# Control macros
\# --------------
\#
\# ENDNOTE POINT SIZE
\# ------------------
\# *Argument:
\#   <base point size for endnotes>
\# *Function:
\#   Creates or modifies register #EN_PS.
\# *Notes:
\#   Default is same as running text in body of document.
\#
\#   This size control macro differs from other size control macros
\#   in that it sets an absolute point size, not a relative one.  This
\#   is because a) endnotes always appear separate from the body of
\#   a document and therefore don't need to be relative to the body
\#   of the document, and b) there are quite a few elements of the
\#   endnotes page(s) that need to be relative to the base point size
\#   of that page.  If the base endnote point size were relative to
\#   the body of the document (i.e. a _SIZE macro taking a +|- value)
\#   getting the rest of the endnote elements sized properly could
\#   become very confusing.
\#
.MAC ENDNOTE_PT_SIZE END
.    nr #EN_PS (p;\\$1)
.END
\#
\# ENDNOTES, BIBLIOGRAPHY and TOC LEADING
\# --------------------------------------
\# *Argument:
\#   <leading> [ ADJUST ]
\# *Function:
\#   Depending on the name by which it's called, creates or modifies
\#   register #<type>_LEAD, where <type> is BIB, EN, or TOC.  Creates or removes
\#   register #ADJ_<type>_LEAD.  Stores arguments in strings if BIB,
\#   EN, or TOC leading are set before START.
\# *Notes:
\#   Default is same as doc lead for TYPESET, adjusted; 24 for TYPEWRITE.
\#
.MAC _LEAD END
.    if '\\$0'BIBLIOGRAPHY_LEAD' .ds $SECTION BIB
.    if '\\$0'ENDNOTE_LEAD' .ds $SECTION EN
.    if '\\$0'TOC_LEAD' .ds $SECTION TOC
.    ds $\\*[$SECTION]_LEAD \\$1
.    ds $ADJUST_\\*[$SECTION]_LEAD \\$2
.    if !\\n[#OK_PROCESS_LEAD] .return
.    nr #\\*[$SECTION]_LEAD (p;\\$1)
.    rr #ADJ_\\*[$SECTION]_LEAD
.    als \\*[$SECTION]_LEAD DOC_LEAD
.    if '\\$2'ADJUST' \{\
.       nr #ORIG_DOC_LEAD \\n[#UNADJUSTED_DOC_LEAD]
.       nr #RESTORE_ADJ_DOC_LEAD \\n[#ADJ_DOC_LEAD]
.       nr #ADJ_DOC_LEAD 1
.       nr #ADJ_\\*[$SECTION]_LEAD 1
.       nr #NO_TRAP_RESET 1
.       \\*[$SECTION]_LEAD \\n[#\\*[$SECTION]_LEAD]u ADJUST
.       nr #\\*[$SECTION]_LEAD \\n[#DOC_LEAD]
.       DOC_LEAD \\n[#ORIG_DOC_LEAD]u
.       rr #NO_TRAP_RESET
.       nr #ADJ_DOC_LEAD \\n[#RESTORE_ADJ_DOC_LEAD]
.       rr #ORIG_DOC_LEAD
.    \}
.END
\#
.ALIAS BIBLIOGRAPHY_LEAD _LEAD
.ALIAS ENDNOTE_LEAD _LEAD
.ALIAS TOC_LEAD _LEAD
\#
\# ENDNOTE SPACING
\# ----------------
\# *Arguments:
\#   <per item endnote spacing> | <anything>
\# *Function:
\#   Enables space between endnotes items.
\# *Notes:
\#   Default is no space.
\#
.MAC ENDNOTE_SPACING END
.    ie \B'\\$1' .ds $EN_SPACE \\$1
.    el .rm $EN_SPACE
.END
\#
\# ENDNOTES_HDRFTR_CENTER
\# ----------------------
\# *Argument:
\#   toggle
\# *Function:
\#   Creates or removes toggle register #EN_HDRFTR_CENTER, used to
\#   determine whether mom should print a/the hdrftr center string
\#   on the endnotes page.  Primarily to enable/disable printing of the
\#   chapter name in hdrftrs when DOCTYPE CHAPTER.
\# *Notes:
\#   Default is OFF
\#
.MAC ENDNOTES_HDRFTR_CENTER END
.    ie '\\$1'' .nr #EN_HDRFTR_CENTER 1
.    el .rr #EN_HDRFTR_CENTER
.END
\#
\# ENDNOTE STRING
\# --------------
\# *Argument:
\#   <title for endnotes page>
\# *Function:
\#   Creates or modifies string $EN_STRING.
\# *Notes:
\#   Default is "Endnotes"
\#
.MAC ENDNOTE_STRING END
.    ds $EN_STRING \\$1
.END
\#
.MAC ENDNOTE_STRING_ADVANCE END
.    nr #EN_STRING_ADVANCE (\\$1)
.END
\#
\# ENDNOTE STRING CAPS
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalization of the endnotes pages title string
\#   "Endnotes" on or off.
\# *Notes:
\#   Users may want the endnotes pages title string to be in caps,
\#   but the toc entry for endnotes in lower case.  If the argument
\#   to ENDNOTE_STRING is in lower case and ENDNOTE_STRING_CAPS is
\#   turned on, this is exactly what will happen.
\#
\#   Default is on.
\#
.MAC ENDNOTE_STRING_CAPS END
.   ie '\\$1'' .nr #EN_STRING_CAPS 1
.   el .nr #EN_STRING_CAPS 0
.END
\#
\# ENDNOTE TITLE
\# -------------
\# *Argument:
\#   <string that appears before the first endnote pertaining to any document>
\# *Function:
\#   Creates string $EN_TITLE.
\# *Notes:
\#   Default is the document title, or, if doc is a chapter, "Chapter #"
\#
.MAC ENDNOTE_TITLE END
.    ds $EN_TITLE \\$1
.END
\#
\# ENDNOTE MARKER STYLE
\# --------------------
\# *Arguments:
\#   NUMBER | LINE | SUPERSCRIPT
\# *Function:
\#   Sets register #EN_MARKER_STYLE, used in ENDNOTE to determine
\#   the style of endnote markers (labels).
\# *Notes:
\#   1=NUMBER; 2=LINE.  LINE means "use output line numbers".
\#   Default is NUMBER.
\#
.MAC ENDNOTE_MARKER_STYLE END
.    if '\\$1'NUMBER' .nr #EN_MARKER_STYLE 1
.    if '\\$1'LINE' \{\
.       nr #EN_MARKER_STYLE 2
.       if !\\n[#EN_LN_SEP] \
.          if !\\n[#EN_LN_BRACKETS] .ENDNOTE_LINENUMBER_BRACKETS SQUARE
.    \}
.    if '\\$1'SUPERSCRIPT' .nr #EN_MARKER_STYLE 3
.END
\#
\# ENDNOTE LINENUMBER MARK
\# -----------------------
\# *Function:
\#   This string, when called inline, stores the current output line
\#   number in register #EN_MARK for use with ENDNOTE.
\#
.ds EN_MARK \R'#EN_MARK \En[ln]'
\#
\# ENDNOTE LINENUMBER SEPARATOR
\# ----------------------------
\# *Argument:
\#   <user-defined separator>
\# *Function:
\#   Stores user-defined separator (for use then
\#   ENDNOTE_MARKER_STYLE is LINE) in string $EN_LN_SEP.  The
\#   separator is intended to be used when the user wishes a
\#   separator, rather than the choice of brackets offered by
\#   ENDNOTE_LINENUMBER_BRACKETS.
\#
.MAC ENDNOTE_LINENUMBER_SEPARATOR END
.    rr #EN_LN_BRACKETS
.    nr #EN_LN_SEP 1
.    ds $EN_LN_SEP "\\$1
.END
\#
\# ENDNOTE LINENUMBER BRACKETS
\# ---------------------------
\# *Argument:
\#   PARENS | SQUARE | BRACES or ( | [ | {
\# *Function:
\#   Sets register #EN_LN_BRACKETS to 1, and creates strings
\#   $EN_OPEN_BRACKET and $EN_CLOSE_BRACKET according to the given argument.
\#
.MAC ENDNOTE_LINENUMBER_BRACKETS END
.    rr #EN_LN_SEP
.    nr #EN_LN_BRACKETS 1
.    if '\\$1'PARENS' \{\
.       ds $EN_OPEN_BRACKET (
.       ds $EN_CLOSE_BRACKET )
.    \}
.    if '\\$1'(' \{\
.       ds $EN_OPEN_BRACKET (
.       ds $EN_CLOSE_BRACKET )
.    \}
.    if '\\$1'SQUARE' \{\
.       ds $EN_OPEN_BRACKET [
.       ds $EN_CLOSE_BRACKET ]
.    \}
.    if '\\$1'[' \{\
.       ds $EN_OPEN_BRACKET [
.       ds $EN_CLOSE_BRACKET ]
.    \}
.    if '\\$1'BRACES' \{\
.       ds $EN_OPEN_BRACKET {
.       ds $EN_CLOSE_BRACKET }
.    \}
.    if '\\$1'{' \{\
.       ds $EN_OPEN_BRACKET {
.       ds $EN_CLOSE_BRACKET }
.    \}
.END
\#
\# ENDNOTE LINENUMBER GAP
\# ----------------------
\# *Argument:
\#   <space between line-number labels and endnotes text>
\# *Function:
\#   Defines string $EN_LN_GAP, used during printing of line-number
\#   labels in ENDNOTE.
\#
.MAC ENDNOTE_LINENUMBER_GAP END
.    nr #EN_LN_GAP (u;\\$1)
.END
\#
\# ENDNOTE NUMBERS ALIGNMENT
\# -------------------------
\# *Argument:
\#   LEFT | RIGHT <max. number of digit placeholders that will appear in endnotes>
\# *Function:
\#   Creates registers for _LEFT or _RIGHT; creates register
\#   #EN_NUMBER_PLACEHOLDERS.
\# *Notes:
\#   Default is for endnote numbers to be right aligned to 2 placeholders.
\#
.MAC ENDNOTE_NUMBERS_ALIGN END
.    if '\\$1'LEFT' \{\
.       rr #EN_NUMBERS_ALIGN_RIGHT
.       nr #EN_NUMBERS_ALIGN_LEFT 1
.    \}
.    if '\\$1'RIGHT' \{\
.       rr #EN_NUMBERS_ALIGN_LEFT
.       nr #EN_NUMBERS_ALIGN_RIGHT 1
.    \}
.    nr #EN_NUMBER_PLACEHOLDERS \\$2
.END
\#
\# ENDNOTE PARAGRAPH INDENT
\# ------------------------
\# *Argument:
\#   <first line indent of paras subsequent to 1st in endnotes>
\# *Function:
\#   Creates register #EN_PP_INDENT for use in .PP.
\# *Notes:
\#   Requires a unit of measure.
\#
\#   Default is 1.5m for TYPESET; same indent as PARA_INDENT for TYPEWRITE.
\#
.MAC ENDNOTE_PARA_INDENT END
.    nr #EN_PP_INDENT (\\$1)
.END
\#
\# TURN OFF COLUMN MODE FOR ENDNOTES
\# ---------------------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #EN_NO_COLS
\# *Notes:
\#   Allows user to tell mom not to set endnotes in columnar
\#   documents in columns.  Default is to set endnotes in columns.
\#
.MAC ENDNOTES_NO_COLUMNS END
.    ie '\\$1'' .nr #EN_NO_COLS 1
.    el .rr #EN_NO_COLS
.END
\#
\# NO FIRST PAGE NUMBER ON ENDNOTES FIRST PAGE
\# -------------------------------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #EN_NO_FIRST_PN
\# *Notes:
\#   For use if FOOTERS are on.  Tells ENDNOTES not to put a page
\#   number on the first endnotes page.  Some users may want this.
\#   Default is to print a page number at the top of the first
\#   endnotes page when footers are on.
\#
.MAC ENDNOTES_NO_FIRST_PAGENUM END
.    ie '\\$1'' .nr #EN_NO_FIRST_PN 1
.    el .rr #EN_NO_FIRST_PN
.END
\#
\# PAGE HEADERS ON ENDNOTES PAGES
\# ------------------------------
\# *Argument:
\#   <none> | ALL
\# *Function:
\#   Creates or removes register #EN_ALLOWS_HEADERS or
\#   #EN_ALLOWS_HEADERS_ALL
\# *Notes:
\#   Whether ENDNOTES puts a page header at the top of endnotes
\#   pages if page headers are used throughout the document.
\#   Default is to insert the page headers, but not on the first
\#   page.  If the optional argument ALL is given, ENDNOTES puts a
\#   page header on the first page as well.
\#
.MAC ENDNOTES_ALLOWS_HEADERS END
.    ie '\\$1'' .nr #EN_ALLOWS_HEADERS 1
.    el \{\
.       ie '\\$1'ALL' \{\
.          nr #EN_ALLOWS_HEADERS 1
.          nr #EN_ALLOWS_HEADERS_ALL 1
.       \}
.       el \{\
.          nr #EN_ALLOWS_HEADERS 0
.          nr #EN_ALLOWS_HEADERS_ALL 0
.       \}
.    \}
.END
\#
\# ENDNOTES PAGES PAGE NUMBERING STYLE
\# -----------------------------------
\# *Argument:
\#   DIGIT | ROMAN | roman | ALPHA | alpha
\# *Function:
\#   Creates or modifies $EN_PN_STYLE.
\# *Notes:
\#   Allows user to define what style should be used for endnotes
\#   pages page numbering.  Arguments are the same as for
\#   PAGENUM_STYLE.
\#
\#   Default is DIGIT.
\#
.MAC ENDNOTES_PAGENUM_STYLE END
.    ds $EN_PN_STYLE \\$1
.END
\#
\# FIRST PAGE NUMBER FOR ENDNOTES
\# ------------------------------
\# *Argument:
\#   <page number that appears on page 1 of endnotes pages>
\# *Function:
\#   Creates or modifies string $EN_FIRST_PN
\# *Notes:
\#   To be used with caution, only if all endnotes
\#   are to be output at once, i.e. not at the end of the separate
\#   docs of a collated doc
\#
.MAC ENDNOTES_FIRST_PAGENUMBER END
.    nr #EN_FIRST_PN \\$1
.END
\#
\# SINGLESPACE ENDNOTES
\# --------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Sets lead of endnotes pages in TYPEWRITE to 12 points,
\#   adjusted.
\# *Notes:
\#   Default is to double-space endnotes pages.
\#
.MAC SINGLESPACE_ENDNOTES END
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#SINGLE_SPACE] \{\
.          nr #EN_SINGLESPACE 1
.          rr #IGNORE
.          if \\n[#OK_PROCESS_LEAD] \{\
.             ENDNOTE_LEAD 12 ADJUST
.             nr #IGNORE 1
.          \}
.       \}
.       el \{\
.          ie '\\$1'' \{\
.             nr #EN_SINGLESPACE 1
.             rr #IGNORE
.             if \\n[#OK_PROCESS_LEAD] \{\
.                ENDNOTE_LEAD 12 ADJUST
.                nr #IGNORE 1
.             \}
.          \}
.          el \{\
.             rr #EN_SINGLESPACE
.             rr #IGNORE
.             if \\n[#OK_PROCESS_LEAD] \{\
.                ENDNOTE_LEAD 24 ADJUST
.                nr #IGNORE 1
.             \}
.          \}
.       \}
.    \}
.END
\#
\# ENDNOTE PARAGRAPH SPACE
\# -----------------------
\# *Argument:
\#   toggle
\# *Function:
\#   Creates toggle register #EN_PP_SPACE for use in .PP.
\# *Notes:
\#   Like PARA_SPACE.  Default is not to space endnote paras.
\#
.MAC ENDNOTE_PARA_SPACE END
.    ie '\\$1'' .nr #EN_PP_SPACE 1
.    el .rr #EN_PP_SPACE
.END
\#
\# ENDNOTE
\# -------
\# *Argument:
\#   toggle
\# *Function:
\#   Places superscript endnote number in text, then collects and
\#   processes endnote in diversion END_NOTES.
\# *Notes:
\#   \c must be appended to the word immediately preceding .ENDNOTE
\#   when ENDNOTE_MARKER_STYLE is NUMBER.
\#
.MAC ENDNOTE END
.    ie '\\$1'' \{\
.       nr #ENDNOTE 1
.       ie !\\n[#EN_MARKER_STYLE]=2 \{\
.          if \\n[#CONDENSE] .nop \*[CONDX]\c
.          if \\n[#EXTEND] .nop \*[EXTX]\c
.             if \\n[#UNDERLINE_ON] \{\
.                nr #UNDERLINE_WAS_ON 1
.                UNDERLINE OFF
.             \}
.          if \\n[#PRINT_STYLE]=1 \{\
.             if \\n[#SLANT_ON] \{\
.                 nr #SLANT_WAS_ON 1
.                 nop \*[SLANTX]\c
.             \}
.\" Vertical raise amount here is more than when the same string is printed in
.\" the endnotes so bottom of number aligns with top of bowl.
.             PRINT \
"\s-2\v'-\\n[#DOC_LEAD]u/5u'\\n+[#EN_NUMBER]\v'+\\n[#DOC_LEAD]u/5u'\s+2\c"
.          \}
.          if \\n[#PRINT_STYLE]=2 .PRINT \*[SUP]\\n+[#EN_NUMBER]\*[SUPX]\c
.       \}
.       el \{\
.          ie r#EN_NUMBER .nr #EN_NUMBER \\n[#EN_NUMBER]+1
.          el .nr #EN_NUMBER 1 1
.          if !\\n[#LINENUMBERS] \{\
.             tm1 "[mom]: Line numbering must be enabled with NUMBER_LINES when
.             tm1 "       ENDNOTE_MARKER_STYLE is LINE.
.             ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.          \}
.          if \\n[#EN_MARK]=0 .nr #EN_MARK \\n[ln]
.          nr #EN_MARK_2 \\n[ln]
.          if '\\n[.z]'P_QUOTE' \{\
.             nr #EN_MARK -1
.             nr #EN_MARK_2 -1
.          \}
.       \}
.       nr #PP_STYLE_PREV \\n[#PP_STYLE]
.       nr #PP_STYLE 1
.       if \\n[#INDENT_FIRST_PARAS] .nr #INDENT_FIRSTS 1
.       INDENT_FIRST_PARAS
.       ev EN
.       da END_NOTES
.       LL \\n[#DOC_L_LENGTH]u
.       ta \\n[.l]u
.       if \\n[#COLUMNS] \{\
.          ie \\n[#EN_NO_COLS] .LL \\n[#DOC_L_LENGTH]u
.          el .LL \\n[#COL_L_LENGTH]u
.          ta \\n[.l]u
.       \}
\!.     if \\\\n[.vpt]=0 .vpt
\!.     ne 3
.       vs \\n[#EN_LEAD]u
.\" Print identifying doc title (eg Chapter n)
.       if \\n[#EN_NUMBER]=1 \{\
.          if \\n[#PRINT_STYLE]=1 .TYPEWRITER
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY  \\*[$EN_TITLE_FAM]
.             FT      \\*[$EN_TITLE_FT]
.             ps \\n[#EN_PS]u\\*[$EN_TITLE_SIZE_CHANGE]
.          \}
.          sp
.          if !'\\*[$EN_TITLE]'' \{\
.             if '\\*[$EN_TITLE_QUAD]'L'      .LEFT
.             if '\\*[$EN_TITLE_QUAD]'LEFT'   .LEFT
.             if '\\*[$EN_TITLE_QUAD]'C'      .CENTER
.             if '\\*[$EN_TITLE_QUAD]'CENTER' .CENTER
.             if '\\*[$EN_TITLE_QUAD]'CENTRE' .CENTER
.             if '\\*[$EN_TITLE_QUAD]'R'      .RIGHT
.             if '\\*[$EN_TITLE_QUAD]'RIGHT'  .RIGHT
.             ie \\n[#EN_TITLE_UNDERLINE] \{\
.                nr #FROM_EN_TITLE 1
.                UNDERSCORE "\\*[$EN_TITLE]"
.                rr #FROM_EN_TITLE
.             \}
.             el .PRINT "\\*[$EN_TITLE]"
.          \}
.       \}
.\" Get indent from endnotes point size; convert string to reg in
.\" case indent string is, e.g., m or n
.       ps \\n[#EN_PS]u
.       nr #REF_EN_INDENT (u;\\*[$REF_EN_INDENT])
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          if \\n[#EN_NUMBER]=1 .sp
.          if \\n[#EN_MARKER_STYLE]=3 .ps -2
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          if \\n[#EN_NUMBER]=1 \
.             if !'\\*[$EN_TITLE]'' .sp .5v
.          if \\n[#EN_MARKER_STYLE]=1 \{\
.             FAMILY  \\*[$EN_NUMBER_FAM]
.             FT      \\*[$EN_NUMBER_FT]
.             ps \\n[#EN_PS]u\\*[$EN_NUMBER_SIZE_CHANGE]
.          \}
.          if \\n[#EN_MARKER_STYLE]=2 \{\
.             FAMILY  \\*[$EN_LN_FAM]
.             FT      \\*[$EN_LN_FT]
.             ps \\n[#EN_PS]u\\*[$EN_LN_SIZE_CHANGE]
.          \}
.          if \\n[#EN_MARKER_STYLE]=3 \{\
.             FAMILY  \\*[$EN_NUMBER_FAM]
.             FT      \\*[$EN_NUMBER_FT]
.             ps \\n[#PT_SIZE_IN_UNITS]u*6u/10u
.          \}
.       \}
.\" Build string for line-numbered endnotes
.       if \\n[#EN_MARKER_STYLE]=2 \{\
.          ie \\n[#EN_LN_BRACKETS]=1 \{\
.             ds $EN_LINENUMBER \v'-.085m'\\*[$EN_OPEN_BRACKET]\v'.085m'
.             ie \\n[#EN_MARK_2]=\\n[#EN_MARK] .as $EN_LINENUMBER \
\\n[#EN_MARK]\v'-.085m'\\*[$EN_CLOSE_BRACKET]\v'.085m'\"
.             el .as $EN_LINENUMBER \
\\n[#EN_MARK]\v'-.1m'-\v'.1m'\\n[#EN_MARK_2]\v'-.085m'\
\\*[$EN_CLOSE_BRACKET]\v'.085m'\"
.          \}
.          el \{\
.             ie \\n[#EN_MARK_2]=\\n[#EN_MARK] \
.                ds $EN_LINENUMBER \
\\n[#EN_MARK]\\*[$EN_LN_SEP]
.             el \
.                ds $EN_LINENUMBER \
\\n[#EN_MARK]\v'-.1m'-\v'.1m'\\n[#EN_MARK_2]\\*[$EN_LN_SEP]
.          \}
.          nr #EN_MARK 0
.       \}
.       vpt 0
.       ie \\n[#EN_NUMBERS_ALIGN_RIGHT] .RIGHT
.       el .LEFT
.       if \\n[#EN_MARKER_STYLE]=1 \
.          nr #EN_NUMBER_L_LENGTH \w'\0'*\\n[#EN_NUMBER_PLACEHOLDERS]+\w'.'
.       if \\n[#EN_MARKER_STYLE]=2 \{\
.          ie \\n[#EN_LN_BRACKETS]=1 .nr #EN_NUMBER_L_LENGTH \
(\w'\0'*(\\n[#EN_NUMBER_PLACEHOLDERS]*2))+\w'-[]'
.          el .nr #EN_NUMBER_L_LENGTH \
(\w'\0'*(\\n[#EN_NUMBER_PLACEHOLDERS]*2))+\w'-\\*[$EN_LN_SEP]'
.          RIGHT
.       \}
.       if \\n[#EN_MARKER_STYLE]=3 \{\
.          nr #EN_NUMBER_L_LENGTH \
\w'\0'*\\n[#EN_NUMBER_PLACEHOLDERS]+.15m
.          RIGHT
.       \}
.       ie \\n[#REF]=1 \
.          ll \\n[#EN_NUMBER_L_LENGTH]u+\\n[#REF_EN_INDENT]u
.       el .ll \\n[#EN_NUMBER_L_LENGTH]u
.       if \\n[#EN_MARKER_STYLE]=1 \{\
.          if \\n[#REF]=1 .ti \\n[#REF_EN_INDENT]u
.          nop \En[#EN_NUMBER].
.       \}
.       if \\n[#EN_MARKER_STYLE]=2 \{\
.          nop \\*[$EN_LINENUMBER]
.          rm $EN_LINENUMBER
.       \}
.       if \\n[#EN_MARKER_STYLE]=3 \{\
.          ps \" Reset ps changed to get width of s-script numbers
.          ie \\n[#PRINT_STYLE]=1 \{\
.\" Vertical raise amount here is less than when the same string is printed in
.\" the body of the text because number precedes a cap.
.             nop \
\s-2\v'-\\n[#DOC_LEAD]u/7u'\\n[#EN_NUMBER]\|\v'+\\n[#DOC_LEAD]u/7u'\s+2
.          \}
.          el .nop \E*[SUP]\\n[#EN_NUMBER]\E*[SUPX]\h'.15m'
.       \}
.       EOL
.       ll
.       nr #EN_FIGURE_SPACE \w'\0'
.       if \\n[#EN_MARKER_STYLE]=1 \{\
.          ie \\n[#REF]=1 .ti \
\\n[#EN_NUMBER_L_LENGTH]u+\\n[#REF_EN_INDENT]u+\\n[#EN_FIGURE_SPACE]u
.          el .in \
\\n[#EN_NUMBER_L_LENGTH]u+\\n[#EN_FIGURE_SPACE]u
.       \}
.       if \\n[#EN_MARKER_STYLE]=2 \{\
.          ie \\n[#REF]=1 .ti \
\\n[#EN_NUMBER_L_LENGTH]u+\\n[#REF_EN_INDENT]u+\\n[#EN_LN_GAP]u
.          el .ti \
\\n[#EN_NUMBER_L_LENGTH]u+\\n[#EN_LN_GAP]u
.       \}
.       if \\n[#EN_MARKER_STYLE]=3 \{\
.          ie \\n[#REF]=1 .ti \
\\n[#EN_NUMBER_L_LENGTH]u+\\n[#REF_EN_INDENT]u+\w'\|'u
.          el .in \
\\n[#EN_NUMBER_L_LENGTH]u
.       \}
.       nr #EN_TEXT_INDENT \\n[.i]
.       QUAD \\*[$EN_QUAD]
.       vpt 1
.       if \\n[#PRINT_STYLE]=1 .TYPEWRITER
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY  \\*[$EN_FAM]
.          FT      \\*[$EN_FT]
.          ps \\n[#EN_PS]u
.       \}
.    \}
.    el \{\
\!.     ie \\n[#EN_NUMBER]=\\\\n[#LAST_EN] .vpt 0
\!.     el .br
.       if \\n[#PRINT_STYLE]=2 .sp \\*[$EN_SPACE]
.       in 0
.       if \\n[#EN_MARKER_STYLE]=2 \{\
\!.        in 0
.       \}
.       da
.\" Restore sentence spacing
.       if \\n[#PRINT_STYLE]=2 \{\
.          if d$RESTORE_SS_VAR .SS \\*[$RESTORE_SS_VAR]
.          rm $RESTORE_SS_VAR
.       \}
.       ev
.\" Restore lead -- need
.       nr #PP_STYLE \\n[#PP_STYLE_PREV]
.       if !\\n[#INDENT_FIRSTS] .INDENT_FIRST_PARAS OFF
.       rr #INDENT_FIRSTS
.       rr #ENDNOTE
.       if \\n[#UNDERLINE_WAS_ON] \{\
.          rr #UNDERLINE_WAS_ON
.          UNDERLINE
.       \}
.       if \\n[#SLANT_WAS_ON] \{\
.          rr #SLANT_WAS_ON
\*[SLANT]\c
.       \}
.    \}
.    if \\n[#NUM_ARGS]=2 \{\
.       if '\\$2'BREAK' .BR
.       if '\\$2'BR' .BR
.    \}
.END
\#
\# ENDNOTES
\# --------
\# *Arguments:
\#   none
\# *Function:
\#   Sets new document leading from #EN_LEAD, breaks to a new page,
\#   sets up an endnotes page based on registers and strings associated
\#   with endnotes, then outputs diversion END_NOTES.
\#
.MAC ENDNOTES END
.    if \\n[defer] .NEWPAGE
.    nr #LAST_EN \\n[#EN_NUMBER]
.    nr #ENDNOTES 1
.    nr #EN_FIRST_PAGE 1
.    nr #HEADER_STATE \\n[#HEADERS_ON]
.    ds $RESTORE_PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#HEADERS_ON]=1 \
.       if !\\n[#EN_ALLOWS_HEADERS_ALL] .HEADERS OFF
.    if \\n[#HEADER_STATE]=1 \{\
.       ie \\n[#EN_HDRFTR_CENTER]=1 .
.       el .rm $HDRFTR_CENTER
.    \}
.    ie !\\n[#SUSPEND_PAGINATION] \{\
.       if \\n[#PAGINATE]=1 \{\
.          if \\n[#PAGE_NUM_V_POS]=1 \{\
.             PAGENUM_STYLE \\*[$EN_PN_STYLE]
.             if \\n[#EN_FIRST_PN] .PAGENUMBER \\n[#EN_FIRST_PN]-1
.             if r #EN_NO_FIRST_PN .nr #PAGINATE 0
.          \}
.       \}
.    \}
.    el \{\
.       ie \\n[#PAGE_NUM_V_POS]=2 .nr #PAGINATE 1
.       el .nr #PAGINATE 0
.    \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       if !'\\*[$HDRFTR_CENTER_OLD]'' \
.          ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_OLD]
.    \}
.    NEWPAGE
.    if \\n[#FOOTERS_ON]=1 \{\
.       ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_NEW]
.       rm $HDRFTR_CENTER_OLD
.       rm $HDRFTR_CENTER_NEW
.    \}
.    ie !\\n[#SUSPEND_PAGINATION] \{\
.       if \\n[#PAGE_NUM_V_POS]=1 \{\
.          if r #EN_NO_FIRST_PN \
.             if \\n[#PAGINATION_STATE]=1 .nr #PAGINATE 1
.       \}
.    \}
.    el \
.       if \\n[#PAGE_NUM_V_POS]=2 .nr #PAGINATE 0
.    rr #PAGINATION_STATE
.    PAGENUM_STYLE \\*[$EN_PN_STYLE]
.    if \\n[#EN_FIRST_PN] .PAGENUMBER \\n[#EN_FIRST_PN]
.    if \\n[#HEADER_STATE]=1 \
.       if \\n[#EN_ALLOWS_HEADERS] .HEADERS
.\" Collect endnotes title string for TOC
.    nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.    af #TOC_ENTRY_PN \\g[#PAGENUMBER]
.    ds $TOC_TITLE_ITEM \\*[$EN_STRING]\|
.    PDF_BOOKMARK 1 \\*[$EN_STRING]
.    TITLE_TO_TOC
.\" End collection of endnotes title string for TOC
.\" Process endnotes
.    if \\n[#PRINT_STYLE]=1 .vs \\n[#EN_LEAD]u
.    if \\n[#PRINT_STYLE]=2 \{\
.       if \\n[#EN_NO_COLS] \{\
.          if \\n[#COLUMNS] .nr #COLUMNS_WERE_ON 1
.          nr #COLUMNS 0
.       \}
.       nr #RESTORE_DOC_LEAD \\n[#DOC_LEAD]
.       ie \\n[#ADJ_EN_LEAD] .nr #DOC_LEAD \\n[#EN_LEAD]
.       el .DOC_LEAD \\n[#EN_LEAD]u
.    \}
.    vpt 0
.    ie r#EN_STRING_ADVANCE .sp |\\n[#EN_STRING_ADVANCE]u-1v
.    el .sp |\\n[#T_MARGIN]u-1v
.    vpt 1
.    mk ec
.    if \\n[#SLANT_ON] \{\
\*[SLANTX]\c
.    \}
.    sp
.    if !'\\*[$EN_STRING]'' \{\
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          vs \\n[#EN_LEAD]u
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          LL \\n[#DOC_L_LENGTH]u
.          ta \\n[.l]u
.          if \\n[#COLUMNS] \{\
.             ie \\n[#EN_NO_COLS] .LL \\n[#DOC_L_LENGTH]u
.             el .LL \\n[#COL_L_LENGTH]u
.             ta \\n[.l]u
.          \}
.          FAMILY  \\*[$EN_STRING_FAM]
.          FT      \\*[$EN_STRING_FT]
.          ps \\n[#EN_PS]u\\*[$EN_STRING_SIZE_CHANGE]
.          vs      \\n[#EN_LEAD]u
.          if \\n[#ENDNOTE_STRING_COLOR]=1 \{\
.             COLOR \\*[$ENDNOTE_STRING_COLOR]
.             EOL
.          \}
.       \}
.       if '\\*[$EN_STRING_QUAD]'L'      .LEFT
.       if '\\*[$EN_STRING_QUAD]'LEFT'   .LEFT
.       if '\\*[$EN_STRING_QUAD]'C'      .CENTER
.       if '\\*[$EN_STRING_QUAD]'CENTER' .CENTER
.       if '\\*[$EN_STRING_QUAD]'CENTRE' .CENTER
.       if '\\*[$EN_STRING_QUAD]'R'      .RIGHT
.       if '\\*[$EN_STRING_QUAD]'RIGHT'  .RIGHT
.       EOL
.       if \\n[#EN_STRING_CAPS] .CAPS
.       ie \\n[#EN_STRING_UNDERLINE] \{\
.          nr #FROM_EN_STRING 1
.          ie \\n[#EN_STRING_UNDERLINE]=2 \
.             UNDERSCORE2 \\*[$EN_UNDERLINE_GAP] \\*[$EN_RULE_GAP] "\\*[$EN_STRING]"
.          el .UNDERSCORE "\\*[$EN_STRING]"
.          rr #FROM_EN_STRING
.       \}
.       el .PRINT "\\*[$EN_STRING]
.    \}
.    CAPS OFF
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#SINGLE_SPACE]=1 .sp
.       el \{\
.          ie \\n[#EN_SINGLESPACE]=1 .sp
.          el .
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=2 .ALD \\n[#EN_LEAD]u
.    QUAD \\*[$EN_QUAD]
.    chop END_NOTES
.    nf
.    END_NOTES
.    rm END_NOTES
.    ps \\n[#DOC_PT_SIZE]u
.    if \\n[#PRINT_STYLE]=1 .vs \\n[#DOC_LEAD]u
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#ADJ_EN_LEAD] \
.          nr #DOC_LEAD \\n[#RESTORE_DOC_LEAD]
.       el .DOC_LEAD \\n[#RESTORE_DOC_LEAD]u
.       rr #RESTORE_DOC_LEAD
.    \}
.    if \\n[#COLUMNS_WERE_ON] .nr #COLUMNS 1
.    if \\n[#HEADER_STATE]=1 .HEADERS
.    if \\n[#LINENUMBERS]=2 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.    \}
.
.    PRINT_FOOTER
.    rr #ENDNOTES
.END
\#
\# ====================================================================
\#
\# +++BIBLIOGRAPHY+++
\#
\# Mom treats bibliographies and endnotes very similarly.  The chief
\# difference is that endnotes are collected and formatted inside a
\# diversion, while bibliographies are built "by hand."  ENDNOTES sets
\# up the endnotes page and outputs the formatted diversion.
\# BIBLIOGRAPHY sets up the bibliography page, then awaits refer
\# commands.
\#
\# All of the bibliography control macros have their exact
\# counterparts in the endnotes control macros.  See, therefore,
\# Arguments, Functions, and Notes in the Endnotes section.
\#
\# Bibliography control macros
\#
.MAC BIBLIOGRAPHY_PT_SIZE END
.    nr #BIB_PS (p;\\$1)
.END
\#
.MAC BIBLIOGRAPHY_HDRFTR_CENTER END
.    ie '\\$1'' .nr #BIB_HDRFTR_CENTER 1
.    el .rr #BIB_HDRFTR_CENTER
.END
\#
.MAC BIBLIOGRAPHY_STRING END
.    ds $BIB_STRING \\$1
.END
\#
.MAC BIBLIOGRAPHY_STRING_ADVANCE END
.    nr #BIB_STRING_ADVANCE (\\$1)
.END
\#
.MAC BIBLIOGRAPHY_STRING_CAPS END
.   ie '\\$1'' .nr #BIB_STRING_CAPS 1
.   el .nr #BIB_STRING_CAPS 0
.END
\#
.MAC BIBLIOGRAPHY_NO_COLUMNS END
.    ie '\\$1'' .nr #BIB_NO_COLS 1
.    el .rr #BIB_NO_COLS
.END
\#
.MAC BIBLIOGRAPHY_NO_FIRST_PAGENUM END
.    ie '\\$1'' .nr #BIB_NO_FIRST_PN 1
.    el .rr #BIB_NO_FIRST_PN
.END
\#
.MAC BIBLIOGRAPHY_ALLOWS_HEADERS END
.    ie '\\$1'' .nr #BIB_ALLOWS_HEADERS 1
.    el \{\
.       ie '\\$1'ALL' \{\
.          nr #BIB_ALLOWS_HEADERS 1
.          nr #BIB_ALLOWS_HEADERS_ALL 1
.       \}
.       el \{\
.          rr #BIB_ALLOWS_HEADERS
.          rr #BIB_ALLOWS_HEADERS_ALL
.       \}
.    \}
.END
\#
.MAC BIBLIOGRAPHY_PAGENUM_STYLE END
.    ds $BIB_PN_STYLE \\$1
.END
\#
.MAC BIBLIOGRAPHY_FIRST_PAGENUMBER END
.    nr #BIB_FIRST_PN \\$1
.END
\#
.MAC SINGLESPACE_BIBLIOGRAPHY END
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#SINGLE_SPACE] \{\
.          nr #BIB_SINGLESPACE 1
.          rr #IGNORE
.          if \\n[#OK_PROCESS_LEAD] \{\
.             BIBLIOGRAPHY_LEAD 12 ADJUST
.             nr #IGNORE 1
.          \}
.       \}
.       el \{\
.          ie '\\$1'' \{\
.             nr #BIB_SINGLESPACE 1
.             rr #IGNORE
.             if \\n[#OK_PROCESS_LEAD] \{\
.                BIBLIOGRAPHY_LEAD 12 ADJUST
.                nr #IGNORE 1
.             \}
.          \}
.          el \{\
.             rr #BIB_SINGLESPACE
.             rr #IGNORE
.             if \\n[#OK_PROCESS_LEAD] \{\
.                BIBLIOGRAPHY_LEAD 24 ADJUST
.                nr #IGNORE 1
.             \}
.          \}
.       \}
.    \}
.END
\#
\# Style for outputting collected bibliographic references
\# -------------------------------------------------------
\# *Argument:
\#   LIST | PLAIN [ <list separator> ] [ <list prefix> ]
\# *Function:
\#   Sets #BIB_LIST to 1 for numbered list style, 0 for plain output
\# *Notes:
\#   Technically, user is supposed to enter PLAIN if s/he wants an
\#   unumbered bibliography, but the el clause says "any arg but
\#   LIST means unumbered."  Effectively, any arg but LIST produces
\#   a "plain" bibliographic list.
\#
\#   The 2nd and 3rd args have the same options as the 2nd arg to LIST.
\#
.MAC BIBLIOGRAPHY_TYPE END
.    ie '\\$1'LIST' \{\
.       nr #BIB_LIST 1
.       ie '\\$2'' \{\
.          if '\\*[$BIB_LIST_SEPARATOR]'' .ds $BIB_LIST_SEPARATOR .
.       \}
.       el .ds $BIB_LIST_SEPARATOR \\$2
.       ie '\\$3'' .ds $BIB_LIST_PREFIX
.       el .ds $BIB_LIST_PREFIX \\$3
.    \}
.    el .nr #BIB_LIST 0
.END
\#
\# Spacing between items in bibliographies
\# ---------------------------------------
\# *Argument:
\#   <amount of space>
\# *Function:
\#   Gets value for #BIB_SPACE in units.
\# *Notes:
\#   Requires a unit of measure.
\#
.MAC BIBLIOGRAPHY_SPACING END
.    ds $BIB_SPACE \\$1
.    if \\n[#BIB_LEAD]=0 \{\
.       nr #DEFER_BIB_SPACING 1
.       return
.    \}
.    ds $EVAL_BIB_SPACE \\*[$BIB_SPACE]
.    substring $EVAL_BIB_SPACE -1
.    ie '\\*[$EVAL_BIB_SPACE]'v' \{\
.       substring $BIB_SPACE 0 0
.       nr #BIB_SPACE \\n[#BIB_LEAD]*\\*[$BIB_SPACE]
.    \}
.    el .nr #BIB_SPACE (\\$1)
.END
\#
\# Set up bibliography page
\# ------------------------
\# *Function:
\#   Sets up a new page, with title, ready to accept the output
\#   of refer's $LIST$ or .R1 bibliography .R2
\# *Notes:
\#   Bibliography pages are set up almost identically to endnotes pages.
\#
.MAC BIBLIOGRAPHY END
.    ie '\\$1'' \{\
.       rr #FN_REF
.       rr #EN_REF
.       nr #BIBLIOGRAPHY 1
.       nr #BIB_FIRST_PAGE 1
.       nr #HEADER_STATE \\n[#HEADERS_ON]
.       ds $RESTORE_PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.       if \\n[#LINENUMBERS]=1 \{\
.          NUMBER_LINES OFF
.          nr #LINENUMBERS 2
.       \}
.       if \\n[#HEADERS_ON]=1 \
.          if !\\n[#BIB_ALLOWS_HEADERS_ALL] .HEADERS OFF
.       if \\n[#HEADER_STATE]=1 \{\
.          ie \\n[#BIB_HDRFTR_CENTER]=1 .
.          el .rm $HDRFTR_CENTER
.       \}
.       ie !\\n[#SUSPEND_PAGINATION] \{\
.          if \\n[#PAGINATE]=1 \{\
.             if \\n[#PAGE_NUM_V_POS]=1 \{\
.                PAGENUM_STYLE \\*[$BIB_PN_STYLE]
.                if \\n[#BIB_FIRST_PN] .PAGENUMBER \\n[#BIB_FIRST_PN]-1
.                if r #BIB_NO_FIRST_PN .nr #PAGINATE 0
.             \}
.          \}
.       \}
.       el \{\
.          ie \\n[#PAGE_NUM_V_POS]=2 .nr #PAGINATE 1
.          el .nr #PAGINATE 0
.       \}
.       if \\n[#FOOTERS_ON]=1 \{\
.          if !'\\*[$HDRFTR_CENTER_OLD]'' \
.             ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_OLD]
.       \}
.       NEWPAGE
.       if \\n[#FOOTERS_ON]=1 \{\
.          ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_NEW]
.          rm $HDRFTR_CENTER_OLD
.          rm $HDRFTR_CENTER_NEW
.       \}
.       ie !\\n[#SUSPEND_PAGINATION] \{\
.          if \\n[#PAGE_NUM_V_POS]=1 \{\
.             if r #BIB_NO_FIRST_PN \{\
.                if \\n[#PAGINATION_STATE]=1 .nr #PAGINATE 1
.             \}
.          \}
.       \}
.       el \
.          if \\n[#PAGE_NUM_V_POS]=2 .nr #PAGINATE 0
.       rr #PAGINATION_STATE
.       PAGENUM_STYLE \\*[$BIB_PN_STYLE]
.       if \\n[#BIB_FIRST_PN] .PAGENUMBER \\n[#BIB_FIRST_PN]
.       if \\n[#HEADER_STATE]=1 \
.          if \\n[#BIB_ALLOWS_HEADERS] .HEADERS
.\" Collect bibliography title string for TOC
.       nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.       af #TOC_ENTRY_PN \\g[#PAGENUMBER]
.       ds $TOC_TITLE_ITEM \\*[$BIB_STRING]\\|
.       PDF_BOOKMARK 1 \\*[$BIB_STRING]
.       TITLE_TO_TOC
.\" End collection of bibliography title string for TOC
.\" Process bibliography
.       if \\n[#PRINT_STYLE]=1 .vs \\n[#BIB_LEAD]u
.       if \\n[#PRINT_STYLE]=2 \{\
.          if \\n[#BIB_NO_COLS] \{\
.             if \\n[#COLUMNS] .nr #COLUMNS_WERE_ON 1
.             nr #COLUMNS 0
.          \}
.          nr #RESTORE_DOC_LEAD \\n[#DOC_LEAD]
.          ie \\n[#ADJ_BIB_LEAD] .nr #DOC_LEAD \\n[#BIB_LEAD]
.          el .DOC_LEAD \\n[#BIB_LEAD]u
.       \}
.       vpt 0
.       ie r#BIB_STRING_ADVANCE .sp |\\n[#BIB_STRING_ADVANCE]u-1v
.       el .sp |\\n[#T_MARGIN]u-1v
.       vpt 1
.       mk bc
.       if \\n[#SLANT_ON] \{\
\*[SLANTX]\c
.       \}
.       sp
.       if !'\\*[$BIB_STRING]'' \{\
.          if \\n[#PRINT_STYLE]=1 \{\
.             TYPEWRITER
.             vs \\n[#BIB_LEAD]u
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             LL \\n[#DOC_L_LENGTH]u
.             ta \\n[.l]u
.             if \\n[#COLUMNS] \{\
.                ie \\n[#BIB_NO_COLS] .LL \\n[#DOC_L_LENGTH]u
.                el .LL \\n[#COL_L_LENGTH]u
.                ta \\n[.l]u
.             \}
.             FAMILY  \\*[$BIB_STRING_FAM]
.             FT      \\*[$BIB_STRING_FT]
.             ps \\n[#BIB_PS]u\\*[$BIB_STRING_SIZE_CHANGE]
.             vs      \\n[#BIB_LEAD]u
.          \}
.          if '\\*[$BIB_STRING_QUAD]'LEFT'   .LEFT
.          if '\\*[$BIB_STRING_QUAD]'C'      .CENTER
.          if '\\*[$BIB_STRING_QUAD]'CENTER' .CENTER
.          if '\\*[$BIB_STRING_QUAD]'CENTRE' .CENTER
.          if '\\*[$BIB_STRING_QUAD]'R'      .RIGHT
.          if '\\*[$BIB_STRING_QUAD]'RIGHT'  .RIGHT
.          EOL
.          if \\n[#BIB_STRING_CAPS] .CAPS
.          ie \\n[#BIB_STRING_UNDERLINE] \{\
.             nr #FROM_BIB_STRING 1
.             ie \\n[#BIB_STRING_UNDERLINE]=2 \
.                UNDERSCORE2 "\\*[$BIB_STRING]"
.             el .UNDERSCORE "\\*[$BIB_STRING]"
.             rr #FROM_BIB_STRING
.          \}
.          el .PRINT "\\*[$BIB_STRING]"
.       \}
.       CAPS OFF
.       FAMILY \\*[$BIB_FAMILY]
.       FT \\*[$BIB_FT]
.       ps -\\*[$BIB_STRING_SIZE_CHANGE]
.       if \\n[#PRINT_STYLE]=1 \{\
.          ie \\n[#SINGLE_SPACE]=1 .ALD \\n[#BIB_LEAD]*3u
.          el \{\
.             ie \\n[#BIB_SINGLESPACE]=1 .ALD \\n[#BIB_LEAD]u*3u
.             el .ALD \\n[#BIB_LEAD]u
.          \}
.       \}
.       if \\n[#PRINT_STYLE]=2 .ALD \\n[#BIB_LEAD]u*2u
.       QUAD \\*[$BIB_QUAD]
.       if \\n[#PRINT_STYLE]=1 \{\
.          ie \\n[#SINGLE_SPACE]=1 .vs \\n[#BIB_LEAD]u
.          el \{\
.             ie \\n[#BIB_SINGLESPACE]=1 .vs \\n[#BIB_LEAD]u
.             el .vs \\n[#BIB_LEAD]u
.          \}
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          ie \\n[#ADJ_BIB_LEAD] \
.             nr #DOC_LEAD \\n[#RESTORE_DOC_LEAD]
.          el .DOC_LEAD \\n[#RESTORE_DOC_LEAD]u
.          rr #RESTORE_DOC_LEAD
.       \}
.       if \\n[#COLUMNS_WERE_ON] .nr #COLUMNS 1
.       if \\n[#HEADER_STATE]=1 .HEADERS
.       if \\n[#LINENUMBERS]=2 \{\
.          NUMBER_LINES RESUME
.          nr #LINENUMBERS 1
.       \}
.       di BIB
.    \}
.    el \{\
.       br
.       di
.\" Part of workaround for refer spitting out a blank page if the
.\" last ref falls on the bottom line.
.       nr num*refs \\n[ref*num*first-pass]
.       nf
.       chop BIB
.       BIB
.    \}
.END
\#
\# ====================================================================
\#
\# +++TABLE OF CONTENTS+++
\#
\# Strings to allocate space for leaders and entry page numbers
\#
.ds $TOC_PN \\*[ST102]\F[\\*[$TOC_PN_FAM]]\f[\\*[$TOC_PN_FT]]\
\s[\\n[#TOC_PS]u]^\\*[ST102X]\\*[ST103]\s[\\*[$TOC_PN_SIZE_CHANGE]]\
\|\|\|\h'\w'0'u*\\n[#TOC_PN_PADDING]u'\\*[ST103X]
\#
.ds $TOC_PN_TYPEWRITE \\*[ST102]^\\*[ST102X]\\*[ST103]\
\h'\w'0'u*\\n[#TOC_PN_PADDING]u'\\*[ST103X]
\#
\# TOC collector
\#
.MAC TO_TOC END
.    if !'\\n[.ev]'TOC_EV' .ev TOC_EV
.    nr #TOC_CH_NUM_INDENT \w'\\*[$TOC_CH_NUM]'
.    da TOC_ENTRIES
\!.  ie \\\\n[#SKIP_ENTRY]=1 \{\
.     rr #SKIP_ENTRY
\!.  \}
\!.  el \{\
.       br
.       ie \\n[#PRINT_STYLE]=1 \{\
\!.        fam \\*[$TYPEWRITER_FAM]
\!.        ft  R
\!.        ps \\*[$TYPEWRITER_PS]
.          ds _TYPEWRITE _TYPEWRITE
.       \}
.       el \{\
.          ie '\\$0'HD_TO_TOC' \{\
\!.           ps \\n[#TOC_PS]u\\*[$TOC_HEAD_\\n[#LEVEL]_SIZE]
.          \}
.          el \{\
\!.           FAMILY  \\*[$TOC_TITLE_FAM]
\!.           FT      \\*[$TOC_TITLE_FT]
\!.           ps \\n[#TOC_PS]u\\*[$TOC_TITLE_SIZE]
.          \}
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          rm _TYPEWRITE
.          if \\n[#SPACE_TOC_ITEMS] \{\
.             if \\n[#POST_TOP]=1 \{\
.                ie !\\n[#LEVEL]=\\n[#LAST_LEVEL] \{\
.                   ie \\n[#LEVEL]>\\n[#LAST_LEVEL] \!.sp .2v
.                   el \!.sp .4v
.                \}
.                el \{\
.                   if \\n[#COLLATED_DOC] \
.                      if '\\$0'TITLE_TO_TOC' \!.sp .4v
.                \}
.             \}
.          \}
.       \}
\!.     PAD_MARKER ^
.       if !'\\$0'HD_TO_TOC' \{\
\!.        if \\n[#TOC_TITLE_CAPS]=1 .CAPS
.       \}
.       if '\\$0'HD_TO_TOC' \{\
.          nr #POST_TOP 1
\!.        if \\n[#TOC_HEAD_\\n[#LEVEL]_CAPS]=1 .CAPS
.       \}
\!.     vpt 0
.       ie '\\$0'HD_TO_TOC' \{\
\!.        PAD \
"\\f[\\*[$TOC_HEAD_\\n[#LEVEL]_FAM]\
\\*[$TOC_HEAD_\\n[#LEVEL]_FT]]\
\h'\\\\n[#TOC_INDENT_ADJ]u'\h'\\n[#TOC_HEAD_\\n[#LEVEL]_INDENT]u'\
\\*[$TOC_HD_NUM]\\*[$TOC_HEAD_\\n[#LEVEL]_ITEM]\\*[$TOC_PN\\*[_TYPEWRITE]]" \
"\\*[PDFBOOKMARK.NAME]"
.       \}
.       el \{\
\!.        PAD \
"\\f[\\*[$TOC_TITLE_FAM]\\*[$TOC_TITLE_FT]]\
\h'\\n[#TOC_TITLE_INDENT]u'\\*[$TOC_TITLE_ITEM]\\*[$TOC_PN\\*[_TYPEWRITE]]" \
"\\*[PDFBOOKMARK.NAME]"
.       \}
.       if '\\$0'HD_TO_TOC' \{\
\!.        if \\n[#TOC_HEAD_\\n[#LEVEL]_CAPS]=1 .CAPS OFF
.       \}
.       if !'\\$0'HD_TO_TOC' \{\
\!.        if \\n[#TOC_TITLE_CAPS]=1 .CAPS OFF
.       \}
\!.     PAD_MARKER #
\!.     EOL
\!.     ST 102 L
\!.     ST 103 R
.       if \\n[#PRINT_STYLE]=2 \{\
\!.        FAMILY  \\*[$TOC_PN_FAM]
\!.        FT      \\*[$TOC_PN_FT]
\!.        ps \\n[#TOC_PS]u
.       \}
\!.     TAB 102
\!.     PRINT \\*[LEADER]
\!.     TN
.       if \\n[#PRINT_STYLE]=2 \{\
\!.        ps \\*[$TOC_PN_SIZE_CHANGE]u
.       \}
\!.     PRINT \\n[#TOC_ENTRY_PN]
\!.     TQ
\!.     vpt
\!. \}
.   da
.   ev
.END
\#
.ALIAS HD_TO_TOC  TO_TOC
.ALIAS TITLE_TO_TOC TO_TOC
\#
\# Control macros for toc
\# ----------------------
\#
\# TOC TITLE STYLE
\# ---------------
\# *Arguments:
\#   FAMILY <family>
\#   FONT   <font>
\#   SIZE   <+|-n>
\#   COLOR  <color>
\#   CAPS
\#   INDENT
\# *Function:
\#   Assigns complete style parameters to TITLEs (doc titles,
\#   chapter titles, etc) in the TOC.
\# *Notes:
\#   TITLEs are not headings, therefore they require their own style
\#   macro.  Otherwise, the same as TOC_ENTRY_STYLE.
\#
.MAC TOC_TITLE_STYLE END
.    nr #ARG_NUM 0 1
.    nr #ATTRIB \\n[#NUM_ARGS]
.    while \\n+[#ARG_NUM]<=\\n[#ATTRIB] \{\
.       if '\\$1'FAMILY' \{\
.          shift
.          ds $TOC_TITLE_FAM  \\$1
.          shift
.       \}
.       if '\\$1'FONT' \{\
.          shift
.          ds $TOC_TITLE_FT   \\$1
.          shift
.       \}
.       if '\\$1'SIZE' \{\
.          shift
.          ds $TOC_TITLE_SIZE \\$1
.          shift
.       \}
.       if '\\$1'CAPS' \{\
.          nr #TOC_TITLE_CAPS 1
.          shift
.       \}
.       if '\\$1'NO_CAPS' \{\
.          rr #TOC_TITLE_CAPS
.          shift
.       \}
.       if '\\$1'INDENT' \{\
.          shift
.          nr #TOC_TITLE_INDENT \\$1
.          shift
.       \}
.    \}
.END
\#
\# TOC HEADER STRING
\# -----------------
\# *Argument:
\#   <string for "doc header" of first toc page>
\# *Function:
\#   Creates or modifies string $TOC_HEADER_STRING
\# *Notes:
\#   Default is "Contents".
\#
.MAC TOC_HEADER_STRING END
.    ds $TOC_HEADER_STRING \\$1
.END
\#
\# TOC POINT SIZE
\# --------------
\# *Argument:
\#   <base point size for toc pages>
\# *Function:
\#   Creates or modifies register #TOC_PS.
\# *Notes:
\#   This size control macro differs from other size control macros
\#   in that it sets an absolute point size, not a relative one.
\#   See notes for ENDNOTE_PT_SIZE for explanation.
\#
\#   No unit of measure required (points assumed).  Default is 12.5
\#   for TYPESET.
\#
.MAC TOC_PT_SIZE END
.    nr #TOC_PS (p;\\$1)
.END
\#
\# TOC ENTRIES PAGE NUMBERS PADDING
\# --------------------------------
\# *Argument:
\#   <number of placeholders for toc entries page numbers>
\# *Function:
\#   Creates or modifies register #TOC_PN_PADDING.
\# *Notes:
\#   "Placeholders" is the maximum number of digits in a page
\#   number numeral.
\#
\#   Default is 3.
\#
.MAC TOC_PADDING END
.    nr #TOC_PN_PADDING \\$1
.END
\#
\# PAGINATE TOC
\# ------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #PAGINATE_TOC.
\# *Notes:
\#   Default is to paginate toc.
\#
.MAC PAGINATE_TOC END
.    ie '\\$1'' .nr #PAGINATE_TOC 1
.    el .nr #PAGINATE_TOC 0
.END
\#
.MAC TOC_FIRST_PAGENUM END
.    nr #TOC_START_PAGENUM \\$1
.END
\#
\# TOC PAGES PAGE-NUMBERING STYLE
\# ------------------------------
\# *Argument:
\#   DIGIT | ROMAN | roman | ALPHA | alpha
\# *Function:
\#   Creates or modifies string $TOC_PN_STYLE
\# *Notes:
\#   Page numbering style for page numbers that appear in the
\#   headers/footers of toc pages.  See notes for PAGENUM_STYLE.
\#
\#   Default is roman.
\#
.MAC TOC_PAGENUM_STYLE END
.    ds $TOC_PN_STYLE \\$1
.END
\#
\# TOC RECTO_VERSO SWITCH
\# ----------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #TOC_RV_SWITCH
\# *Notes:
\#   Allows switching of L/R margins if a doc is recto/verso and
\#   the first toc page happens to fall the wrong way
\#
.MAC TOC_RV_SWITCH END
.    ie '\\$1'' .nr #TOC_RV_SWITCH 1
.    el .rr #TOC_RV_SWITCH
.END
\#
\# TOC ENTRY SPACING
\# -----------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles whether a small amount of space is inserted between TOC
\#   entries for greater legibility.
\#
.MAC SPACE_TOC_ITEMS END
.    ie !'\\$1'' .rr #SPACE_TOC_ITEMS
.    el .nr #SPACE_TOC_ITEMS 1
.END
\#
\# NUMBERING OF TOC ENTRIES
\# ------------------------
\# *Arguments:
\#   FULL | TRUNCATE | NONE
\# *Function:
\#   Determines how, or whether, to prepend heading numbers to TOC
\#   entries.
\# *Notes:
\#   FULL means the complete numbering string (default).
\#
\#   TRUNCATE means prepend a single digit sufficient to identify
\#   an entry's place in the numbering scheme with reference to the
\#   level above it.  Thus, if a HEADING 1 is the second HEADING 1
\#   and therefore numbered "2.", a HEADING 2 beneath it (in the TOC)
\#   will have only "1." prepended to the entry; TOC indenting makes it
\#   evident under which level the HEADING 2 belongs.
\#
\#   Note that TRUNCATE also removes chapter numbers, if
\#   PREFIX_CHAPTER_NUMBER is on.
\#
.MAC TOC_ENTRY_NUMBERS END
.    if '\\$1'TRUNCATE' .nr #TRUNC_TOC_HD_NUM 1
.    if '\\$1'FULL'     .nr #TRUNC_TOC_HD_NUM 0
.    if '\\$1'NONE'     .nr #TOC_NO_HD_NUM 1
.END
\#
\# User defined TITLE entry string
\#
.MAC TOC_TITLE_ENTRY END
.    nr #USER_SET_TITLE_ITEM 1
.    ds $USER_SET_TITLE_ITEM \\$1
.END
\#
\# APPEND AUTHOR(S) TO TOC DOC TITLE ENTRIES
\# -----------------------------------------
\# *Argument:
\#   <none> | <name(s) of author(s) as they should appear in toc doc title entries>
\# *Function:
\#   Creates register #TOC_AUTHORS (to tell TOC to append authors
\#   to toc doc title entries).  Optionally creates string
\#   $TOC_AUTHORS.
\# *Notes:
\#   Normally, TOC does not append the author(s) to a toc doc title
\#   entry.  This special macro instructs TOC to do so.
\#
\#   If user has multiple authors for each doc when collating,
\#   TOC_APPENDS_AUTHOR "<string>" must be inserted somewhere between
\#   COLLATE and START in each doc.  Otherwise, mom prints only the
\#   first author given to AUTHOR.
\#
.MAC TOC_APPENDS_AUTHOR END
.    nr #TOC_AUTHORS 1
.    if !'\\$1'' .ds $TOC_AUTHORS \\$1
.END
\#
\# TABLE OF CONTENTS
\# -----------------
\# *Arguments:
\#   none
\# *Function:
\#   Takes care of the administrivia of setting up the TOC as if
\#   it's a collated doc, then outputs the formatted TOC_ENTRIES
\#   diversion.
\#
.MAC TOC END
.    char \[leader] " .
.    LEADER_CHARACTER \[leader]
.    ie \\n[#COLLATED_DOC] \{\
.       nr #TOC_INDENT_ADJ 1.5m
.       if \\n[#PREFIX_CH_NUM] .nr #TOC_INDENT_ADJ \\n[#TOC_CH_NUM_INDENT]
.    \}
.    el \{\
.       nr #SKIP_ENTRY 1
.       nr #TOC_INDENT_ADJ 0
.    \}
.    nr #TOC 1
.    nr TOC.RELOCATE 0
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if !r #PAGINATE_TOC .PAGINATE_TOC
.    nr #TOC_FIRST_PAGE 1
.    if \\n[#FINIS] \{\
.       if \\n[#FOOTERS_WERE_ON] \
.          FOOTERS \" Have to turn FOOTERS on for next bit to work, so we can't skip this step
.    \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       if !'\\*[$HDRFTR_CENTER_OLD]'' .ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_OLD]
.       ie \\n[#PAGINATE_TOC]=1 .PAGINATE
.       el .PAGINATION OFF
.    \}
.    if \\n[#FOOTERS_WERE_ON] .FOOTERS OFF  \" But have to turn FOOTERS off again so they don't print when FINIS was called
.    rr #COLUMNS
.    COLLATE
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#SINGLE_SPACE] .vs 24
.       DOC_LEAD_ADJUST
.    \}
.    if \\n[#PRINT_STYLE]=2 .vs \\n[#TOC_LEAD]u
.    if \\n[#FINIS] \{\
.       if \\n[#FOOTERS_WERE_ON] .FOOTERS  \" Finally, turn footers on if they were on
.       rr #FOOTERS_WERE_ON
.       if \\n[#PAGINATION_WAS_ON] \{\
.          nr #PAGINATE 1
.          rr #PAGINATION_WAS_ON
.       \}
.       rr #FINIS
.    \}
.    ie \\n[#PAGINATE_TOC]=1 .PAGINATE
.    el .PAGINATION OFF
.    ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_NEW]
.    rm $HDRFTR_CENTER_OLD
.    rm $HDRFTR_CENTER_NEW
.    rr #COLLATED_DOC
.    DOCHEADER OFF \\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.    if !r #TOC_START_PAGENUM .nr #TOC_START_PAGENUM 1
.       PAGENUMBER \\n[#TOC_START_PAGENUM]
.    if \\n[#LINENUMBERS]=2 .nr #LINENUMBERS 3
.    L_MARGIN   \\n[#DOC_L_MARGIN]u
.    LL         \\n[#DOC_L_LENGTH]u
.    HEADER_CENTER "\\*[$TOC_HEADER_STRING]
.    if \\n[#SLANT_ON] .nop \\*[SLANTX]
.    START
.    PAGENUM_STYLE \\*[$TOC_PN_STYLE]
.    PDF_BOOKMARK 1 \\*[$TOC_HEADER_STRING]
.    if \\n[#PRINT_STYLE]=1 .TYPEWRITER
.    if \\n[#PRINT_STYLE]=2 \{\
.       FAMILY  \\*[$TOC_HEADER_FAM]
.       FT      \\*[$TOC_HEADER_FT]
.       ps \\n[#TOC_PS]u\\*[$TOC_HEADER_SIZE_CHANGE]
.    \}
.    ie \\n[#PRINT_STYLE]=1 \{\
.       CAPS
.       UNDERSCORE 3p "\\*[$TOC_HEADER_STRING]"
.       CAPS      OFF
.    \}
.    el .PRINT \\*[$TOC_HEADER_STRING]
.    sp
.    nf
.    TOC_ENTRIES
.    rr #TOC
.    if \\n[#LINENUMBERS]=3 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.       nn 1
.    \}
.    rr #TOC
.    pdfsync
.END
\#
\# ====================================================================
\#
\# +++COLUMNS+++
\#
\# COLUMNS
\# -------
\# *Arguments:
\#   <number of columns>  <width of gutters>
\# *Function:
\#   Creates registers associated with setting docs in columns.
\#   Calculates column line lengths and offsets
\# *Notes:
\#   COLUMNS, if used, s/b the last macro invoked before START.
\#
.MAC COLUMNS END
.    if \\n[#IGNORE_COLUMNS]=1 .return
.    nr #COLUMNS 1
.    nr #NUM_COLS \\$1
.    nr #GUTTER (\\$2)
.    nr #COL_L_LENGTH \\n[#L_LENGTH]-(\\n[#GUTTER]*(\\n[#NUM_COLS]-1))/\\n[#NUM_COLS]
.    nr #COL_TOTAL 0 \\n[#COL_L_LENGTH]+\\n[#GUTTER]
.    nr #COL_NUM 0 1
.    while !\\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.       nr #COL_\\n+[#COL_NUM]_L_MARGIN \\n[#L_MARGIN]+\\n[#COL_TOTAL]
.       nr #COL_TOTAL \\n+[#COL_TOTAL]
.    \}
.    if \\n[#NUM_COLS]=1 \
.       if !\\n[#COLLATE]=1 .MN_INIT
.    rr #COL_TOTAL
.    rr #COL_NUM
.END
\#
\# MARK COL V-POSITION AFTER DOCHEADER
\# -----------------------------------
\# *Arguments:
\#   none
\# *Function:
\#   Sets 1st page dc register.
\# *Notes:
\#   Only required if manual spacing, positive or negative, precedes
\#   start of columns on first page of doc.
\#
.MAC COL_MARK END
.    mk dc
.END
\#
\# NEXT COLUMN
\# -----------
\# *Arguments:
\#   <none>
\# *Function:
\#   Breaks current column and moves to next column.
\#   If current column is the last on the page, breaks
\#   to a new page.
\#
.MAC COL_NEXT END
.    if \\n[#COLUMNS] \{\
.       nr #COL_NEXT 1
.       ie '\\$0'COL_NEXT' .br
.       el \{\
.          brp
.          RLD 1v
.       \}
.       ie \\n[#COL_NUM]=\\n[#NUM_COLS] .bp
.       el .FOOTER
.    \}
.END
\#
\# ====================================================================
\#
\# +++LISTS+++
\#
\# LIST
\# ----
\# *Arguments:
\#   [ BULLET | DASH | DIGIT | alpha | ALPHA | roman | ROMAN | USER ] \
\#   [ <separator> | NONE ] [ <prefix> ] [ <anything> ]
\# *Function:
\#   Stores indent information in effect prior to invocation and
\#   initializes a list with the supplied enumerator (and separator).
\# *Notes:
\#   Default enumerator is a bullet.
\#
\#   Enumerator *must* be supplied for every list that's to the
\#   right of another list, every time, unless the default bullet is
\#   desired.
\#
\#   <anything> moves back one list level intuitively, or exits lists
\#   completely if the level in which it's invoked is the first.
\#
.MAC LIST END
.    ds $1ST_LETTER \\$1
.    if !'\\*[$1ST_LETTER]'' .substring $1ST_LETTER 0 0
.    if '\\*[$1ST_LETTER]'r' .ds $1ST_LETTER R
.    ie '\\*[$1ST_LETTER]'R' \{\
.       ds $LAST_CHAR \\$1
.       substring $LAST_CHAR -1
.       if !\B'\\*[$LAST_CHAR]' \{\
.          if !'\\$1'ROMAN' \{\
.             LIST OFF
.             return
.          \}
.          if !'\\$1'roman' \{\
.             LIST OFF
.             return
.          \}
.          tm1 "[mom]: You must append a number to the \\$1 argument to \\$0.
.          tm1 "       The number should be the total number of items in this list.
.          tm1 "       See the documentation.
.          ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.       \}
.       ds $ROMAN_WIDTH \\$1
.          substring $ROMAN_WIDTH 1
.       while !\B'\\*[$ROMAN_WIDTH]' \{\
.          substring $ROMAN_WIDTH 1
.       \}
.       length #ROMAN_LENGTH \\*[$ROMAN_WIDTH]
.       ds $LIST_ARG_1 \\$1
.       substring $LIST_ARG_1 0 -(\\n[#ROMAN_LENGTH]+1)
.    \}
.    el .ds $LIST_ARG_1 \\$1
.    if !r#DEPTH \{\
.       nr #STORED_HL_INDENT \\n[#HL_INDENT]
.       nr #STORED_T_INDENT  \\n[#T_INDENT]
.       nr #CURRENT_L_LENGTH \\n[.l]
.       nr #DEPTH 0 1
.       if \\n[#INDENT_ACTIVE]=1 \{\
.          if \\n[#INDENT_LEFT_ACTIVE]=1 \{\
.             nr #STORED_L_INDENT \\n[#L_INDENT]
.             nr #RESTORE_PREV_INDENT 1
.          \}
.          if \\n[#INDENT_BOTH_ACTIVE]=1 \{\
.             nr #STORED_BL_INDENT \\n[#BL_INDENT]
.             nr #STORED_BR_INDENT \\n[#BR_INDENT]
.             IBX
.             nr #ORIG_L_LENGTH \\n[.l]
.             IB
.             nr #RESTORE_PREV_INDENT 2
.          \}
.          if \\n[#INDENT_RIGHT_ACTIVE]=1 \{\
.             nr #STORED_R_INDENT \\n[#R_INDENT]
.             IRX
.             nr #ORIG_L_LENGTH \\n[.l]
.             IR
.             nr #RESTORE_PREV_INDENT 3
.             if \\n[#INDENT_LEFT_ACTIVE]=1 .nr #RESTORE_PREV_INDENT 4
.          \}
.       \}
.    \}
.    if \\n[#NUM_ARGS]=0 \{\
.       nr #ARGS_TO_LIST 1 \" So default behaves as if LIST BULLET
.       ds $ENUMERATOR\\n+[#DEPTH] \[bu]
.       ds $ENUMERATOR_TYPE\\n[#DEPTH] other
.       ds $SEPARATOR
.    \}
.    if \\n[#NUM_ARGS]>0 \{\
.       rr #ARGS_TO_LIST \" Clear this before processing arg 1.
.       if '\\*[$LIST_ARG_1]'DASH' \{\
.          nr #ARGS_TO_LIST 1
.          ds $ENUMERATOR\\n+[#DEPTH] \[en]
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] other
.          ds $SEPARATOR\\n[#DEPTH]
.       \}
.       if '\\*[$LIST_ARG_1]'BULLET' \{\
.          nr #ARGS_TO_LIST 1
.          ds $ENUMERATOR\\n+[#DEPTH] \[bu]
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] other
.          ds $SEPARATOR\\n[#DEPTH]
.       \}
.       if '\\*[$LIST_ARG_1]'DIGIT' \{\
.          nr #ARGS_TO_LIST 1
.          nr #ENUMERATOR\\n+[#DEPTH] 0 1
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] register
.          ds $SEPARATOR\\n[#DEPTH] .
.          ds $PREFIX\\n[#DEPTH]
.          if \\n[#NUM_ARGS]>=2 \{\
.             ie '\\$2'NONE' .ds $SEPARATOR\\n[#DEPTH]
.             el .ds $SEPARATOR\\n[#DEPTH] \\$2
.             if \\n[#NUM_ARGS]=3 .ds $PREFIX\\n[#DEPTH] \\$3
.          \}
.       \}
.       if '\\*[$LIST_ARG_1]'alpha' \{\
.          nr #ARGS_TO_LIST 1
.          nr #ENUMERATOR\\n+[#DEPTH] 0 1
.          af #ENUMERATOR\\n[#DEPTH] a
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] register
.          ds $SEPARATOR\\n[#DEPTH] )
.          ds $PREFIX\\n[#DEPTH]
.          if \\n[#NUM_ARGS]>=2 \{\
.             ie '\\$2'NONE' .ds $SEPARATOR\\n[#DEPTH]
.             el .ds $SEPARATOR\\n[#DEPTH] \\$2
.             if \\n[#NUM_ARGS]=3 .ds $PREFIX\\n[#DEPTH] \\$3
.          \}
.       \}
.       if '\\*[$LIST_ARG_1]'ALPHA' \{\
.          nr #ARGS_TO_LIST 1
.          nr #ENUMERATOR\\n+[#DEPTH] 0 1
.          af #ENUMERATOR\\n[#DEPTH] A
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] register
.          ds $SEPARATOR\\n[#DEPTH] )
.          ds $PREFIX\\n[#DEPTH]
.          if \\n[#NUM_ARGS]>=2 \{\
.             ie '\\$2'NONE' .ds $SEPARATOR\\n[#DEPTH]
.             el .ds $SEPARATOR\\n[#DEPTH] \\$2
.             if \\n[#NUM_ARGS]=3 \{\
.                ds $PREFIX\\n[#DEPTH] \\$3
.             \}
.          \}
.       \}
.       if '\\*[$1ST_LETTER]'R' \{\
.          nr #ARGS_TO_LIST 1
.          nr #ENUMERATOR\\n+[#DEPTH] 0 1
.          if '\\*[$LIST_ARG_1]'roman' .af #ENUMERATOR\\n[#DEPTH] i
.          if '\\*[$LIST_ARG_1]'ROMAN' .af #ENUMERATOR\\n[#DEPTH] I
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] roman
.          ds $SEPARATOR\\n[#DEPTH] )
.          ds $PREFIX\\n[#DEPTH]
.          if \\n[#NUM_ARGS]>=2 \{\
.             ie '\\$2'NONE' .ds $SEPARATOR\\n[#DEPTH]
.             el .ds $SEPARATOR\\n[#DEPTH] \\$2
.             if \\n[#NUM_ARGS]=3 .ds $PREFIX\\n[#DEPTH] \\$3
.          \}
.       \}
.       if '\\*[$LIST_ARG_1]'USER' \{\
.          nr #ARGS_TO_LIST 1
.          ds $ENUMERATOR\\n+[#DEPTH] \\$2
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] other
.          ds $SEPARATOR\\n[#DEPTH]
.          ds $PREFIX\\n[#DEPTH]
.       \}
.       if \\n[#NUM_ARGS]=1 \{\
.          if !r#ARGS_TO_LIST \{\
.             ie \\n[#DEPTH]=1 \{\
.                ie \\n[#NEXT_DEPTH_BACK]=0 \{\
.                   SET_LIST_INDENT
.                   if \\n[#QUIT]=1 \{\
.                      QUIT_LISTS
.                      return
.                   \}
.                   return
.                \}
.                el \{\
.                   QUIT_LISTS
.                   return
.                \}
.             \}
.             el \{\
.                SET_LIST_INDENT
.                return
.             \}
.          \}
.       \}
.    \}
.    nr #TOTAL_LISTS \\n[#DEPTH]
.    if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'register' \{\
.       nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]m\\*[$SEPARATOR\\n[#DEPTH]]\ '
.       if '\\*[$LIST_ARG_1]'ALPHA' nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]M\\*[$SEPARATOR\\n[#DEPTH]]\ '
.    \}
.    if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'roman' \
.       GET_ROMAN_INDENT
.    if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'other' \
.       nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$ENUMERATOR\\n[#DEPTH]]\0'
.    ll \\n[#CURRENT_L_LENGTH]u
.    ie \\n[#DEPTH]=1 \{\
.       ie \\n[#INDENT_ACTIVE]=1 \{\
.          if \\n[#INDENT_LEFT_ACTIVE]=1 \{\
.             nr #L_INDENT \\n[#L_INDENT]+\\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #LIST_INDENT\\n[#DEPTH] \\n[#L_INDENT]
.          \}
.          if \\n[#INDENT_BOTH_ACTIVE]=1 \{\
.             nr #L_INDENT \\n[#BL_INDENT]+\\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #LIST_INDENT\\n[#DEPTH] \\n[#L_INDENT]
.          \}
.          if \\n[#INDENT_RIGHT_ACTIVE]=1 \{\
.             ie \\n[#INDENT_LEFT_ACTIVE]=1 \{\
.             \" Don't do anything; we already have a left indent
.             \}
.             el \{\
.                nr #L_INDENT +\\n[#LIST_INDENT\\n[#DEPTH]]
.                nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.             \}
.          \}
.       \}
.       el \{\
.          nr #L_INDENT +\\n[#LIST_INDENT\\n[#DEPTH]]
.          nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.       \}
.    \}
.    el \{\
.       nr #L_INDENT +\\n[#LIST_INDENT\\n[#DEPTH]]
.       nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.    \}
.END
\#
\# ITEM
\# ----
\# *Arguments:
\#   none
\# *Function:
\#   Prints enumerator for a given list depth and prepares mom to
\#   receive the text of an item.
\#
.MAC ITEM END
.    if !r#DEPTH .return
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#KERN]=1 \{\
.       nr #KERN_WAS_ON 1
.       KERN OFF
.    \}
.    rr #IN_ITEM
.    IL
.    nr #IN_ITEM 1
.    ll \\n[#CURRENT_L_LENGTH]u \" Set ll again because IL turns IB off.
.    TRAP OFF
.    HI \\n[#HL_INDENT\\n[#DEPTH]]u
.    if '\\*[$SEPARATOR\\n[#DEPTH]]')' .nr #SEP_TYPE 1
.    if '\\*[$SEPARATOR\\n[#DEPTH]]']' .nr #SEP_TYPE 1
.    if '\\*[$SEPARATOR\\n[#DEPTH]]'}' .nr #SEP_TYPE 1
.    ie \\n[#IN_BIB_LIST]=1 \{\
.       ie \\n[#ENUMERATOR\\n[#DEPTH]]<9 \{\
.          ie \\n[#SEP_TYPE]=1 .PRINT \
\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\
\\n+[#ENUMERATOR\\n[#DEPTH]]\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.          el .PRINT \
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.       \}
.       el \{\
.          ie \\n[#SEP_TYPE]=1 .PRINT \
\h'-\w'\0'u'\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\
\\n+[#ENUMERATOR\\n[#DEPTH]]\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.          el .PRINT \
\h'-\w'\0'u'\
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.       \}
.    \}
.    el \{\
.       ie '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'register' \{\
.\" DIGIT
.          ie '\\g[#ENUMERATOR\\n[#DEPTH]]'0' \{\
.             ie \\n[#PAD_LIST_DIGITS\\n[#DEPTH]]=1 \{\
.                ie \\n[#ENUMERATOR\\n[#DEPTH]]<9 \{\
.                   ie \\n[#SEP_TYPE]=1 .PRINT \
\0\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\
\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                   el .PRINT \
\0\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.                \}
.                el \{\
.                   ie \\n[#SEP_TYPE]=1 .PRINT \
\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\
\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                   el .PRINT \
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.                \}
.             \}
.             el \{\
.                ie \\n[#SEP_TYPE]=1 .PRINT \
\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\
\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                el .PRINT \
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.             \}
.          \}
.          el \{\
.\" ALPHA
.             ie '\\g[#ENUMERATOR\\n[#DEPTH]]'A' \{\
.                ie \\n[#SEP_TYPE]=1 .PRINT \
\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\
\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                el .PRINT \
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.             \}
.\" alpha
.             el .PRINT \
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.          \}
.       \}
.       if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'roman' \{\
.          ie \\n[#PAD_LIST_DIGITS\\n[#DEPTH]]=1 \{\
.\" ROMAN I, padded
.             ie '\\g[#ENUMERATOR\\n[#DEPTH]]'I' \{\
.                ie \\n[#SEP_TYPE]=1 .PRINT \
\h'\\n[#HL_INDENT\\n[#DEPTH]]u'\h'-\w'\\*[$PREFIX\\n[#DEPTH]]\
\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]\0'u'\
\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n[#ENUMERATOR\\n[#DEPTH]]\
\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                el .PRINT \
\h'\\n[#HL_INDENT\\n[#DEPTH]]u'\h'-\w'\\*[$PREFIX\\n[#DEPTH]]\
\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]\
\0'u'\\*[$PREFIX\\n[#DEPTH]]\\n[#ENUMERATOR\\n[#DEPTH]]\
\\*[$SEPARATOR\\n[#DEPTH]]
.             \}
.\" roman i, padded
.             el .PRINT \
\h'\\n[#HL_INDENT\\n[#DEPTH]]u'\h'-\w'\\*[$PREFIX\\n[#DEPTH]]\
\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]\0'u'\
\\*[$PREFIX\\n[#DEPTH]]\\n[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.          \}
.\" No pad
.          el \{\
.\" ROMAN I, no pad
.             ie '\\g[#ENUMERATOR\\n[#DEPTH]]'I' \{\
.                ie \\n[#SEP_TYPE]=1 .PRINT \
\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\
\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                el .PRINT \
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.             \}
.\" roman i, no pad
.             el .PRINT \
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.          \}
.       \}
.       if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'other' \
.          PRINT \\*[$ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.    \}
.    rr #SEP_TYPE
.    EOL
.    if \\n[#REF]=1 \{\
.       IL +\\n[#REF_BIB_INDENT]u
.       ti \\n[#L_INDENT]u-\\n[#REF_BIB_INDENT]u
.    \}
.    TRAP
.    if \\n[#KERN_WAS_ON]=1 \{\
.       KERN
.       rr #KERN_WAS_ON
.    \}
.    if \\n[#LINENUMBERS]=2 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.    \}
.END
\#
\# A utility macro that determines the space to reserve for
\# roman numeral enumerated lists.  Limit is 20 roman numerals
\# per list.  If this isn't enough, the user can add to the
\# macro.
\#
.MAC GET_ROMAN_INDENT END
.    if '\\*[$LIST_ARG_1]'roman' \{\
.       if '\\*[$ROMAN_WIDTH]'1' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 1
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]i\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'2' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 2
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]ii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'3' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 3
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]iii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'4' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 4
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]iii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'5' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 5
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]iii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'6' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 6
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]iii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'7' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 7
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]vii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'8' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 8
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]viii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'9' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 9
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]viii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'10' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 10
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]viii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'11' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 11
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]viii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'12' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 12
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]viii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'13' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 13
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xiii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'14' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 14
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xiii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'15' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 15
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xiii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'16' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 16
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xiii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'17' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 17
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xvii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'18' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 18
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xviii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'19' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 19
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xviii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'20' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 20
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xviii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.    \}
.    if '\\*[$LIST_ARG_1]'ROMAN' \{\
.       if '\\*[$ROMAN_WIDTH]'1' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 1
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]I\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'2' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 2
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]II\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'3' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 3
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]III\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'4' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 4
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]IV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'5' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 5
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]IV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'6' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 6
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]IV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'7' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 7
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]VII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'8' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 8
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]VIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'9' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 9
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]VIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'10' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 10
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]VIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'11' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 11
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]VIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'12' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 12
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]VIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'13' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 13
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'14' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 14
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XIV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'15' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 15
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XIV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'16' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 16
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XIV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'17' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 17
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XVII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'18' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 18
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XVIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'19' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 19
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XVIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'20' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 20
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XVIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.    \}
.END
\#
\# SHIFT LIST
\# ----------
\# *Arguments:
\#   <amount by which to indent a list to the right>
\# *Function:
\#   Adds the value of the arg to the current list's indent.
\# *Notes:
\#   Requires a unit of measure.
\#
.MAC SHIFT_LIST END
.    nr #SHIFT_LIST\\n[#DEPTH] (\\$1)
.    nr #L_INDENT +\\n[#SHIFT_LIST\\n[#DEPTH]]
.END
\#
\# PAD LIST DIGITS
\# ---------------
\# *Arguments:
\#   [ LEFT ]
\# *Function:
\#   Adds a figure space to a list's hanging and left indent.  If
\#   LEFT is given, sets reg. #PAD_LIST_DIGITS to 1 for use in ITEM.
\#
.MAC PAD_LIST_DIGITS END
.    if '\\g[#ENUMERATOR\\n[#DEPTH]]'0' \{\
.       nr #LIST_INDENT\\n[#DEPTH] +\\w'\\0'
.       nr #L_INDENT \\n[#LIST_INDENT\\n[#DEPTH]]+\\n[#LIST_INDENT\\n-[#DEPTH]]
.       nr #HL_INDENT\\n+[#DEPTH] +\\w'\\n[#ENUMERATOR\\n[#DEPTH]]'
.       if '\\$1'LEFT' .nr #PAD_LIST_DIGITS\\n[#DEPTH] 1
.    \}
.    if '\\g[#ENUMERATOR\\n[#DEPTH]]'i' \
.       if '\\$1'LEFT' .nr #PAD_LIST_DIGITS\\n[#DEPTH] 1
.    if '\\g[#ENUMERATOR\\n[#DEPTH]]'I' \
.       if '\\$1'LEFT' .nr #PAD_LIST_DIGITS\\n[#DEPTH] 1
.END
\#
\# RESET LIST
\# ----------
\# *Arguments:
\#   none
\# *Function:
\#   Resets register enumerators to 1 or a.
\#
.MAC RESET_LIST END
.    ie '\\$1'' .nr #ENUMERATOR\\n[#DEPTH] 0 1
.    el .nr #ENUMERATOR\\n[#DEPTH] \\$1-1 1
.END
\#
\# QUIT LISTS
\# ----------
\# *Arguments:
\#   none
\# *Function:
\#   Exits lists cleanly and restores any indents that were in
\#   effect prior to LIST.
\#
.MAC QUIT_LISTS END
.   IQ CLEAR
.   nr #HL_INDENT \\n[#STORED_HL_INDENT]
.   nr #T_INDENT  \\n[#STORED_T_INDENT]
.   rr #STORED_HL_INDENT
.   if \\n[#RESTORE_PREV_INDENT]=1 \{\
.      nr #L_INDENT  \\n[#STORED_L_INDENT]
.      IL
.      rr #STORED_L_INDENT
.   \}
.   if \\n[#RESTORE_PREV_INDENT]=2 \{\
.      nr #BL_INDENT \\n[#STORED_BL_INDENT]
.      nr #BR_INDENT \\n[#STORED_BR_INDENT]
.      ll \\n[#ORIG_L_LENGTH]u
.      IB
.      rr #STORED_BL_INDENT
.      rr #STORED_BR_INDENT
.   \}
.   if \\n[#RESTORE_PREV_INDENT]=3 \{\
.      nr #R_INDENT \\n[#STORED_R_INDENT]
.      ll \\n[#ORIG_L_LENGTH]u
.      IR
.      rr #STORED_R_INDENT
.   \}
.   if \\n[#RESTORE_PREV_INDENT]=4 \{\
.      nr #R_INDENT \\n[#STORED_R_INDENT]
.      nr #L_INDENT \\n[#STORED_L_INDENT]
.      ll \\n[#ORIG_L_LENGTH]u
.      IR
.      IL
.      rr #STORED_R_INDENT
.      rr #STORED_L_INDENT
.   \}
.\" Clean up after exiting last depth of list
.   nr #REMOVE 0 1
.   while \\n+[#REMOVE]<=\\n[#TOTAL_LISTS] \{\
.      rr #LIST_INDENT\\n[#REMOVE]
.      rr #ENUMERATOR\\n[#REMOVE]
.      rm $ENUMERATOR\\n[#REMOVE]
.      rm $SEPARATOR\\n[#REMOVE]
.      rm $ENUMERATOR_TYPE\\n[#REMOVE]
.      rr #PAD_LIST_DIGITS\\n[#REMOVE]
.   \}
.   rr #REMOVE
.   rr #TOTAL_LISTS
.   rr #QUIT
.   rr #DEPTH
.   rr #NEXT_DEPTH_BACK
.   rr #RESTORE_PREV_INDENT
.   rr #ORIG_L_LENGTH
.   rr #CURRENT_L_LENGTH
.   rr #IN_ITEM
.   rr #IN_ITEM_L_INDENT
.END
\#
\# SET LIST INDENT
\# ---------------
\# *Arguments:
\#   none
\# *Function:
\#   Restores indent of prev. list in nested lists.  Also sets the
\#   #QUIT register if an invocation of LIST OFF applies to the first
\#   level of list.
\#
.MAC SET_LIST_INDENT END
.    nr #NEXT_DEPTH_BACK \\n[#DEPTH]-1
.    if \\n[#NEXT_DEPTH_BACK]=0 \{\
.       nr #QUIT 1
.       return
.    \}
.    nr #L_INDENT -\\n[#LIST_INDENT\\n[#DEPTH]]+\\n[#SHIFT_LIST\\n[#DEPTH]]
.    nr #HL_INDENT \\n[#HL_INDENT\\n-[#DEPTH]]
.END
\#
\# ====================================================================
\#
\# +++DOCUMENT PROCESSING MISC AND SUPPORT MACROS+++
\#
\# COLLATE
\# -------
\# *Arguments:
\#   <none>
\# *Function:
\#   Turns headers off (if on) and saves header state, sets register
\#   #COLLATE to 1 (toggle), and breaks to a new page.
\# *Notes:
\#   COLLATE exists primarily to allow putting multiple chapters in
\#   a single file, although it can be used for any document type.  After
\#   COLLATE, any of the macros that normally precede START may be
\#   used, and should behave as expected.
\#
\#   N.B.--the START macro must be used after every COLLATE
\#
.MAC COLLATE END
.    if \\n[defer] \
.       DO_FOOTER
.    EOL
.    nr #COLLATED_DOC 1
.    if ( (\\n[.t]-1) <= \\n[.v] ) .nr #NO_BREAK 1
.    ds $SAVED_DOC_FAM \\*[$DOC_FAM]
.    ds $SAVED_PP_FT   \\*[$PP_FT]
.    nr #COLLATE 1
.    nr #PRE_COLLATE 1
.    nr #HEADER_STATE \\n[#HEADERS_ON]
.    nr #POST_TOP 1
.    nr #ARG_NUM 0 1
.    nr #LOOP \\n[#ACTIVE_LEVELS]      \" loop count                                   
.    nr #HEAD_1_NUM 0 1
.    nr eqn*label-width     (\\n[eqn*label-num] >? \\n[eqn*label-width])
.    nr pdf-img*label-width (\\n[pdf-img*label-num] >? \\n[pdf-img*label-width])
.    nr pic*label-width     (\\n[pic*label-num] >? \\n[pic*label-width])
.    nr tbl*label-width     (\\n[tbl*label-num] >? \\n[tbl*label-width])
.    nr fig*label-width     (\\n[pdf-img*label-width] >? \\n[pic*label-width])
.    if \\n[eqn*label-with-chapter]=1     .nr eqn*label-num     0 1
.    if \\n[pdf-img*label-with-chapter]=1 .nr pdf-img*label-num 0 1
.    if \\n[pic*label-with-chapter]=1     .nr pic*label-num     0 1
.    if \\n[tbl*label-with-chapter]=1     .nr tbl*label-num     0 1
.    if (\\n[defer]=0)&(\\n[float*defer]=0) .HEADERS OFF
.    if \\n[#DOC_HEADER]=2 .nr #DOC_HEADER 1
.    if \\n[#PAGE_NUM_V_POS]=1 \{\
.       nr #PAGINATION_STATE \\n[#PAGINATE]
.       PAGINATION OFF
.    \}
.    IQ CLEAR
.    TQ
.    LL \\n[#DOC_L_LENGTH]u
.    QUAD \\*[$DOC_QUAD]
.    nr #SAVED_DOC_LEAD \\n[#DOC_LEAD]
.    vs \\n[#DOC_LEAD]u
\*[SLANTX]
\*[CONDX]
\*[EXTX]
.    if \\n[#TOC] \{\
.       if \\n[TOC_BH]=1 .pdfswitchtopage before MOM:TOC
.       if \\n[TOC_BH]=2 .pdfswitchtopage after MOM:TOC
.    \}
.    if !\\n[#NO_NEWPAGE] .NEWPAGE
.    rr #NO_NEWPAGE
.    ch RR_@TOP
.    rr @TOP
.    if \\n[.ns] \{\
.      rs
.      nop \&
.    \}
.    if '\\n[.ev]'PAGE_TRANSITION' .ev
.    if \\n[#DEFER_PAGINATION] .PAGINATE
.    if !'\\*[$RESTORE_PAGENUM_STYLE]'' \{\
.       PAGENUM_STYLE \\*[$RESTORE_PAGENUM_STYLE]
.       rm $RESTORE_PAGENUM_STYLE
.    \}
.    if \\n[#CH_NUM] \
.       if \\n[#TOC]=0 .nr #CH_NUM +1
.    rm $EN_TITLE
.    COVERTITLE
.    DOCCOVERTITLE
.    MISC
.    TITLE
.    SUBTITLE
.    CHAPTER
.    CHAPTER_TITLE
.    rr #PAGENUM_STYLE_SET
.    rr #DOC_COVER
.    rr #COVER
.    rr #LAST_LEVEL
.    rr #LEVEL
.    if \\n[#RESTORE_PN_V_POS] \{\
.       nr #PAGE_NUM_V_POS \\n[#RESTORE_PN_V_POS]
.       rr #RESTORE_PN_V_POS
.    \}
.END
\#
\# NUMBER_LINES
\# ------------
\# *Arguments:
\#   <starting line number> [ <increment> [ <gutter> ] ]
\#   or
\#   <anything> | RESUME
\# *Function:
\#   Begin, suspend/turn off, or resume numbering of output lines.
\#
.MAC NUMBER_LINES END
.    br
.    if \\n[#QUOTE] \{\
.       if \\n[#QUOTE]=1 .ds macro QUOTE
.       if \\n[#QUOTE]=2 .ds macro BLOCKQUOTE
.       tm1 "[mom]: \\$0 at line \\n[.c] may not be used inside \\*[macro].
.       tm1 "       Please set NUMBER_LINES before \\*[macro], followed by
.       tm1 "       NUMBER_\\*[macro]_LINES.
.       ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.    \}
.    if '\\n[.z]'EPI_TEXT' .return
.    if '\\$1'' \{\
.       tm1 "[mom]: NUMBER_LINES at line \\n[.c] has no argument.
.       tm1 "       Most likely, you have forgotten to give it a starting line number.
.       ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.    \}
.    if !\\n[#LINENUMBERS]=2 .nr #LINENUMBERS 1
.\" Test whether the first arg is a digit.
.    if \B'\\$1' \{\
.       nr #LN \\$1
.       ds $LN_NUM \\$1
.       if !'\\n[.z]'' .nr #RESTORE_LN_NUM 1
.       ie '\\$2'' \
.          if '\\*[$LN_INC]'' .ds $LN_INC 1
.       el .ds $LN_INC \\$2
.       ie '\\$3'' \
.          if !\\n[#LN_GUTTER] .nr #LN_GUTTER 2
.       el .nr #LN_GUTTER \\$3
.    \}
.    ie !\\n[#LN] \{\
.\" In other words, the first arg was not a digit.
.       rr #LN
.       ie '\\$1'RESUME' \{\
.          LN_PARAMS
.          nm \\*[$LN_NUM]
.          RESTORE_PARAMS
.       \}
.       el \{\
.          nm
.\" register ln is still set and may confuse preprocessors like tbl
.\" still, resuming line numbering must be possible, so save ln in $LN_NUM
.          ds $LN_NUM \\n[ln]
.          if !\\n[#QUOTE] .nr ln 0
.          if !\\n[#LINENUMBERS]=2 .rr #LINENUMBERS
.       \}
.    \}
.    el \{\
.       LN_PARAMS
.       nm \\*[$LN_NUM] \\*[$LN_INC] \\n[#LN_GUTTER] -3-\\n[#LN_GUTTER]
.       RESTORE_PARAMS
.       if !'\\n[.z]'' .nr #DIVER_LN_OFF 1
.    \}
.    rr #LN
.END
\#
\# LINENUMBER STYLE PARAMETERS
\# ---------------------------
\# *Arguments:
\#   none
\# *Function:
\#   LN_PARAMS sets parameters for line numbers.
\#   RESTORE_PARAMS restores them after internal calls to .nm
\#
.MAC LN_PARAMS END
.    ie d$LN_FAM .fam \\*[$LN_FAM]
.    el .fam \\n[.fam]
.    ie d$LN_FT .ft \\*[$LN_FT]
.    el .ft \\n[.sty]
.    ie d$LN_SIZE_CHANGE .ps \\*[$LN_SIZE_CHANGE]
.    el .ps \\n[.s]
.    ie d$LN_COLOR .gcolor \\*[$LN_COLOR]
.    el .gcolor \\n[.m]
.END
\#
.MAC RESTORE_PARAMS END
.    fam
.    ft
.    ps
.    gcolor
.END
\#
\# NUMBER QUOTE AND BLOCKQUOTE LINES AS PART OF RUNNING TEXT
\# ---------------------------------------------------------
\# *Argument:
\#   <gutter> | <anything>
\# *Function:
\#   Sets #(B)QUOTE_LN to 1 if no argument, or a single numeric
\#   argument, is given; otherwise, turns (BLOCK)QUOTE linenumbering
\#   off.
\# *Notes:
\#   #(B)QUOTE is checked for in QUOTE and BLOCKQUOTE.
\#   The single numeric argument allows establishing a different gutter from
\#   the one used for line numbers in running text.
\#
.MAC NUMBER_QUOTE_LINES END
.    ie \\n[#NUM_ARGS]=0 .nr #QUOTE_LN 1
.    el \{\
.       ie \B'\\$1' \{\
.          nr #QUOTE_LN 1
.          nr #Q_LN_GUTTER \\$1
.       \}
.       el \{\
.          ie '\\$1'SILENT' .nr #SILENT_QUOTE_LN 1
.          el \{\
.             rr #QUOTE_LN
.             rr #SILENT_QUOTE_LN
.          \}
.       \}
.    \}
.END
\#
.MAC NUMBER_BLOCKQUOTE_LINES END
.    ie \\n[#NUM_ARGS]=0 .nr #BQUOTE_LN 1
.    el \{\
.       ie \B'\\$1' \{\
.          nr #BQUOTE_LN 1
.          nr #BQ_LN_GUTTER \\$1
.       \}
.       el \{\
.          ie '\\$1'SILENT' .nr #SILENT_BQUOTE_LN 1
.          el \{\
.             rr #BQUOTE_LN
.             rr #SILENT_BQUOTE_LN
.          \}
.       \}
.    \}
.END
\#
\# OUTPUT BLANK PAGES
\# ------------------
\# *Argument:
\#   <number of blank pages to output> [ DIVIDER [ NULL ] ]
\# *Function:
\#   Outputs blank pages.
\# *Notes:
\#   If recto/verso, each page is recto/verso, even if there's
\#   nothing on it.
\#
\#   The 1st argument to BLANKPAGE is non-optional.  DIVIDER is for
\#   blank pages before endnotes, bibliographies, tocs, new chapters.
\#
.MAC BLANKPAGE END
.    nr #HOW_MANY \\$1
.    nr #PAGES 0 1
.    if \\n[#LINENUMBERS] \{\
.       nr #LINENUMBERS_WERE_ON 1
.       NUMBER_LINES OFF
.    \}
.    while \\n+[#PAGES]<=\\n[#HOW_MANY] \{\
.       if \\n[#HEADERS_ON]=1 \{\
.          nr #HEADERS_WERE_ON 1
.          HEADERS OFF
.       \}
.       if \\n[#PAGE_NUM_V_POS]=1 \{\
.          if \\n[#PAGINATE]=1 .nr #PAGINATE_WAS_ON 1
.          PAGINATION OFF
.       \}
.       NEWPAGE
.       PRINT \&
.       if \\n[#FOOTERS_ON]=1 \{\
.          nr #FOOTERS_WERE_ON 1
.          FOOTERS OFF
.       \}
.       if \\n[#PAGE_NUM_V_POS]=2 \{\
.          if \\n[#PAGINATE]=1 .nr #PAGINATE_WAS_ON 1
.             nr #RESTORE_PN_V_POS \\n[#PAGE_NUM_V_POS]
.          PAGINATION OFF
.       \}
.       if \\n[#HEADERS_WERE_ON] .HEADERS
.       if \\n[#PAGE_NUM_V_POS]=1 \
.          if \\n[#PAGINATE_WAS_ON] .PAGINATE
.    \}
.    shift
.    ie '\\$1'DIVIDER' \{\
.       if \\n[#FOOTERS_WERE_ON] .FOOTERS
.       if \\n[#RESTORE_PN_V_POS]=2 \{\
.          if \\n[#PAGINATE_WAS_ON] .nr #RESTORE_PAGINATION 1
.       \}
.       shift
.       if '\\$1'NULL' .nr #PAGE_NUM_ADJ -\\n[#HOW_MANY]
.    \}
.    el \{\
.       if '\\$1'' \{\
.          NEWPAGE
.          if \\n[#FOOTERS_WERE_ON] .FOOTERS
.          if \\n[#PAGE_NUM_V_POS]=2 \
.             if \\n[#PAGINATE_WAS_ON] .PAGINATE
.       \}
.       if '\\$1'NULL' \{\
.          NEWPAGE
.          if \\n[#FOOTERS_WERE_ON] .FOOTERS
.          if \\n[#PAGE_NUM_V_POS]=2 \
.             if \\n[#PAGINATE_WAS_ON] .PAGINATE
.       \}
.    \}
.    if \\n[#PAGINATE]=1 \
.       if '\\$1'NULL' .nr #PAGE_NUM_ADJ -\\n[#HOW_MANY]
.    if \\n[#LINENUMBERS_WERE_ON] .NUMBER_LINES RESUME
.    rr #HOW_MANY
.    rr #HEADERS_WERE_ON
.    rr #FOOTERS_WERE_ON
.    rr #PAGINATE_WAS_ON
.END
\#
\# FLOATS
\# ------
\#
.am PSPIC \" Need to do this for PSPIC inside a float
.  vpt 0
\h'(\\n[ps-offset]u + \\n[ps-deswid]u)'
.  sp -1
.  vpt 1
..
\#
.MAC PROCESS_FLOATS END
.    if (\\n[float*defer]>0):(\\n[defer]=0) \{\
.        if !\\n[tbl*no-top-hook] .tbl@top-hook
.        rr tbl*no-top-hook
.    \}
.    if \\n[defer] \{\
.       ev protect
.       evc FLOAT
.       nf
.       rs
.       nop \&
.       sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.       if '\\*[float*type:1]'boxed-tbl' \{\
.          ch RR_@TOP
.          if (\\n[.t] >= 1)&(\\n[float-depth:1] > \\n[.t]) \
.             tbl*float-warning
.          if \\n[#MLA] .sp \\n[tbl*label-lead-diff]u
.          if (\\n[tbl*have-caption]=1)&(\\n[tbl*caption-after-label]=0) \
.             sp \\n[tbl*caption-lead-diff]u
.          if \\n[tbl*caption-after-label] .sp 1n+(\\n[tbl*caption-lead-diff]u*2u)
.       \}
.       if \\n[float*pic] \{\
.          if (\\n[pic*have-caption]=1)&(\\n[pic*caption-after-label]=0) \{\
.             ie \\n[#COLUMNS] \{\
.                sp |\\n[dc]u-.5v
.             \}
.             el \
.                sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u-.5v
.          \}
.          rr pic*caption-lead-diff
.          rr pic*top-lead-diff
.          rr float*pic
.       \}
.       if \\n[float*img] \{\
.             ie \\n[#COLUMNS] \
.                sp |\\n[dc]u
.             el \
.                sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.       \}
.       nr defer-count \\n[defer]
.       nr loop-count  0 1
.       nr new-defer   0 1
.       while \\n+[loop-count]<=\\n[defer-count] \{\
.          nr tbl*no-top-hook 1
.          if \\n[defer] .rnn defer float*defer \" So '.if \n[defer]' is skipped during float output
.          vpt
.          ch RR_@TOP
.          rr @TOP
.          if \\n[pdf-img*have-caption] \{\
.             if !\\n[pdf-img*caption-after-label] .sp -.5v
.          \}
.          rr pdf-img*have-caption
.          rr pic*have-caption
.          if '\\*[float*type:\\n[loop-count]]'table' \{\
.             ch FOOTER \\n[#VARIABLE_FOOTER_POS]u+\\n[#DOC_LEAD]u
.             ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u+\\n[#DOC_LEAD]u
.          \}
.          ie !\\n[float-span:\\n[loop-count]] \{\
.             ie ((\\n[float-depth:\\n[loop-count]]-\\n[.v])>\\n[.t]):(\\n[D-float:\\n[loop-count]]>\\n[.t]) \{\
.\" Insufficient space, defer to next page
.                rn FLOAT*DIV:\\n[loop-count] NEW*FLOAT*DIV:\\n+[new-defer]
.                rnn float-depth:\\n[loop-count] new-float-depth:\\n[new-defer]
.                rnn D-float:\\n[loop-count] new-D-float:\\n[new-defer]
.             \}
.             el \{\
.                output-float
.             \}
.          \}
.          el \{\
.             rr tbl*no-top-hook
.             output-float
.          \}
.       \}
.       rm FLOAT*DIV:\\n[loop-count]
.       rr float-depth:\\n[loop-count]
.       rm tbl*header-div:\\n[loop-count]
.       rm float*type:\\n[loop-count]
.\" FLOAT arrays are empty now
.\" Rename new arrays (FLOATs deferred to next page) to proper names
.       nr loop-count 0 1
.       rnn new-defer defer
.       while \\n+[loop-count]<=\\n[defer] \{\
.          rn NEW*FLOAT*DIV:\\n[loop-count] FLOAT*DIV:\\n[loop-count]
.          rnn new-float-depth:\\n[loop-count] float-depth:\\n[loop-count]
.          rnn new-D-float:\\n[loop-count] D-float:\\n[loop-count]
.       \}
.       rr float*defer
.       ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.       ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u
.       ev
.       SHIM
.       if \\n[#SHIM]>(\\n[#DOC_LEAD]-(\\n[#DOC_LEAD]/4)) 'sp -\\n[#DOC_LEAD]u
.       nr tbl*have-header 0
.       rr loop-count
.       rr defer-count
.       rr float*before-shim
.       rr float*after-shim
.       rm float-adj
.       rm float-adj:top
.       rm float-adj:bottom
.       if \\n[#NEWPAGE] \{\
.          vpt
'          bp
.          rr #NEWPAGE
.       \}
.    \}
.    rr float*img
.    rr float*eqn
.    rr float*tbl
.    rr float*pic
.END
\#
.MAC output-float END
.    vpt 0
.    nop \&
.    sp -1
.    if \\n[no-top-space] \{\
.       ie !\\n[#COLUMNS] \{\
.          sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.          ns
.       \}
.       el .sp |\\n[dc]u
.       if \\n[float*tbl] \{\
.          rs
.          if \\n[tbl*caption-top-lead-diff] \{\
.             sp \\n[tbl*caption-top-lead-diff]u
.             rr tbl*caption-top-lead-diff
.          \}
.          rr float*tbl
.       \}
.    \}
.    if \\n[float*pic] \{\
.       nr pic*top-space-adj \\n[#DOC_LEAD]-\\n[pic@text-lead]
.       if (\\n[pic*have-caption]=0):(\\n[pic*caption-after-label]=1) \{\
.          sp \\n[pic*top-space-adj]u
.       \}
.       if \\n[#COLUMNS] \{\
.          if !'\\*[pic*space-adj]'' .sp \\*[pic*space-adj]
.       \}
.       rr float*pic
.    \}
.    if \\n[float*eqn] \{\
.       sp -.5v
.       rr float*eqn
.    \}
.    FLOAT*DIV:\\n[loop-count]
.    if \\n[no-top-space] \{\
.       rs
.       nop \&
.       sp -1
.       rr no-top-space
.    \}
.    if \\n[#COLUMNS] \
.       if !'\\*[pic*space-adj]'' .sp -\\*[pic*space-adj]
.    rm pic*space-adj
.    if \\n[D-float:\\n[loop-count]] \{\
.       sp \
-\\n[float-depth:\\n[loop-count]]u+\\n[D-float:\\n[loop-count]]u+\\n[#DOC_LEAD]u
.       rr D-float:\\n[loop-count]
.    \}
.END
\#
\# FLOAT
\# -----
\# *Arguments:
\#   [ ADJUST +|-<amount> ] [ FORCE] [ SPAN] [ NO_SHIM] | <anything>
\# *Function:
\#   Captures input in a diversion, which is output immediately if
\#   there's room on the page; otherwise outputs diversion at top of
\#   next page.
\# *Notes:
\#   ADJUST allows for raising or lowering the contents of
\#   the diversion within the space allotted.  FORCE breaks to
\#   a new page immediately.
\#
.MAC FLOAT END
.\"  Case where upcoming .br breaks to a new page, causing a defered float
.\"  to be output by HEADER and the defer register to be cleared.
.    nr pagenum \\n%+\\n[#PAGE_NUM_ADJ]
.    br
.\" Clear .ns when a single line of running text precededs float
.\" at the top of the page.
.    if \\n[nl]=\\n[#PAGE_TOP] \{\
.       vpt 0
.       sp -1v
.       sp
.       ch RR_@TOP
.       rr @TOP
.       vpt
.    \}
.    if \\n[#NUM_ARGS]>0 \{\
.    nr loop-count 0 1
.    nr loop-counter \\n[#NUM_ARGS]
.       while \\n+[loop-count]<=\\n[loop-counter] \{\
.          if '\\$1'FORCE' \{\
.             nr #FORCE 1
.             shift
.          \}
.          if '\\$1'SPAN' \{\
.              nr float-span 1
.              shift
.          \}
.          if '\\$1'ADJUST' \{\
.             shift
.             ds float-adj \\$1
.             shift
.          \}
.          if '\\$1'NO_SHIM' \{\
.             nr float*no-shim 1
.             shift
.          \}
.       \}
.    \}
.    ie '\\$1'' \{\
.       ev FLOAT
.       evc 0
.       nf
.       di FLOAT*DIV
.    \}
.    el \{\
.       br
.       di
.       if \\n[float*table] \
.          if !\\n[tbl*have-header] .ev
.       ev
.       if \\n[tbl*boxed] \{\
.          ie !\\n[#MLA] \{\
.             ie (\\n[tbl@label]=1):(\\n[tbl@source]=1) .nr dn -.65v
.             el .nr dn +.65v
.          \}
.          el \{\
.             if !\\n[tbl@source] .nr dn -1.65v
.          \}
.       \}
.       if (\\n[dn]>\\n[.t]):(\\n[D-float]>\\n[.t]) \{\
.          ie \\n[@TOP] \
.             if \\n[tbl*boxed] .rs
.          el \{\
.             if !\\n[defer] .nr defer 0 1
.             rn FLOAT*DIV FLOAT*DIV:\\n+[defer]
.             if \\n[float-span] \
.                if !\\n[tbl*boxed] .rnn float-span float-span:\\n[defer]
.             if \\n[float*tbl] \{\
.                if \\n[defer]=1 .nr no-top-space 1
.                ie \\n[tbl*boxed] \{\
.                   ds float*type:\\n[defer] boxed-tbl
.                   rr float-span
.                \}
.                el .ds float*type:\\n[defer] table
.                if \\n[tbl*center] .nr float*tbl-center:\\n[defer] 1
.                rn tbl*header-div tbl*header-div:\\n[defer]
.                rr tbl*center
.             \}
.             if \\n[float*eqn] \{\
.                if \\n[defer]=1 .nr no-top-space 1
.                ds float*type:\\n[defer] eqn
.             \}
.             if \\n[float*pic] \{\
.                ds float*type:\\n[defer] pic
.             \}
.             if \\n[float*img] \{\
.                ds float*type:\\n[defer] img
.             \}
.             if \\n[D-float] .nr D-float:\\n[defer] \\n[D-float]
.             nr float-depth:\\n[defer] \\n[dn]
.             if \\n[#FORCE] \{\
.                bp
.                rr #FORCE
.             \}
.             return \" output div after header
.          \}
.       \}
.       if !'\\*[float-adj]'' .sp \\*[float-adj]
.       if \\n[.u] .nr fill 1
.       if \\n[@TOP] \{\
.          nr no-adjust 1
.          rr @TOP
.       \}
.       nf
.       if \\n[float*tbl] \
.          if (\\n[#MLA]=1)&(\\n[tbl@source]=0) \
.             chop FLOAT*DIV
.          if \\n[nl]=\\n[#PAGE_TOP] \{\
.             if \\n[tbl*have-caption] \{\
.                ie !\\n[#MLA] .sp \\n[tbl*caption-lead-diff]u
.                el \{\
.                ch RR_@TOP
.                sp \\n[tbl*label-lead-diff]u-.5v
.             \}
.          \}
.       \}
.       FLOAT*DIV
.       if \\n[float*tbl] \{\
.          ie \\n[tbl*boxed] \{\
.             if \\n[dn]=\\n[bx-tbl-depth] .sp .35v
.             if \\n[tbl*plain-boxed] .sp .5v
.             ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.             ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u
.             rr tbl*boxed
.             rr bx-tbl-depth
.          \}
.          el \{\
.             if '\\*[tbl*label]'' \
.                if \\n[tbl*autolabel]=0 .sp
.          \}
.          rr float*tbl
.          rr tbl*center
.          rm tbl*header-div
.          rr tbl*have-caption
.          rr tbl*have-label
.          rr tbl*have-source
.          rm tbl*caption
.          rm tbl*label
.          rm tbl*source
.       \}
.       if \\n[D-float] \
.          sp -\\n[dn]u+\\n[#DOC_LEAD]u+\\n[D-float]u
.       if \\n[fill] \{\
.          fi
.          rr fill
.       \}
.       rm FLOAT*DIV
.       if !'\\*[float-adj]'' \
.          if !\\n[no-adjust] .sp -\\*[float-adj]
.          if !\\n[float*no-shim] .SHIM
.       rm float-adj
.       rm no-adjust
.       rm float-adj:top
.       rm float-adj:bottom
.       rr D-float
.       rr float*no-shim
.       rr #FORCE
.    \}
.END
\#
\# SET TRAPS FOR HEADERS/FOOTERS/FOOTNOTES
\# ---------------------------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Sets header/footer/footnotes/etc... traps.
\#
\#   Calculates the number of lines that actually fit on a
\#   page based on #B_MARGIN and resets page bottom trap to coincide
\#   with the depth of that number of lines, or, if #ADJ_DOC_LEAD=1,
\#   adjusts #DOC_LEAD so that the last line of text on a page falls
\#   exactly on #B_MARGIN.
\#
.MAC RR_@TOP END \" Trap-invoked after first line of text on a new page
.    rr @TOP
.    if \\n[.ns] \{\
.       vpt 0
.       rs
.       if \\n[.u] .nr fill 1
.       nf
.       nop \&
.       sp -1
.       if \\n[fill] .fi
.    \}
.    if \\n[.vpt]=0 .vpt
.END
\#
.MAC TRAPS END
.    if !\\n[#UNADJUSTED_DOC_LEAD]  .nr #UNADJUSTED_DOC_LEAD \\n[#DOC@LEAD]
.\" Remove all header/footer traps
.    if !\\n[#NO_TRAP_RESET] \{\
.       ch DO_T_MARGIN
.       ch DO_B_MARGIN
.       ch HEADER
.       ch FOOTER
.       ch FN_OVERFLOW_TRAP
.\" Plant header trap
.       wh 0 HEADER
.    \}
.\" Adjust lead so last line of text falls on B_MARGIN
.       nr #LINES_PER_PAGE 0 1
.       nr #DOC_LEAD_ADJ 0 1
.       nr #DEPTH_TO_B_MARGIN \\n[#PAGE_LENGTH]-\\n[#ORIGINAL_B_MARGIN]-\\n[#DOC_LEAD]
.\" Get the number of unadjusted lines that fit on the page; always a
.\" bit short of the bottom margin
.       while \\n[#T_MARGIN]+(\\n[#DOC_LEAD]*\\n+[#LINES_PER_PAGE])<\\n[#DEPTH_TO_B_MARGIN] \{\
.
.       \}
.       nr #LINES_PER_PAGE -1
.\" Add machine units, 1 at a time, increasing the leading until the
.\" new leading fills the page properly
.       while \\n[#T_MARGIN]+(\\n[#DOC_LEAD]+\\n+[#DOC_LEAD_ADJ]*\\n[#LINES_PER_PAGE])<=\\n[#DEPTH_TO_B_MARGIN] \{\
.
.       \}
.       DOC_LEAD \\n[#DOC_LEAD]u+\\n[#DOC_LEAD_ADJ]u
.\" The "visual" bottom margin is what \n[nl] would report on the
.\" last line before the FOOTER trap is sprung
.       nr #VISUAL_B_MARGIN \\n[#T_MARGIN]+(\\n[#LINES_PER_PAGE]*\\n[#DOC_LEAD])
.\" Get the difference between #B_MARGIN and #VISUAL_B_MARGIN
.       nr #FOOTER_DIFF (\\n[#PAGE_LENGTH]-\\n[#B_MARGIN])-\\n[#VISUAL_B_MARGIN]
.\" Set #B_MARGIN to 1 machine unit lower on the page than #VISUAL_B_MARGIN
.       nr #B_MARGIN \\n[#B_MARGIN]+(\\n[#FOOTER_DIFF]-1)
.\" Set the FN_OVERFLOW_TRAP position
.       nr #FN_OVERFLOW_TRAP_POS \\n[#B_MARGIN]-\\n[#FN_LEAD]
.       if \\n[#PRINT_STYLE]=1 .nr #FN_OVERFLOW_TRAP_POS \\n[#ORIGINAL_B_MARGIN]u
.\" Set footer and footnote overflow traps
.    if !\\n[#NO_TRAP_RESET] \{\
.       nr #FN_COUNT 0 1
.       nr #SPACE_REMAINING 0
.       nr #FN_DEPTH 0
.       nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]u
.       wh \\n[.p]u FOOTER
.       wh -(\\n[#FN_OVERFLOW_TRAP_POS]u) FN_OVERFLOW_TRAP
.       ch FOOTER -\\n[#B_MARGIN]u
.    \}
.END
\#
\# CHECK INDENT
\# ------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Adds left, right, or both indent values to document elements
\#   like heads and subheads that are processed in environments.
\#
.MAC CHECK_INDENT END
.    if \\n[#INDENT_LEFT_ACTIVE] \{\
.       in \\n[#L_INDENT]u
.       if \\n[#QUOTE] \{\
.          in -\\n[#L_INDENT]u \"Because you added an indent in 2nd line of macro
.          ll -\\n[#L_INDENT]u
.          ta \\n[.l]u
.       \}
.       if \\n[#EPIGRAPH] \{\
.          in -\\n[#L_INDENT]u
.          ll -\\n[#L_INDENT]u
.          ta \\n[.l]u
.       \}
.    \}
.    if \\n[#INDENT_RIGHT_ACTIVE] \{\
.       ll -\\n[#R_INDENT]u
.       ta \\n[.l]u
.    \}
.    if \\n[#INDENT_BOTH_ACTIVE] \{\
.       in \\n[#BL_INDENT]u
.       ll -\\n[#BR_INDENT]u
.       ta \\n[.l]u
.       if \\n[#QUOTE] \{\
.          in -\\n[#BL_INDENT]u
.          ie \\n[#BR_INDENT]=\\n[#BL_INDENT] \{\
.             ll -\\n[#BR_INDENT]u
.             ta \\n[.l]u
.          \}
.          el \{\
.             ll -(\\n[#BR_INDENT]u/2u)
.             ta \\n[.l]u
.          \}
.       \}
.       if \\n[#EPIGRAPH] \{\
.          in -\\n[#BL_INDENT]u
.          ie \\n[#BR_INDENT]=\\n[#BL_INDENT] \{\
.             ll -\\n[#BR_INDENT]u
.             ta \\n[.l]u
.          \}
.          el \{\
.             ll -(\\n[#BR_INDENT]u/2u)
.             ta \\n[.l]u
.          \}
.       \}
.    \}
.END
\#
\# REMOVE INDENT
\# -------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Removes left, right, or both indent values from document elements
\#   like heads and subheads that are processed in environments.
\#
.MAC REMOVE_INDENT END
.    in 0
.    ll \\n[#L_LENGTH]u
.    ta \\n[.l]u
.END
\#
\# This .em (for all DOC_TYPEs, except 4 [LETTER]) ensures that
\# deferred footnotes that happen on the 2nd to last page get
\# output.
\#
.MAC TERMINATE END
.    ie \\n[#FN_DEPTH] \{\
.       ie \\n[#FN_DEFER] \{\
.          br
.          nr #TERMINATE 1
.          FOOTNOTE
.          nf
.          FOOTNOTE OFF
.       \}
.       el \{\
.          br
.          ch FN_OVERFLOW_TRAP
.          DO_FOOTER
.       \}
.    \}
.    el \{\
.       ch FN_OVERFLOW_TRAP
.       DO_FOOTER
.    \}
.END
\#
\# END MACRO FOR LETTERS
\# ---------------------
\# *Arguments:
\#   none
\# *Function:
\#   The .em macro executed at the end of letters.  Turns footers
\#   and pagination off, terminates and outputs diversion CLOSING
\#   (indented with the author's name underneath).
\#
.MAC ALL_DONE END
.    ch FOOTER
.    ch HEADER
.    br
.    if \\n[#DOC_TYPE]=4 \{\
.       if !'\\n[.z]'' \{\
.          br
.          ALD \\*[$SIG_SPACE]
.          di
.       \}
.       IQ CLEAR
.       TQ
.       LEFT
.       ie !'\\*[$CLOSE_INDENT]'' .IL \\*[$CLOSE_INDENT]
.       el .IL \\n[#DOC_L_LENGTH]u/2u
.       SP
.       if \\n[#CLOSING] \{\
.          CLOSING_TEXT
.          br
.       \}
.       PRINT \\*[$AUTHOR_1]
.    \}
.END
\#
\# Set up a default papersize of US letter
\#
.PAPER LETTER
\#
\# ====================================================================
\#
\# +++DOCUMENT PROCESSING ALIASES+++
\#
\# Aliases to make life easier for users: synonyms, short forms
\# and alternate spellings.
\#
.ALIAS   BREAK_BLOCKQUOTE    BREAK_QUOTE
.ALIAS   BREAK_CITATION      BREAK_QUOTE
.ALIAS   BREAK_CITE          BREAK_QUOTE
.ALIAS   BLOCKQUOTE_INDENT   QUOTE_INDENT
.ALIAS   CITATION            BLOCKQUOTE
.ALIAS   CITATION_FAMILY     BLOCKQUOTE_FAMILY
.ALIAS   CITATION_FONT       BLOCKQUOTE_FONT
.ALIAS   CITATION_SIZE       BLOCKQUOTE_SIZE
.ALIAS   CITATION_COLOR      BLOCKQUOTE_COLOR
.ALIAS   CITATION_QUAD       BLOCKQUOTE_QUAD
.ALIAS   CITE                BLOCKQUOTE
.ALIAS   CITE_FAMILY         BLOCKQUOTE_FAMILY
.ALIAS   CITE_FONT           BLOCKQUOTE_FONT
.ALIAS   CITE_SIZE           BLOCKQUOTE_SIZE
.ALIAS   CITE_COLOR          BLOCKQUOTE_COLOR
.ALIAS   CITE_QUAD           BLOCKQUOTE_QUAD
.ALIAS   DOC_R_MARGIN        DOC_RIGHT_MARGIN
.ALIAS   DOC_L_MARGIN        DOC_LEFT_MARGIN
.ALIAS   DOC_L_LENGTH        DOC_LINE_LENGTH
.ALIAS   DOC_RMARGIN         DOC_RIGHT_MARGIN
.ALIAS   DOC_LMARGIN         DOC_LEFT_MARGIN
.ALIAS   DOC_LLENGTH         DOC_LINE_LENGTH
.ALIAS   DOC_FAM             DOC_FAMILY
.ALIAS   DOC_LS              DOC_LEAD
.ALIAS   DOC_PS              DOC_PT_SIZE
.ALIAS   FILL                QUAD
.ALIAS   PAGENUM             PAGENUMBER
.ALIAS   PAGINATION          PAGINATE
.ALIAS   PP_FT               PP_FONT
.ALIAS   REF_INDENT          INDENT_REFS
.ALIAS   TOC_PS              TOC_PT_SIZE
\#
\# HEADER and FOOTER macros
\# ------------------------
\# Because the type-style of headers and footers are managed
\# identically, and the type-style macros (_<type parameter>) all
\# require the correct name of the calling macro, it's necessary
\# to create HEADER_ and FOOTER_ macros here.  They're basically
\# aliases of HDRFTR_, but required because you can't alias an
\# alias.
\#
.MAC FOOTER_CENTER_COLOR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC FOOTER_CENTER_COLOUR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC FOOTER_CENTER_FAM END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC FOOTER_CENTER_FAMILY END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC FOOTER_CENTER_FONT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC FOOTER_CENTER_FT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC FOOTER_CENTER_PS END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC FOOTER_CENTER_SIZE END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC FOOTER_CENTRE_CAPS END
.    HDRFTR_CENTER_CAPS \\$1
.END
\#
.MAC FOOTER_CENTRE_COLOR END
.    HDRFTR_CENTRE_COLOR \\$1
.END
\#
.MAC FOOTER_CENTRE_COLOUR END
.    HDRFTR_CENTRE_COLOR \\$1
.END
\#
.MAC FOOTER_CENTRE_FAM END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC FOOTER_CENTRE_FAMILY END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC FOOTER_CENTRE_FONT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC FOOTER_CENTRE_FT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC FOOTER_CENTRE_PS END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC FOOTER_CENTRE_SIZE END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC FOOTER_COLOR END
.    HDRFTR_COLOR \\$1
.END
\#
.MAC FOOTER_COLOUR END
.    HDRFTR_COLOR \\$1
.END
\#
.MAC FOOTER_FAM END
.    HDRFTR_FAMILY \\$1
.END
\#
.MAC FOOTER_FAMILY END
.    HDRFTR_FAMILY \\$1
.END
\#
.MAC FOOTER_LEFT_COLOR END
.    HDRFTR_LEFT_COLOR \\$1
.END
\#
.MAC FOOTER_LEFT_COLOUR END
.    HDRFTR_LEFT_COLOR \\$1
.END
\#
.MAC FOOTER_LEFT_FAM END
.    HDRFTR_LEFT_FAMILY \\$1
.END
\#
.MAC FOOTER_LEFT_FAMILY END
.    HDRFTR_LEFT_FAMILY \\$1
.END
\#
.MAC FOOTER_LEFT_FONT END
.    HDRFTR_LEFT_FONT \\$1
.END
\#
.MAC FOOTER_LEFT_FT END
.    HDRFTR_LEFT_FONT \\$1
.END
\#
.MAC FOOTER_LEFT_PS END
.    HDRFTR_LEFT_SIZE \\$1
.END
\#
.MAC FOOTER_LEFT_SIZE END
.    HDRFTR_LEFT_SIZE \\$1
.END
\#
.MAC FOOTER_RIGHT_COLOR END
.    HDRFTR_RIGHT_COLOR \\$1
.END
\#
.MAC FOOTER_RIGHT_COLOUR END
.    HDRFTR_RIGHT_COLOR \\$1
.END
\#
.MAC FOOTER_RIGHT_FAM END
.    HDRFTR_RIGHT_FAMILY \\$1
.END
\#
.MAC FOOTER_RIGHT_FAMILY END
.    HDRFTR_RIGHT_FAMILY \\$1
.END
\#
.MAC FOOTER_RIGHT_FONT END
.    HDRFTR_RIGHT_FONT \\$1
.END
\#
.MAC FOOTER_RIGHT_FT END
.    HDRFTR_RIGHT_FONT \\$1
.END
\#
.MAC FOOTER_RIGHT_PS END
.    HDRFTR_RIGHT_SIZE \\$1
.END
\#
.MAC FOOTER_RIGHT_SIZE END
.    HDRFTR_RIGHT_SIZE \\$1
.END
\#
.MAC FOOTER_RULE_COLOR END
.    HDRFTR_RULE_COLOR \\$1
.END
\#
.MAC FOOTER_SIZE END
.    HDRFTR_SIZE \\$1
.END
\#
.MAC HEADER_CENTER_COLOR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC HEADER_CENTER_COLOUR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC HEADER_CENTER_FAM END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC HEADER_CENTER_FAMILY END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC HEADER_CENTER_FONT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC HEADER_CENTER_FT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC HEADER_CENTER_PS END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC HEADER_CENTER_SIZE END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC HEADER_CENTRE_COLOR END
.    HDRFTR_CENTRE_COLOR \\$1
.END
\#
.MAC HEADER_CENTRE_COLOUR END
.    HDRFTR_CENTRE_COLOR \\$1
.END
\#
.MAC HEADER_CENTRE_FAM END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC HEADER_CENTRE_FAMILY END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC HEADER_CENTRE_FONT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC HEADER_CENTRE_FT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC HEADER_CENTRE_PS END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC HEADER_CENTRE_SIZE END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC HEADER_COLOR END
.    HDRFTR_COLOR \\$1
.END
\#
.MAC HEADER_COLOUR END
.    HDRFTR_COLOR \\$1
.END
\#
.MAC HEADER_FAM END
.    HDRFTR_FAMILY \\$1
.END
\#
.MAC HEADER_FAMILY END
.    HDRFTR_FAMILY \\$1
.END
\#
.MAC HEADER_LEFT_COLOR END
.    HDRFTR_LEFT_COLOR \\$1
.END
\#
.MAC HEADER_LEFT_COLOUR END
.    HDRFTR_LEFT_COLOR \\$1
.END
\#
.MAC HEADER_LEFT_FAM END
.    HDRFTR_LEFT_FAMILY \\$1
.END
\#
.MAC HEADER_LEFT_FAMILY END
.    HDRFTR_LEFT_FAMILY \\$1
.END
\#
.MAC HEADER_LEFT_FONT END
.    HDRFTR_LEFT_FONT \\$1
.END
\#
.MAC HEADER_LEFT_FT END
.    HDRFTR_LEFT_FONT \\$1
.END
\#
.MAC HEADER_LEFT_PS END
.    HDRFTR_LEFT_SIZE \\$1
.END
\#
.MAC HEADER_LEFT_SIZE END
.    HDRFTR_LEFT_SIZE \\$1
.END
\#
.MAC HEADER_RIGHT_COLOR END
.    HDRFTR_RIGHT_COLOR \\$1
.END
\#
.MAC HEADER_RIGHT_COLOUR END
.    HDRFTR_RIGHT_COLOR \\$1
.END
\#
.MAC HEADER_RIGHT_FAM END
.    HDRFTR_RIGHT_FAMILY \\$1
.END
\#
.MAC HEADER_RIGHT_FAMILY END
.    HDRFTR_RIGHT_FAMILY \\$1
.END
\#
.MAC HEADER_RIGHT_FONT END
.    HDRFTR_RIGHT_FONT \\$1
.END
\#
.MAC HEADER_RIGHT_FT END
.    HDRFTR_RIGHT_FONT \\$1
.END
\#
.MAC HEADER_RIGHT_PS END
.    HDRFTR_RIGHT_SIZE \\$1
.END
\#
.MAC HEADER_RIGHT_SIZE END
.    HDRFTR_RIGHT_SIZE \\$1
.END
\#
.MAC HEADER_RULE_COLOR END
.    HDRFTR_RULE_COLOR \\$1
.END
\#
.MAC HEADER_SIZE END
.    HDRFTR_SIZE \\$1
.END
\#
\# HEADER and FOOTER aliases for HDRFTR macros.
\#
.ALIAS   BIBLIOGRAPHY_FOOTER_CENTER    BIBLIOGRAPHY_HDRFTR_CENTER
.ALIAS   BIBLIOGRAPHY_FOOTER_CENTRE    BIBLIOGRAPHY_HDRFTR_CENTRE
.ALIAS   BIBLIOGRAPHY_HEADER_CENTER    BIBLIOGRAPHY_HDRFTR_CENTER
.ALIAS   BIBLIOGRAPHY_HEADER_CENTRE    BIBLIOGRAPHY_HDRFTR_CENTRE
.ALIAS   ENDNOTES_FOOTER_CENTER    ENDNOTES_HDRFTR_CENTER
.ALIAS   ENDNOTES_FOOTER_CENTRE    ENDNOTES_HDRFTR_CENTRE
.ALIAS   ENDNOTES_HEADER_CENTER    ENDNOTES_HDRFTR_CENTER
.ALIAS   ENDNOTES_HEADER_CENTRE    ENDNOTES_HDRFTR_CENTRE
.ALIAS   FOOTER_CENTER_CAPS        HDRFTR_CENTER_CAPS
.ALIAS   FOOTER_CENTER             HDRFTR_CENTER
.ALIAS   FOOTER_CENTER_PAD         HDRFTR_CENTER_PAD
.ALIAS   FOOTER_CENTRE             HDRFTR_CENTER
.ALIAS   FOOTER_CENTRE_PAD         HDRFTR_CENTER_PAD
.ALIAS   FOOTER_LEFT_CAPS          HDRFTR_LEFT_CAPS
.ALIAS   FOOTER_LEFT               HDRFTR_LEFT
.ALIAS   FOOTER_PLAIN              HDRFTR_PLAIN
.ALIAS   FOOTER_RECTO              HDRFTR_RECTO
.ALIAS   FOOTER_RIGHT_CAPS         HDRFTR_RIGHT_CAPS
.ALIAS   FOOTER_RIGHT              HDRFTR_RIGHT
.ALIAS   FOOTER_RULE_GAP           HDRFTR_RULE_GAP
.ALIAS   FOOTER_RULE               HDRFTR_RULE
.ALIAS   FOOTER_VERSO              HDRFTR_VERSO
.ALIAS   HEADER_CENTER_CAPS        HDRFTR_CENTER_CAPS
.ALIAS   HEADER_CENTER             HDRFTR_CENTER
.ALIAS   HEADER_CENTER_PAD         HDRFTR_CENTER_PAD
.ALIAS   HEADER_CENTRE_CAPS        HDRFTR_CENTER_CAPS
.ALIAS   HEADER_CENTRE             HDRFTR_CENTER
.ALIAS   HEADER_CENTRE_PAD         HDRFTR_CENTER_PAD
.ALIAS   HEADER_LEFT_CAPS          HDRFTR_LEFT_CAPS
.ALIAS   HEADER_LEFT               HDRFTR_LEFT
.ALIAS   HEADER_PLAIN              HDRFTR_PLAIN
.ALIAS   HEADER_RECTO              HDRFTR_RECTO
.ALIAS   HEADER_RIGHT_CAPS         HDRFTR_RIGHT_CAPS
.ALIAS   HEADER_RIGHT              HDRFTR_RIGHT
.ALIAS   HEADER_RULE_GAP           HDRFTR_RULE_GAP
.ALIAS   HEADER_RULE               HDRFTR_RULE
.ALIAS   HEADER_VERSO              HDRFTR_VERSO
.ALIAS   SWITCH_FOOTERS            SWITCH_HDRFTR
.ALIAS   SWITCH_HEADERS            SWITCH_HDRFTR
\#
\# Type-style aliases
\#
.ALIAS   AUTHOR_FAMILY                    _FAMILY
.ALIAS   BIBLIOGRAPHY_FAMILY              _FAMILY
.ALIAS   BIBLIOGRAPHY_STRING_FAMILY       _FAMILY
.ALIAS   BLOCKQUOTE_FAMILY                _FAMILY
.ALIAS   CHAPTER_TITLE_FAMILY             _FAMILY
.ALIAS   COVER_AUTHOR_FAMILY              _FAMILY
.ALIAS   COVER_CHAPTER_TITLE_FAMILY       _FAMILY
.ALIAS   COVER_COPYRIGHT_FAMILY           _FAMILY
.ALIAS   COVER_DOCTYPE_FAMILY             _FAMILY
.ALIAS   COVER_FAMILY                     _FAMILY
.ALIAS   COVER_MISC_FAMILY                _FAMILY
.ALIAS   COVER_SUBTITLE_FAMILY            _FAMILY
.ALIAS   COVER_TITLE_FAMILY               _FAMILY
.ALIAS   DOC_COVER_AUTHOR_FAMILY          _FAMILY
.ALIAS   DOC_COVER_CHAPTER_TITLE_FAMILY   _FAMILY
.ALIAS   DOC_COVER_COPYRIGHT_FAMILY       _FAMILY
.ALIAS   DOC_COVER_DOCTYPE_FAMILY         _FAMILY
.ALIAS   DOC_COVER_FAMILY                 _FAMILY
.ALIAS   DOC_COVER_MISC_FAMILY            _FAMILY
.ALIAS   DOC_COVER_SUBTITLE_FAMILY        _FAMILY
.ALIAS   DOC_COVER_TITLE_FAMILY           _FAMILY
.ALIAS   DOCHEADER_FAMILY                 _FAMILY
.ALIAS   DOCTYPE_FAMILY                   _FAMILY
.ALIAS   ENDNOTE_FAMILY                   _FAMILY
.ALIAS   ENDNOTE_NUMBER_FAMILY            _FAMILY
.ALIAS   ENDNOTE_LINENUMBER_FAMILY        _FAMILY
.ALIAS   ENDNOTE_STRING_FAMILY            _FAMILY
.ALIAS   ENDNOTE_TITLE_FAMILY             _FAMILY
.ALIAS   EPIGRAPH_FAMILY                  _FAMILY
.ALIAS   FOOTNOTE_FAMILY                  _FAMILY
.ALIAS   HDRFTR_CENTER_FAMILY             _FAMILY
.ALIAS   HDRFTR_FAMILY                    _FAMILY
.ALIAS   HDRFTR_LEFT_FAMILY               _FAMILY
.ALIAS   HDRFTR_RIGHT_FAMILY              _FAMILY
.ALIAS   LINENUMBER_FAMILY                _FAMILY
.ALIAS   PAGENUM_FAMILY                   _FAMILY
.ALIAS   QUOTE_FAMILY                     _FAMILY
.ALIAS   SUBTITLE_FAMILY                  _FAMILY
.ALIAS   TITLE_FAMILY                     _FAMILY
.ALIAS   TOC_FAM                          _FAMILY
.ALIAS   TOC_FAMILY                       _FAMILY
.ALIAS   TOC_HEADER_FAMILY                _FAMILY
.ALIAS   TOC_PN_FAMILY                    _FAMILY
\#
.ALIAS   AUTHOR_FONT                    _FONT
.ALIAS   BIBLIOGRAPHY_STRING_FONT       _FONT
.ALIAS   BIBLIOGRAPHY_FONT              _FONT
.ALIAS   BLOCKQUOTE_FONT                _FONT
.ALIAS   CHAPTER_TITLE_FONT             _FONT
.ALIAS   COVER_AUTHOR_FONT              _FONT
.ALIAS   COVER_CHAPTER_TITLE_FONT       _FONT
.ALIAS   COVER_COPYRIGHT_FONT           _FONT
.ALIAS   COVER_DOCTYPE_FONT             _FONT
.ALIAS   COVER_MISC_FONT                _FONT
.ALIAS   COVER_SUBTITLE_FONT            _FONT
.ALIAS   COVER_TITLE_FONT               _FONT
.ALIAS   DOC_COVER_AUTHOR_FONT          _FONT
.ALIAS   DOC_COVER_CHAPTER_TITLE_FONT   _FONT
.ALIAS   DOC_COVER_COPYRIGHT_FONT       _FONT
.ALIAS   DOC_COVER_DOCTYPE_FONT         _FONT
.ALIAS   DOC_COVER_MISC_FONT            _FONT
.ALIAS   DOC_COVER_SUBTITLE_FONT        _FONT
.ALIAS   DOC_COVER_TITLE_FONT           _FONT
.ALIAS   DOCTYPE_FONT                   _FONT
.ALIAS   ENDNOTE_FONT                   _FONT
.ALIAS   ENDNOTE_NUMBER_FONT            _FONT
.ALIAS   ENDNOTE_LINENUMBER_FONT        _FONT
.ALIAS   ENDNOTE_STRING_FONT            _FONT
.ALIAS   ENDNOTE_TITLE_FONT             _FONT
.ALIAS   EPIGRAPH_FONT                  _FONT
.ALIAS   FOOTNOTE_FONT                  _FONT
.ALIAS   HDRFTR_CENTER_FONT             _FONT
.ALIAS   HDRFTR_LEFT_FONT               _FONT
.ALIAS   HDRFTR_RIGHT_FONT              _FONT
.ALIAS   LINENUMBER_FONT                _FONT
.ALIAS   PAGENUM_FONT                   _FONT
.ALIAS   QUOTE_FONT                     _FONT
.ALIAS   SUBTITLE_FONT                  _FONT
.ALIAS   TITLE_FONT                     _FONT
.ALIAS   TOC_HEADER_FONT                _FONT
.ALIAS   TOC_PN_FONT                    _FONT
\#
.ALIAS   AUTHOR_SIZE                    _SIZE
.ALIAS   BIBLIOGRAPHY_STRING_SIZE       _SIZE
.ALIAS   BLOCKQUOTE_SIZE                _SIZE
.ALIAS   CHAPTER_TITLE_SIZE             _SIZE
.ALIAS   COVER_AUTHOR_SIZE              _SIZE
.ALIAS   COVER_CHAPTER_TITLE_SIZE       _SIZE
.ALIAS   COVER_COPYRIGHT_SIZE           _SIZE
.ALIAS   COVER_DOCTYPE_SIZE             _SIZE
.ALIAS   COVER_MISC_SIZE                _SIZE
.ALIAS   COVER_SUBTITLE_SIZE            _SIZE
.ALIAS   COVER_TITLE_SIZE               _SIZE
.ALIAS   DOC_COVER_AUTHOR_SIZE          _SIZE
.ALIAS   DOC_COVER_CHAPTER_TITLE_SIZE   _SIZE
.ALIAS   DOC_COVER_COPYRIGHT_SIZE       _SIZE
.ALIAS   DOC_COVER_DOCTYPE_SIZE         _SIZE
.ALIAS   DOC_COVER_MISC_SIZE            _SIZE
.ALIAS   DOC_COVER_SUBTITLE_SIZE        _SIZE
.ALIAS   DOC_COVER_TITLE_SIZE           _SIZE
.ALIAS   DOCTYPE_SIZE                   _SIZE
.ALIAS   ENDNOTE_NUMBER_SIZE            _SIZE
.ALIAS   ENDNOTE_LINENUMBER_SIZE        _SIZE
.ALIAS   ENDNOTE_STRING_SIZE            _SIZE
.ALIAS   ENDNOTE_TITLE_SIZE             _SIZE
.ALIAS   EPIGRAPH_SIZE                  _SIZE
.ALIAS   FOOTNOTE_SIZE                  _SIZE
.ALIAS   HDRFTR_CENTER_SIZE             _SIZE
.ALIAS   HDRFTR_LEFT_SIZE               _SIZE
.ALIAS   HDRFTR_RIGHT_SIZE              _SIZE
.ALIAS   HDRFTR_SIZE                    _SIZE
.ALIAS   LINENUMBER_SIZE                _SIZE
.ALIAS   PAGENUM_SIZE                   _SIZE
.ALIAS   QUOTE_SIZE                     _SIZE
.ALIAS   SUBTITLE_SIZE                  _SIZE
.ALIAS   TITLE_SIZE                     _SIZE
.ALIAS   TOC_HEADER_SIZE                _SIZE
.ALIAS   TOC_PN_SIZE                    _SIZE
\#
.ALIAS   ATTRIBUTE_COLOR                 _COLOR
.ALIAS   AUTHOR_COLOR                    _COLOR
.ALIAS   BLOCKQUOTE_COLOR                _COLOR
.ALIAS   CHAPTER_TITLE_COLOR             _COLOR
.ALIAS   CODE_COLOR                      _COLOR
.ALIAS   COVER_ATTRIBUTE_COLOR           _COLOR
.ALIAS   COVER_AUTHOR_COLOR              _COLOR
.ALIAS   COVER_CHAPTER_TITLE_COLOR       _COLOR
.ALIAS   COVER_COLOR                     _COLOR
.ALIAS   COVER_COPYRIGHT_COLOR           _COLOR
.ALIAS   COVER_DOCTYPE_COLOR             _COLOR
.ALIAS   COVER_MISC_COLOR                _COLOR
.ALIAS   COVER_SUBTITLE_COLOR            _COLOR
.ALIAS   COVER_TITLE_COLOR               _COLOR
.ALIAS   DOC_COVER_ATTRIBUTE_COLOR       _COLOR
.ALIAS   DOC_COVER_AUTHOR_COLOR          _COLOR
.ALIAS   DOC_COVER_CHAPTER_TITLE_COLOR   _COLOR
.ALIAS   DOC_COVER_COLOR                 _COLOR
.ALIAS   DOC_COVER_COPYRIGHT_COLOR       _COLOR
.ALIAS   DOC_COVER_DOCTYPE_COLOR         _COLOR
.ALIAS   DOC_COVER_MISC_COLOR            _COLOR
.ALIAS   DOC_COVER_SUBTITLE_COLOR        _COLOR
.ALIAS   DOC_COVER_TITLE_COLOR           _COLOR
.ALIAS   DOCHEADER_COLOR                 _COLOR
.ALIAS   DOCTYPE_COLOR                   _COLOR
.ALIAS   ENDNOTE_STRING_COLOR            _COLOR
.ALIAS   EPIGRAPH_COLOR                  _COLOR
.ALIAS   FINIS_COLOR                     _COLOR
.ALIAS   FOOTNOTE_COLOR                  _COLOR
.ALIAS   HDRFTR_CENTER_COLOR             _COLOR
.ALIAS   HDRFTR_COLOR                    _COLOR
.ALIAS   HDRFTR_LEFT_COLOR               _COLOR
.ALIAS   HDRFTR_RIGHT_COLOR              _COLOR
.ALIAS   HDRFTR_RULE_COLOR               _COLOR
.ALIAS   LINEBREAK_COLOR                 _COLOR
.ALIAS   LINENUMBER_COLOR                _COLOR
.ALIAS   PAGENUM_COLOR                   _COLOR
.ALIAS   QUOTE_COLOR                     _COLOR
.ALIAS   SECTION_COLOR                   _COLOR
.ALIAS   SUBTITLE_COLOR                  _COLOR
.ALIAS   TITLE_COLOR                     _COLOR
\#
.ALIAS   BIBLIOGRAPHY_QUAD          _QUAD
.ALIAS   BIBLIOGRAPHY_STRING_QUAD   _QUAD
.ALIAS   BLOCKQUOTE_QUAD            _QUAD
.ALIAS   COVER_COPYRIGHT_QUAD       _QUAD
.ALIAS   COVER_MISC_QUAD            _QUAD
.ALIAS   COVER_QUAD                 _QUAD
.ALIAS   DOC_COVER_COPYRIGHT_QUAD   _QUAD
.ALIAS   DOC_COVER_MISC_QUAD        _QUAD
.ALIAS   DOC_COVER_QUAD             _QUAD
.ALIAS   DOCHEADER_QUAD             _QUAD
.ALIAS   DOC_QUAD                   _QUAD
.ALIAS   ENDNOTE_QUAD               _QUAD
.ALIAS   ENDNOTE_STRING_QUAD        _QUAD
.ALIAS   ENDNOTE_TITLE_QUAD         _QUAD
.ALIAS   EPIGRAPH_QUAD              _QUAD
.ALIAS   FOOTNOTE_QUAD              _QUAD
.ALIAS   TOC_HEADER_QUAD            _QUAD
\#
\# Support aliases
\#
.ALIAS   COL_BREAK               COL_NEXT
.ALIAS   DOC_COVER_ADVANCE       COVER_ADVANCE
.ALIAS   DOC_COVER               COVER
.ALIAS   DOC_COVER_COUNTS_PAGES  COVER_COUNTS_PAGES
.ALIAS   DOC_COVERS              COVERS
.ALIAS   DOC_COVER_LEAD          COVER_LEAD
.ALIAS   DOC_COVERTITLE          COVERTITLE
.ALIAS   DO_DOC_COVER            DO_COVER
.ALIAS   PRINT_FOOTNOTE_RULE     FOOTNOTE_RULE
\#
\# Miscellaneous aliases
.ALIAS   SECTION        LINEBREAK
.ALIAS   SECTION_CHAR   LINEBREAK_CHAR
\#
\# Miscellaneous macros to take care of backward compatibility
\# -----------------------------------------------------------
\#
\# As of 1.1.9, EL and TN got changed to make TRAP...TRAP OFF
\# unnecessary for users.  However, I used both macros extensively
\# throughout this file (in conjunction with TRAP...TRAP OFF).
\# EOL is the old EL; used only in om.tmac.
\#
.MAC EOL END
.    if \\n[.vpt] \{\
.       vpt 0
.       nr #RESTORE_TRAP 1
.    \}
.    br
.    sp -1v
.    if \\n[#RESTORE_TRAP] \{\
.       vpt
.       rr #RESTORE_TRAP
.    \}
.END
\#
\#
\# PREPROCESSOR SUPPORT
\# ====================
\#
\# Utility macros--label and caption styles, lists collector, lists
\# generator.
\#
.nr lists*target 0 1
.
.MAC get-label-type END
.    if \\n[all]=1 .ds label-type eqn
.    if \\n[all]=2 .ds label-type pdf-img
.    if \\n[all]=3 .ds label-type pic
.    if \\n[all]=4 .ds label-type tbl
.END
\#
.MAC set-defaults END
.    if '\\*[\\*[label-type]*\\*[spec-type]-family]'' \
.       ds \\*[label-type]*\\*[spec-type]-family \\*[$DOC_FAM]\"
.    if '\\*[\\*[label-type]*\\*[spec-type]-font]'' \
.       ds \\*[label-type]*\\*[spec-type]-font R\"
.    if '\\*[\\*[label-type]*\\*[spec-type]-size-change]'' \
.       ds \\*[label-type]*\\*[spec-type]-size-change +0\"
.    if !r \\*[label-type]*\\*[spec-type]-autolead \
.       nr \\*[label-type]*\\*[spec-type]-autolead 2
.    if '\\*[\\*[label-type]*\\*[spec-type]-color]'' \
.       ds \\*[label-type]*\\*[spec-type]-color black\"
.    if '\\*[\\*[label-type]*\\*[spec-type]-quad]'' \{\
.       ie '\\*[label-type]'eqn' \{\
.          if '\\*[spec-type]'caption' \
.             ds \\*[label-type]*\\*[spec-type]-quad C\"
.       \}
.       el .ds \\*[label-type]*\\*[spec-type]-quad L\"
.    \}
.    if '\\n[\\*[label-type]*\\*[spec-type]-quad-on-ll]'' \
.       nr \\*[label-type]*\\*[spec-type]-quad-on-ll 1
.    if '\\*[spec-type]'caption' \{\
.       nr default-left 1
.    \}
.END
\#
.MAC set-inline-specs END
.    ds \\*[label-type]*\\*[spec-type]-specs \
\f[\\*[\\*[label-type]*\\*[spec-type]-family]\\*[\\*[label-type]*\\*[spec-type]-font]]\
\s[\\*[\\*[label-type]*\\*[spec-type]-size-change]]\
\m[\\*[\\*[label-type]*\\*[spec-type]-color]]
.END
\#
\# Line lengths, indents, and quads for captions and labels.
\# Aliased for eqn, pic, pdf-image, and tbl.
\#
.MAC SET_QUAD END
.    ds label-type \\$0
.    substring label-type 0 2
.    if '\\*[label-type]'PDF'  .ds label-type pdf-img
.    if '\\*[label-type]'TBL'  .ds label-type tbl
.    if '\\*[label-type]'PIC'  .ds label-type pic
.    if '\\*[label-type]'EQN'  .ds label-type eqn
.    ds spec-type \\$0
.    substring spec-type -6 -10
.    if '\\*[spec-type]'PTION' .ds spec-type caption
.    if '\\*[spec-type]'LABEL' .ds spec-type label
.    if '\\*[spec-type]'OURCE' .ds spec-type source
.    QUAD \\$1
.    ds \\*[label-type]*\\*[spec-type]-quad \\$1
.    substring \\*[label-type]*\\*[spec-type]-quad 0 0
.    if '\\*[label-type]'pdf-img' \{\
.       if '\\*[\\*[label-type]*\\*[spec-type]-quad]'L' \{\
.          if !\\n[pdf-img*\\*[spec-type]-quad-on-ll] \{\
.             ie !'\\*[pdf-img:pos]'-R' \
.                ll \\n[pdf-img:ind]u+\\n[pdf-img:width]u+\\n[pdf-img:frame-inset]u
.             el .ll -\\n[ind-pre-img]u
.             if '\\*[pdf-img:pos]'-C' \
.                in \\n[pdf-img:ind]u-\\n[pdf-img:frame-inset]u
.             if '\\*[pdf-img:pos]'-R' \
.                in \\n[.l]u-(\\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u))
.             if '\\*[pdf-img:pos]'-I' \
.                in \\n[pdf-img:ind]u
.          \}
.       \}
.       if '\\*[\\*[label-type]*\\*[spec-type]-quad]'C' \{\
.          if !\\n[pdf-img*\\*[spec-type]-quad-on-ll] \{\
.             if '\\*[pdf-img:pos]'-L' \
.                ll \\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u)
.             if '\\*[pdf-img:pos]'-C' \{\
.                ll (\\n[ll-pre-img]u-\\n[pdf-img:width]u/2u+(\\n[pdf-img:frame-inset]u))+\\n[pdf-img:width]u
.                in \\n[.l]u-(\\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u))
.             \}
.             if '\\*[pdf-img:pos]'-R' \{\
.                ll -\\n[ind-pre-img]u
.                in \\n[.l]u-(\\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u))
.             \}
.             if '\\*[pdf-img:pos]'-I' \{\
.                ll \\n[pdf-img:ind]u+\\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u)
.                in \\n[pdf-img:ind]u
.             \}
.          \}
.       \}
.       if '\\*[\\*[label-type]*\\*[spec-type]-quad]'R' \{\
.          if !\\n[pdf-img*\\*[spec-type]-quad-on-ll] \{\
.             if '\\*[pdf-img:pos]'-L' \
.                ll \\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u]
.             if '\\*[pdf-img:pos]'-C' \{\
.                ll (\\n[.l]u-\\n[ind-pre-img]u-\\n[pdf-img:width]u/2u)+\\n[pdf-img:width]u+\\n[pdf-img:frame-inset]u
.                in \\n[pdf-img:ind]u
.             \}
.             if '\\*[pdf-img:pos]'-R' \{\
.                ll -\\n[ind-pre-img]u
.                in \\n[.l]u-\\n[pdf-img:width]u
.             \}
.             if '\\*[pdf-img:pos]'-I' \{\
.                ll \\n[pdf-img:ind]u+\\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u)
.                in \\n[pdf-img:ind]u
.             \}   
.          \}
.       \}
.    \}
.    if '\\*[label-type]'pic' \{\
.       if !\\n[pic*\\*[spec-type]-quad-on-ll] \{\
.          ie \\n[pic*left] .ll \\n[pic*div-width]u
.          el \{\
.             ll \\n[pic*div-width]u
\!.           in \\n[ll-pre-pic]u-\\n[pic*div-width]u/2u
.          \}
.       \}
.    \}
.    if '\\*[label-type]'tbl' \{\
.       if !\\n[tbl*\\*[spec-type]-quad-on-ll] \{\
.          ie \\n[tbl*center] \{\
.             ie '\\*[spec-type]'label' \{\
.                ll \\n[ll-pre-tbl]u-\\n[TW]u/2u+\\n[TW]u
\!.                in \\n[ll-pre-tbl]u-\\n[TW]u/2u
.             \}
.             el \{\
.                ll \\n[TW]u
\!.              in \\n[ll-pre-tbl]u-\\n[TW]u/2u
.             \}
.          \}
.          el .ll \\n[TW]u
.       \}
.    \}
.END
\#
.ALIAS TBL*SET_CAPTION_QUAD     SET_QUAD
.ALIAS TBL*SET_LABEL_QUAD       SET_QUAD
.ALIAS TBL*SET_SOURCE_QUAD      SET_QUAD
.ALIAS PDF_IMG*SET_CAPTION_QUAD SET_QUAD
.ALIAS PDF_IMG*SET_LABEL_QUAD   SET_QUAD
.ALIAS PIC*SET_CAPTION_QUAD     SET_QUAD
.ALIAS PIC*SET_LABEL_QUAD       SET_QUAD
\#
.MAC style END
.    ds label-type \\$0
.    substring label-type 0 2
.    if '\\*[label-type]'img' .ds label-type pdf-img
.    if '\\*[label-type]'tbl' .ds label-type tbl
.    if '\\*[label-type]'pic' .ds label-type pic
.    ds spec-type \\$0
.    substring spec-type 4 6
.    if '\\*[spec-type]'cap' .ds spec-type caption
.    if '\\*[spec-type]'lab' .ds spec-type label
.    if '\\*[spec-type]'sou' .ds spec-type source
.    fam \\*[\\*[label-type]*\\*[spec-type]-family]
.    ft \\*[\\*[label-type]*\\*[spec-type]-font]
.    ps \\n[#DOC_PT_SIZE]u\\*[\\*[label-type]*\\*[spec-type]-size-change]
.    gcolor \\*[\\*[label-type]*\\*[spec-type]-color]
.END
\#
.ALIAS tbl*caption-style style
.ALIAS tbl*label-style   style
.ALIAS tbl*source-style  style
.ALIAS img*caption-style style
.ALIAS img*label-style   style
.ALIAS img*source-style  style
.ALIAS pic*caption-style style
.ALIAS pic*label-style   style
.ALIAS pic*source-style  style
\#
\# User style macros
\#
\# TYPE SPECS FOR LABELS, CAPTIONS, AND SOURCES
\# --------------------------------------------
\#  Aliased as CAPTIONS and LABELS for eqn, pic, tbl, and pdf images.
\# *Arguments:
\#   EQN | IMG | PIC | TBL \
\#   Remaining arguments are optional
\#   FAMILY fam \
\#   FONT   sty \
\#   SIZE   +|-size \
\#   QUAD   LEFT | CENTRE | RIGHT [ ON_LL ] \
\#   COLOR  color \
\#   AUTOLEAD n \
\#   ADJUST   +|-n
\# *Function:
\#   Sets type specs for captions, labels, and sources according to
\#   calling alias name
\# *Notes:
\#   SIZE is relative to running text.
\#   QUAD optional arg says quad on full line length rather than
\#    pdf-img or pre-processor output.  
\#
.MAC CAPTION_LABEL_SPECS END
.    if '\\$0'CAPTIONS' .ds spec-type caption
.    if '\\$0'LABELS'   .ds spec-type label
.    if '\\$0'SOURCES'  .ds spec-type source
.    if '\\$1'EQN' .ds label-type eqn
.    if '\\$1'IMG' .ds label-type pdf-img
.    if '\\$1'PIC' .ds label-type pic
.    if '\\$1'TBL' .ds label-type tbl
.    if '\\$1'ALL' .nr all 1
.    shift
.    nr loop-counter \\n[#NUM_ARGS]
.    nr loop-count 0 1
.    while \\n+[loop-count]<=\\n[loop-counter] \{\
.       if '\\$1'FAMILY' \{\
.          shift
.          ie r all \{\
.             nr all 0 1
.             while \\n+[all]<=4 \{\
.                 get-label-type
.                 ds \\*[label-type]*\\*[spec-type]-family \\$1
.             \}
.          \}
.          el .ds \\*[label-type]*\\*[spec-type]-family \\$1
.          if \\n[#PRINT_STYLE]=1 \
.             ds \\*[label-type]*\\*[spec-type]-family \\*[$TYPEWRITER_FAM]
.          shift
.       \}
.       if '\\$1'FONT' \{\
.          shift
.          ie r all \{\
.             nr all 0 1
.             while \\n+[all]<=4 \{\
.                 get-label-type
.                 ds \\*[label-type]*\\*[spec-type]-font \\$1
.             \}
.          \}
.          el .ds \\*[label-type]*\\*[spec-type]-font \\$1
.          if \\n[#PRINT_STYLE]=1 \
.             ds \\*[label-type]*\\*[spec-type]-font R
.          shift
.       \}
.       if '\\$1'SIZE' \{\
.          shift
.          ie r all \{\
.             nr all 0 1
.             while \\n+[all]<=4 \{\
.                 get-label-type
.                 ds \\*[label-type]*\\*[spec-type]-size-change \\$1
.             \}
.          \}
.          el .ds \\*[label-type]*\\*[spec-type]-size-change \\$1
.          if \\n[#PRINT_STYLE]=1 \
.             ds \\*[label-type]*\\*[spec-type]-size-change +0
.          shift
.       \}
.       if '\\$1'AUTOLEAD' \{\
.          shift
.          ie r all \{\
.             nr all 0 1
.             while \\n+[all]<=4 \{\
.                 get-label-type
.                 nr \\*[label-type]*\\*[spec-type]-autolead (p;\\$1)
.             \}
.          \}
.          el .nr \\*[label-type]*\\*[spec-type]-autolead (p;\\$1)
.          shift
.       \}
.       if '\\$1'QUAD' \{\
.          shift
.          ie r all \{\
.             nr all 0 1
.             while \\n+[all]<=4 \{\
.                 get-label-type
.                 ds \\*[label-type]*\\*[spec-type]-quad \\$1
.                 substring \\*[label-type]*\\*[spec-type]-quad 0 0
.             \}
.          \}
.          el \{\
.             ds \\*[label-type]*\\*[spec-type]-quad \\$1
.             substring \\*[label-type]*\\*[spec-type]-quad 0 0
.             if \\n[\\*[label-type]*\\*[spec-type]-quad-on-ll] \
.                rr \\*[label-type]*\\*[spec-type]-quad-on-ll 
.          \}
.          shift
.          if '\\$1'ON_LL' \{\
.             nr \\*[label-type]*\\*[spec-type]-quad-on-ll 1
.             shift
.          \}
.       \}
.       if '\\$1'COLOR' \{\
.          shift
.          ie r all \{\
.             nr all 0 1
.             while \\n+[all]<=4 \{\
.                 get-label-type
.                 ds \\*[label-type]*\\*[spec-type]-color \\$1
.             \}
.          \}
.          el .ds \\*[label-type]*\\*[spec-type]-color \\$1
.          if \\n[#PRINT_STYLE]=1 \
.             ds \\*[label-type]*\\*[spec-type]-color black
.          shift
.       \}
.       if '\\$1'ADJUST' \{\
.          shift
.          ie r all \{\
.             nr all 0 1
.             while \\n+[all]<=4 \{\
.                 get-label-type
.                 ds \\*[label-type]*\\*[spec-type]-space \\$1
.             \}
.          \}
.          el .ds \\*[label-type]*\\*[spec-type]-space \\$1
.          if \\n[#PRINT_STYLE]=1 \
.             ds \\*[label-type]*\\*[spec-type]-space +0
.          shift
.       \}
.    \}
.    ie r all \{\
.       nr all 0 1
.       while \\n+[all]<=4 \{\
.          get-label-type
.          set-defaults
.          set-inline-specs
.       \}
.    \}
.    el \{\
.       set-defaults
.       set-inline-specs
.    \}
.    ds revert-specs \f[]\s[0]\m[]
.    rr all
.END
\#
.ALIAS CAPTIONS CAPTION_LABEL_SPECS
.ALIAS LABELS   CAPTION_LABEL_SPECS
.ALIAS SOURCES  CAPTION_LABEL_SPECS
\#
\# CAPTION_AFTER_LABEL
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Sets register indicating non-MLA captions should come after labels.
\#
.MAC CAPTION_AFTER_LABEL END
.    if '\\$1'IMG' .ds type pdf-img
.    if '\\$1'PIC' .ds type pic
.    if '\\$1'TBL' .ds type tbl
.    if !\\n[#MLA] \{\
.       nr \\*[type]*caption-after-label 1
.       if '\\$1'ALL' \{\
.          if '\\$1'IMG' .nr pdf-img*caption-after-label 1
.          if '\\$1'TBL' .nr tbl*caption-after-label 1
.          if '\\$1'PIC' .nr pic*caption-after-label 1
.       \}
.       if !'\\$2'' \{\
.          ie !'\\$1'ALL' .rr \\*[type]*caption-after-label
.          el \{\
.             rr pdf-img*caption-after-label
.             rr tbl*caption-after-label
.             rr pic*caption-after-label
.          \}
.       \}
.    \}
.END
\#
\# AUTOLABELLING
\# -------------
\# *Argument:
\#   [ PREFIX <prefix> SUFFIX <suffix> ] | <anything>
\# *Function:
\#   Turns label autonumbering on of off; optionally lets user set
\#   prefix and suffix for labels.
\# *Notes:
\#   Aliased for images (pdf), tbl, pic, and eqn.
\#
.MAC AUTOLABEL END
.    if '\\$0'AUTOLABEL_EQUATIONS' .ds label-type eqn
.    if '\\$0'AUTOLABEL_IMAGES'    .ds label-type pdf-img
.    if '\\$0'AUTOLABEL_PIC'       .ds label-type pic
.    if '\\$0'AUTOLABEL_TABLES'    .ds label-type tbl
.    if !'\\$1'' \{\
.       ds \\*[label-type]-label-args \\$1
.       substring \\*[label-type]-label-args -1 -3
.    \}
.    if '\\*[\\*[label-type]-label-args]'FIX' .nr \\*[label-type]-label-args 1
.    if '\\*[\\*[label-type]-label-args]'TER' .nr \\*[label-type]-label-args 1
.    if !\\n[\\*[label-type]*label-num] \
.       nr \\*[label-type]*label-num 0 1
.    if '\\*[label-type]'pdf-img' .nr fig*label-num 0 1
.    if '\\*[label-type]'pic'     .nr fig*label-num 0 1
.    nr \\*[label-type]*autolabel 1
.    nr loop-counter 0 1
.    nr loop-count \\n[#NUM_ARGS]
.    while \\n+[loop-counter]<=\\n[loop-count] \{\
.       if '\\$1'PREFIX' \{\
.          ds \\*[label-type]*label-prfx \\$2
.          nr \\*[label-type]*label-prfx-set 1
.          shift 2
.       \}
.       if '\\$1'SUFFIX' \{\
.          ds \\*[label-type]*label-sffx \\$2
.          nr \\*[label-type]*label-sffx-set 1
.          shift 2
.       \}
.       if '\\$1'PREFIX_CHAPTER' \{\
.          nr \\*[label-type]*label-with-chapter 1
.          ie !'\\$2'' \{\
.             ie \B'\\$2' .nr #CH_NUM \\$2
.             el .autolabel@error
.          \}
.          el \{\
.             ie \\n[#CHAPTER_CALLED] \
.                ie \B'\\*[$CHAPTER]' .nr #CH_NUM \\*[$CHAPTER]
.                el .autolabel@error \\$0
.             el .autolabel@error \\$0
.          \}
.          shift 2
.       \}
.    \}
.    if '\\*[\\*[label-type]*label-prfx]'' \{\
.       if '\\*[label-type]'eqn' \
.          if !\\n[\\*[label-type]*label-prfx-set] \
.             ds \\*[label-type]*label-prfx (\"
.       if '\\*[label-type]'pic' \
.          if !\\n[\\*[label-type]*label-prfx-set] \
.             ds \\*[label-type]*label-prfx Fig. \"
.       if '\\*[label-type]'pdf-img' \
.          if !\\n[\\*[label-type]*label-prfx-set] \
.             ds \\*[label-type]*label-prfx Fig. \"
.       if '\\*[label-type]'tbl' \
.          if !\\n[\\*[label-type]*label-prfx-set] \
.             ds \\*[label-type]*label-prfx Table \"
.    \}
.    if '\\*[\\*[label-type]*label-sffx]'' \{\
.       if '\\*[label-type]'eqn' \
.          if !\\n[\\*[label-type]*label-sffx-set] \
.             ds \\*[label-type]*label-sffx )\"
.       if '\\*[label-type]'pic' \
.          if !\\n[\\*[label-type]*label-sffx-set] \
.             ds \\*[label-type]*label-sffx .\"
.       if '\\*[label-type]'pdf-img' \
.          if !\\n[\\*[label-type]*label-sffx-set] \
.             ds \\*[label-type]*label-sffx .\"
.       if '\\*[label-type]'tbl' \
.          if !\\n[\\*[label-type]*label-sffx-set] \
.             ds \\*[label-type]*label-sffx .\"
.    \}
.    ie \\n[args]>0 \{\
.       if \\n[\\*[label-type]*label-prfx-set]+\\n[\\*[label-type]*label-sffx-set]=1 \{\
.          ie (\\n[\\*[label-type]*label-prfx-set]=1)&(\\n[\\*[label-type]*label-sffx-set]=0) \
.             ds missing-arg SUFFIX
.          el .ds missing-arg PREFIX
.          tm1 "[mom]: You must supply a \\*[missing-arg] argument to \\$0.
.          tm1 "       If you wish the \\*[missing-arg] to be blank, use \\*[missing-arg] "".
.          ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.       \}
.       if !\\n[\\*[label-type]-label-args] \{\
.          rr \\*[label-type]*autolabel
.          rr \\*[label-type]*label-prfx-set
.          rr \\*[label-type]*label-suffx-set
.          rr \\*[label-type]-label-args
.       \}
.    \}
.    rr \\*[label-type]-label-args
.END
\#
.ALIAS AUTOLABEL_EQUATIONS AUTOLABEL
.ALIAS AUTOLABEL_IMAGES    AUTOLABEL
.ALIAS AUTOLABEL_PIC       AUTOLABEL
.ALIAS AUTOLABEL_TABLES    AUTOLABEL
\#
.MAC autolabel@error END
.    tm1 "[mom]: \\$1 cannot determine a chapter number.
.    tm1 "       Enter the current chapter number as a digit after the
.    tm1 "       PREFIX_CHAPTER argument at line \\n[.c].
.    ab Aborting '\\n[.F]', line \\n[.c]. 
.END
\#
\# MLA STYLE
\# ---------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Sets or removes register #MLA.
\# *Notes:
\#   MLA formatting differs from other styles wrt caption and
\#   label placement.
\#
.MAC MLA END
.    ie '\\$1'' \{\
.       nr #MLA 1
.       nr pdf-img*caption-after-label 1
.       nr pic*caption-after-label 1
.       rr tbl*caption-after-label
.    \}
.    el \{\
.       rr #MLA
.    \}
.END
\#
.MAC mla@error END
.    tm1 "[mom]: MLA style enabled, but \\$1 has no corresponding \\$2.
.    ab Aborting '\\$3' at \\$4, line \\$5.
.END
\#
\# LISTS_OF
\# --------
\# *Aliases:
\#   LIST_OF_EQUATIONS
\#   LIST_OF_FIGURES
\#   LIST_OF_TABLES
\# *Arguments:
\#   TITLE_STRING <string> START_PAGENUM <pagenumber>
\# *Function:
\#   Generates lists-of based on calling alias.
\# *Notes:
\#   Called at end of file.
\#   If after TOC, and TOC is being auto-relocated, lists are also
\#   relocated.  If called before, lists are output at end of file.
\#
.MAC LISTS_OF END
.    ds $LIST_TYPE \\$0
.    substring $LIST_TYPE -1 -4
.    if '\\*[$LIST_TYPE]'URES' \{\
.       ds $LIST_TYPE FIGURES
.       ds \\*[$LIST_TYPE]_TITLE_STRING "List of Figures
.    \}
.    if '\\*[$LIST_TYPE]'BLES' \{\
.       ds $LIST_TYPE TABLES
.       ds \\*[$LIST_TYPE]_TITLE_STRING "List of Tables
.    \}
.    if '\\*[$LIST_TYPE]'IONS' \{\
.       ds $LIST_TYPE EQUATIONS
.       ds \\*[$LIST_TYPE]_TITLE_STRING "List of Equations
.    \}
.    nr #LIST_OF_\\*[$LIST_TYPE] 1
.    nr loop-count 0 1
.    nr loop-counter \\n[#NUM_ARGS]
.    while \\n+[loop-count]<=\\n[loop-counter] \{\
.       if '\\$1'TITLE_STRING' \{\
.          ds \\*[$LIST_TYPE]_TITLE_STRING \\$2
.          shift 2
.       \}
.       if '\\$1'START_PAGENUM' \{\
.          nr #\\*[$LIST_TYPE]_START_PAGENUM \\$2
.          shift 2
.       \}
.    \}
.    char \[leader] " .
.    LEADER_CHARACTER \[leader]
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#FINIS] \{\
.       if \\n[#FOOTERS_WERE_ON] \
.          FOOTERS
.    \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       if !'\\*[$HDRFTR_CENTER_OLD]'' .ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_OLD]
.       ie \\n[#LISTS_NO_PAGENUM]=1 .PAGINATION off
.       el .PAGINATE
.    \}
.    if \\n[#FOOTERS_WERE_ON] .FOOTERS OFF
.    rr #COLUMNS
.    COLLATE
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#SINGLE_SPACE] .LS 24
.       DOC_LEAD_ADJUST
.    \}
.    if \\n[#FINIS] \{\
.       if \\n[#FOOTERS_WERE_ON] .FOOTERS
.       rr #FOOTERS_WERE_ON
.       if \\n[#PAGINATION_WAS_ON] \{\
.          nr #PAGINATE 1
.          rr #PAGINATION_WAS_ON
.       \}
.       rr #FINIS
.    \}
.    ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_NEW]
.    rm $HDRFTR_CENTER_OLD
.    rm $HDRFTR_CENTER_NEW
.    rr #COLLATED_DOC
.    DOCTYPE DEFAULT
.    DOCHEADER
.    TITLE "\\*[\\*[$LIST_TYPE]_TITLE_STRING]
.    AUTHOR ""
.    L_MARGIN \\n[#DOC_L_MARGIN]u
.    LL       \\n[#DOC_L_LENGTH]u
.    if '\\*[$LISTS_FAM]'' \
.       ds $LISTS_FAM \\*[$TOC_FAM]
.    if '\\*[$LISTS_FT]'' \
.       ds $LISTS_FT \\*[$TOC_TITLE_FT]
.    if !\\n[#LISTS_PS] \
.       nr #LISTS_PS \\n[#TOC_PS]
.    ps \\n[#LISTS_PS]u
.    if !\\n[#LISTS_LEAD] \
.       nr #LISTS_LEAD \\n[#TOC_LEAD]
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#LISTS_LEAD_ADJUST]=1 \{\
.          vs \\n[#LISTS_LEAD]u
.          DOC_LEAD_ADJUST
.       \}
.       el \{\
.          vs \\n[#LISTS_LEAD]u
.          DOC_LEAD_ADJUST OFF
.       \}
.    \}
.    ie !'\\*[$LISTS_TITLE_QUAD]'' \
.       DOCHEADER_QUAD \\*[$LISTS_TITLE_QUAD]
.    el .DOCHEADER_QUAD \\*[$TOC_HEADER_QUAD]
.    if '\\*[$LISTS_TITLE_QUAD]'' \
.       ds $LISTS_TITLE_QUAD \\*[$TOC_HEADER_QUAD]
.    if !'\\*[$LISTS_TITLE_FAM]'' \
.       TITLE_FAMILY \\*[$LISTS_TITLE_FAM]
.    if !'\\*[$LISTS_TITLE_FT]'' \
.       TITLE_FONT  \\*[$LISTS_TITLE_FT]
.    if !'\\*[$LISTS_TITLE_SIZE]'' \
.       TITLE_SIZE \\*[$LISTS_TITLE_SIZE]
.    if !'\\*[$LISTS_TITLE_COLOR]'' \
.       TITLE_COLOR \\*[$LISTS_TITLE_COLOR]
.    if '\\*[$LISTS_PN_FAM]'' \
.       ds $LISTS_PN_FAM \\*[$TOC_PN_FAM]
.    if '\\*[$LISTS_PN_FT]'' \
.       ds $LISTS_PN_FT \\*[$TOC_PN_FT]
.    if '\\*[$LISTS_PN_SIZE_CHANGE]'' \
.       ds $LISTS_PN_SIZE_CHANGE \\*[$TOC_PN_SIZE_CHANGE]
.    if !\\n[#EQN_PN_PADDING] \
.       nr #EQN_PN_PADDING \\n[#TOC_PN_PADDING]
.    if !\\n[#FIG_PN_PADDING] \
.       nr #FIG_PN_PADDING \\n[#TOC_PN_PADDING]
.    if !\\n[#TBL_PN_PADDING] \
.       nr #TBL_PN_PADDING \\n[#TOC_PN_PADDING]
.    ie '\\*[$LISTS_PAGENUM_STYLE]'' \
.       PAGENUM_STYLE \\*[$TOC_PAGENUM_STYLE]
.    el \
.       PAGENUM_STYLE \\*[$LISTS_PAGENUM_STYLE]
.    if r #\\*[$LIST_TYPE]_START_PAGENUM  \
.       PAGENUMBER \\n[#\\*[$LIST_TYPE]_START_PAGENUM]
.    if r #LISTS_NO_PAGENUM .PAGINATION off
.    HEADER_LEFT "\\*[$HDRFTR_LEFT]
.    HEADER_RIGHT "\\*[$HDRFTR_RIGHT]
.    HEADER_CENTER "\\*[\\*[$LIST_TYPE]_TITLE_STRING]
.    if \\n[#LINENUMBERS]=2 .nr #LINENUMBERS 3
.\" Get num placeholders for ch. num and label num.
.    if \\n[\\*[list-type]*autolabel] \{\
.       if \\n[#CH_NUM]<1000 .nr chapno-width 3
.       if \\n[#CH_NUM]<100  .nr chapno-width 2
.       if \\n[#CH_NUM]<10   .nr chapno-width 1
.       if \\n[\\*[list-type]*label-width]<1000 .nr label-width 3
.       if \\n[\\*[list-type]*label-width]<100  .nr label-width 2
.       if \\n[\\*[list-type]*label-width]<10   .nr label-width 1
.\" Calculate width of label-num tab
.       nr label-width \w'\0'*(\\n[chapno-width]+\\n[label-width])+\w'.'
.    \}
.    if \\n[#SLANT_ON] .nop \\*[SLANTX]
.    if \\n[#COLUMNS]=1 .nr #COLUMNS 0
.    START
.    if \\n[#PRINT_STYLE]=2 .sp -1
.    if '\\*[$LIST_TYPE]'FIGURES'   .LIST_OF_FIG
.    if '\\*[$LIST_TYPE]'TABLES'    .LIST_OF_TBL
.    if '\\*[$LIST_TYPE]'EQUATIONS' .LIST_OF_EQN
.    if \\n[#LINENUMBERS]=3 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.       nn 1
.    \}
.    pdfsync
.END
.\"
.ALIAS LIST_OF_EQUATIONS LISTS_OF
.ALIAS LIST_OF_FIGURES   LISTS_OF
.ALIAS LIST_OF_TABLES    LISTS_OF
\#
\# LISTS-OF STYLE
\# --------------
\# *Arguments:
\#   FAMILY        fam  /
\#   FONT          sty /
\#   PT_SIZE       size /
\#   LEAD          leading [ADJUST] /
\#   TITLE_FAMILY  fam /
\#   TITLE_FONT    sty /
\#   TITLE_SIZE    +|-size /
\#   TITLE_QUAD    LEFT | CENTER | RIGHT /
\#   TITLE_COLOR   color /
\#   NO_PAGINATION /
\#   PAGENUM_STYLE format /
\#   PN_FAMILY     fam /
\#   PN_FONT       sty /
\#   PN_SIZE       +|-size /
\#   PN_PADDING    n
\# *Function:
\#   Allows setting of all style parameters for lists-of.
\# *Notes:
\#   Assumption is that lists-of will all have the same style.
\#   TOC style is used if LISTS_STYLE is omitted.
\#
.MAC LISTS_STYLE END
.    nr loop-count 0 1
.    nr loop-counter \\n[#NUM_ARGS]
.    while \\n+[loop-count]<=\\n[loop-counter] \{\
.       if '\\$1'FAMILY' \{\
.          ds $LISTS_FAM \\$2
.          shift 2
.       \}
.       if '\\$1'FONT' \{\
.          ds $LISTS_FT \\$2
.          shift 2
.       \}
.       if '\\$1'TITLE_FAMILY' \{\
.          ds $LISTS_TITLE_FAM \\$2
.          shift 2
.       \}
.       if '\\$1'TITLE_FONT' \{\
.          ds $LISTS_TITLE_FT \\$2
.          shift 2
.       \}
.       if '\\$1'TITLE_SIZE' \{\
.          ds $LISTS_TITLE_SIZE \\$2
.          shift 2
.       \}
.       if '\\$1'TITLE_QUAD' \{\
.          ds $LISTS_TITLE_QUAD \\$2
.          shift 2
.       \}
.       if '\\$1'TITLE_COLOR' \{\
.          ds $LISTS_TITLE_COLOR \\$2
.          shift 2
.       \}
.       if '\\$1'PT_SIZE' \{\
.          nr #LISTS_PS (p;\\$2)
.          shift 2
.       \}
.       if '\\$1'LEAD' \{\
.          nr #LISTS_LEAD (p;\\$2)
.          ie !'\\$3'ADJUST' \{\
.             nr #LISTS_LEAD_ADJUST 0
.             shift 2
.          \}
.          el \{\
.             nr #LISTS_LEAD_ADJUST 1
.             shift 3
.          \}
.       \}
.       if '\\$1'NO_PAGINATION' \{\
.          nr #LISTS_NO_PAGENUM 1
.          shift 1
.       \}
.       if '\\$1'PAGENUM_STYLE' \{\
.          ds $LISTS_PAGENUM_STYLE \\$2
.          shift 2
.       \}
.       if '\\$1'PN_FAMILY' \{\
.          ds $LISTS_PN_FAM \\$2
.          shift 2
.       \}
.       if '\\$1'PN_FONT' \{\
.          ds $LISTS_PN_FT \\$2
.          shift 2
.       \}
.       if '\\$1'PN_SIZE' \{\
.          ds $LISTS_PN_SIZE_CHANGE \\$2
.          shift 2
.       \}
.       if '\\$1'EQN_PN_PADDING' \{\
.          nr #EQN_PN_PADDING \\$2
.          shift 2
.       \}
.       if '\\$1'FIG_PN_PADDING' \{\
.          nr #FIG_PN_PADDING \\$2
.          shift 2
.       \}
.       if '\\$1'TBL_PN_PADDING' \{\
.          nr #TBL_PN_PADDING \\$2
.          shift 2
.       \}
.    \}
.END
\#
\# Lists-of collector
\# Strings to allocate space for leaders and entry page numbers
\#
.ds $LISTS_PN \\*[ST102]\F[\\*[$LISTS_PN_FAM]]\f[\\*[$LISTS_PN_FT]]\
\s[\\n[#LISTS_PS]u]^\\*[ST102X]\\*[ST103]\s[\\\\*[$LISTS_PN_SIZE_CHANGE]]\
\|\|\|\h'\w'0'u*\\\\n[#LISTS_PN_PADDING]u'\\*[ST103X]
\#
.ds $LISTS_PN_TYPEWRITE \\*[ST102]^\\*[ST102X]\\*[ST103]\|\
\h'\w'0'u*\\\\n[#LISTS_PN_PADDING]u'\\*[ST103X]
\#
.MAC LISTS_COLLECTOR END
.    if '\\$0'TO_EQUATIONS' \{\
.       ds list-type eqn
.       da LIST_OF_EQN
\!.       nr #LISTS_PN_PADDING \\\\n[#EQN_PN_PADDING]
.       nr label-width \w'\\$1'
.    \}
.    if '\\$0'TO_FIGURES' \{\
.       ds list-type fig
.       da LIST_OF_FIG
\!.       nr #LISTS_PN_PADDING \\\\n[#FIG_PN_PADDING]
.       nr label-width \w'\\$1'
.    \}
.    if '\\$0'TO_TABLES' \{\
.       ds list-type tbl
.       da LIST_OF_TBL
\!.       nr #LISTS_PN_PADDING \\\\n[#TBL_PN_PADDING]
.       nr label-width \w'\\$1'
.    \}
.    br
.    nr #LISTS_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.    ie \\n[#PRINT_STYLE]=1 \{\
\!.     fam \\*[$TYPEWRITER_FAM]
\!.     ft  R
\!.     ps \\*[$TYPEWRITER_PS]
.       ds _TYPEWRITE _TYPEWRITE
.    \}
.    el \{\
\!.     FAMILY \\\\*[$LISTS_FAM]
\!.     FONT \\\\*[$LISTS_FT]
\!.     ps \\\\n[#LISTS_PS]u
.    \}
.    if \\n[#PRINT_STYLE]=2 .rm _TYPEWRITE
\!.  PAD_MARKER ^
\!.  vpt 0
\!.  PAD \
"\\*[ST100]\h'\\n[label-width]u'\\*[ST100X]\0\\*[ST101]\h'\w'\\$2'u'\\*[ST101X]\\\\*[$LISTS_PN\\*[_TYPEWRITE]]" \
"\\*[PDFBOOKMARK.NAME]"
\!.  PAD_MARKER #
\!.  EOL
.    ie !\\n[\\*[label-type]*autolabel] \
\!.     ST 100 L
.    el \
\!.     ST 100 R
\!.  ST 101 L
\!.  ST 102 L
\!.  ST 103 R
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\\\*[$LISTS_FAM]
\!.     FT      \\\\*[$LISTS_FT]
\!.     ps \\\\n[#LISTS_PS]u
.    \}
\!.  TAB 100
\!.  PDF_LINK \\*[list-type]:\\n[lists*target] "\\$1"
\!.  TN
\!.  PDF_LINK \\*[list-type]:\\n[lists*target] "\\$2"
\!.  TN
\!.  PRINT \\*[LEADER]
\!.  TN
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\\\*[$LISTS_PN_FAM]
\!.     FT      \\\\*[$LISTS_PN_FT]
\!.     ps \\\\*[$LISTS_PN_SIZE_CHANGE]u
.    \}
\!.  PRINT \\n[#LISTS_ENTRY_PN]
\!.  TQ
\!.  vpt
.    da
.END
\#
.ALIAS TO_EQUATIONS LISTS_COLLECTOR
.ALIAS TO_FIGURES   LISTS_COLLECTOR
.ALIAS TO_TABLES    LISTS_COLLECTOR
\#
\# ***tbl***
\#
\# Support for multipage tables with headers borrowed from ms and
\# mommified by Robin Haberkorn <robin.haberkorn@googlemail.com>
\# with extensions by Peter Schaffter.
\#
.nr tbl*have-header 0
.ds T&
\#
.MAC TS END
.    di NULL \" Set rule weight for boxed tables
\D't 500'
.    di
.    br
.    if !\\n[@TOP] \
.       if \\n[.t]=1 .sp \\n[.t]u
.    rr tbl*have-header
.    rr float*tbl
.    if '\\n[.z]'FLOAT*DIV' .nr float*tbl 1
.    if !'\\n[.z]'FLOAT*DIV' \{\
.       if \\n[.t]=1 \{\
.          if !\\n[@TOP] \{\
.             if \\n[#COL_NUM]=\\n[#NUM_COLS] \
.                NEWPAGE
.          \}
.       \}
.    \}
.    rr tbl*boxed
.    rm tbl*label
.    rm tbl*caption
.    nr loop-count 0 1
.    nr loop-counter \\n[#NUM_ARGS]
.    while \\n+[loop-count]<=\\n[loop-counter] \{\
.       if '\\$1'H' \{\
.          nr tbl*have-header 1
.          shift
.          if \\n[#NUM_ARGS]=0 .nr tbl*plain 1
.       \}
.       if '\\$1'BOXED' \{\
.          nr tbl*boxed 1
.          shift
.       \}
.       if '\\$1'CENTER' \{\
.          nr tbl*center 1
.          shift
.       \}
.       if '\\$1'NEEDS' \{\
.          nr tbl*needs \\$2
.          shift 2
.       \}
.       if '\\$1'NO_SHIM' \{\
.          nr tbl*no-shim 1
.          shift
.       \}
.       if '\\$1'ADJUST' \{\
.          ds tbl*space-adj \\$2
.          shift 2
.       \}
.       if '\\$1'CAPTION' \{\
.          nr tbl*have-caption 1
.          ds tbl*caption \\$2
.          shift 2
.       \}
.       if '\\$1'SHORT_CAPTION' \{\
.          ds tbl*caption-short \\$2
.          shift 2
.       \}
.       if '\\$1'LABEL' \{\
.          nr tbl*have-label 1
.          ds tbl*label \\$2
.          ds label-type tbl
.          shift 2
.       \}
.    \}
.    if \\n[tbl*boxed]=1 \{\
.       if (\\n[tbl*have-label]=0)&(\\n[tbl*have-caption]=0)&\
(\\n[tbl*autolabel]=0)&(\\n[tbl*have-source]=0) \
.       nr tbl*plain-boxed 1
.    \}
.    if !\\n[tbl*needs] .nr tbl*needs 1
.    if !\\n[tbl*have-header] .nr tbl*no-header 1
.    ds tbl*label-sffx-tmp \\*[tbl*label-sffx]
.    substring tbl*label-sffx-tmp -1
.    if '\\*[tbl*label-sffx-tmp]'.' \
.       if (\\n[tbl*caption-after-label]=0):(\\n[#MLA]=1) .chop tbl*label-sffx
.    if \\n[tbl*caption-after-label] \{\
.       if !'\\*[tbl*label-sffx]'' \
.          if '\\*[tbl*caption]'' .chop tbl*label-sffx
.    \}
.    ie \\n[@TOP] \{\
.       if !'\\n[.z]'FLOAT*DIV' \{\
.          vpt 0
.          rr @TOP
.          ch RR_@TOP
.          rs
.          nop \&
.          if \\n[#COLUMNS] \
.             if !'\\*[tbl*space-adj]'' \
.                sp \\*[tbl*space-adj]-1v
.          nr tbl*boxed 2
.          vpt
.       \}
.    \}
.    el \
.       if !'\\*[tbl*space-adj]'' .sp \\*[tbl*space-adj]u
.    if !\\n[#MLA] \{\
.      if (\\n[tbl*have-caption]=0):(\\n[tbl*caption-after-label]=1) \{\
.         ie !'\\n[.z]'FLOAT*DIV' \{\
.            sp .5v
.            if \\n[tbl*boxed] .sp .25v
.         \}
.         el .sp 1n
.      \}
.    \}
.    if '\\n[.z]'FLOAT*DIV' \{\
.       if \\n[defer]>0 .sp .5v
.    \}
.    ds ev-current   \\n[.ev]
.    nr ll-pre-tbl   \\n[.l]
.    nr lead-pre-tbl \\n[.v]
.    nr ind-pre-tbl  \\n[.i]
.    ll \\n[.l]u-\\n[.i]u
.    if (\\n[nl]=\\n[#PAGE_TOP]):(\\n[nl]=\\n[dc]) \
.       nr tbl*caption-lead-diff-adj 1
.    if \\n[#MLA] \
.       if \\n[tbl*have-label]+\\n[tbl*have-caption]=0 \
.          sp .5v
.    if \\n[tbl*boxed]=2 \{\
.       if \\n[#MLA]=0 \
.          if (\\n[tbl*caption-after-label]=1):(\\n[tbl*have-caption]=0) \
.             sp 1n
.    \}
.    if \\n[tbl*have-header] \{\
.       ev table-header
.       evc \\*[ev-current]
.       di tbl*header-div
.       if !\\n[float-span] \!.in 0
.    \}
.END
\#
.MAC TH END
.    ie '\\n[.z]'tbl*header-div' \{\
.       nr T. 0
.       T#
.       di
.       ev
.       PDF_TARGET tbl:\\n+[lists*target]
.       if !'\\n[.z]'FLOAT*DIV' \{\
.          ie !\\n[tbl*boxed] \{\
.             nr th*needs (u;\\n[dn]+\\n[tbl*needs]v)
.             if \\n[th*needs]>\\n[.t] \{\
.                ne \\n[dn]u+\\n[tbl*needs]
.                nr tbl@needs 1
.             \}
.          \}
.          el \{\
.             nr th*needs (u;\\n[dn]+2p+\\n[tbl*needs]v)
.             if \\n[th*needs]>\\n[.t] \{\
.                ne \\n[dn]u+2p+\\n[tbl*needs]
.                if \\n[#COLUMNS] \
.                   if !\\n[#COL_NUM]=\\n[#NUM_COLS] .nr tbl*no-top-hook 1
.                nr tbl@needs 1
.             \}
.          \}
.          if \\n[defer] .nr tbl*interrupted 1
.       \}
.       ie (\\n[dn]-\\n[.v])>\\n[.t] \{\
.          if !\\n[@TOP] .@error ridiculously long table header
.          if \\n[tbl@needs] \{\
.             if \\n[tbl*boxed] \{\
.                rs
.                nop \&
.                sp -1n
.             \}
.             rr tbl@needs
.          \}
.          if \\n[tbl*have-caption] .TBL*CAPTION
.          tbl*print-header
.       \}
.       el \{\
.          nr tbl*header-ht \\n[dn]
.          if \\n[tbl@needs] \{\
.             if \\n[tbl*boxed] \{\
.                rs
.                nop \&
.                sp -1n
.             \}
.             rr tbl@needs
.          \}
.          if \\n[tbl*have-caption] .TBL*CAPTION
.          vs
.          tbl*print-header
.       \}
.    \}
.    el \{\
.       if \\n[tbl*have-caption] \{\
.          TBL*CAPTION
.          nr skip-th-warning 1
.       \}
.       if !\\n[skip-th-warning] .@error .TH without .TS H
.       rr skip-th-warning
.    \}
.\" When centering a boxed table inside a float, .T# won't place
.\" vertical rules in the correct horizontal position unless .ll is
.\" given a nominal value (can be anything) and an indent is set
.\" manually.
.    if '\\n[.z]'FLOAT*DIV' \{\
.       if \\n[tbl*center] \{\
.          nr float*ll \\n[.l]
.          ll 0
.          in \\n[float*ll]u-\\n[TW]u/2u
.       \}
.    \}
.END
\#
.MAC TE END
.    ev tbl*end \" Needed because of .ad changes
.    evc \\*[ev-current] 
.    nh
.    nf
.    rr tbl*no-header
.    if !'\\n[.z]'FLOAT*DIV' \{\
.       ie \\n[.t]<(\\n[.v]+(\\n[.v]/2u)) \{\
.          rm tbl*header-div
.          nr tbl*no-top-hook 1
.          nr pgnum \\n%+\\n[#PAGE_NUM_ADJ]
.          tm1 "[mom]: '\\n[.F]', macro \\$0, line \\n[.c]:
.          tm1 "        Insufficient room for label, caption, and/or source after
.          tm1 "        table on page \\n[pgnum].  Omitting, but continuing to process.
.          NEWPAGE
.          nr tbl*skip-source 1
.          nr tbl*skip-label 1
.          ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u
.       \}
.       el \{\
.          ch FOOTER 0+\\n[pre-tbl-vfp]u
.          ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u
.       \}
.    \}
.    if !'\\$1'' \{\
.       if '\\$1'SOURCE' \{\
.          nr tbl*have-source 1
.          shift
.       \}
.    \}
.    if !\\n[#MLA] \{\
.       if (\\n[tbl*have-label]=1):(\\n[tbl*autolabel]=1):(\\n[tbl*caption-after-label]=1) \{\
.          ev label
.          evc tbl*end
.          ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.          el \{\
.             tbl*label-style
.             vs \\n[.ps]u+\\n[tbl*label-autolead]u
.          \}
.          SIZESPECS
.          if \\n[tbl*label-with-chapter] \
.             ds chapno \\n[#CH_NUM].
.          TBL*SET_LABEL_QUAD \\*[tbl*label-quad]
.          di tbl*label-div
\!.        in -\\n[ind-pre-tbl]u
.          ie \\n[tbl*boxed] .sp \\n[#CAP_HEIGHT]u
.          el .sp \\n[#DOC_LEAD]u/4u
.          if (\\n[tbl*have-label]=1):(\\n[tbl*autolabel]=1) \{\
.             if !'\\*[tbl*label-space]'' .sp \\*[tbl*label-space]
.             ie \\n[tbl*autolabel] \{\
.                ie !\\n[tbl*caption-after-label] .nop \
\\*[tbl*label-prfx]\\*[chapno]\\n+[tbl*label-num]\\*[tbl*label-sffx]
.                el \{\
.                   nop \\*[tbl*label-prfx]\\*[chapno]\\n+[tbl*label-num]\\*[tbl*label-sffx]\|
.                   tbl*caption-style
.                   vs \\n[.ps]u+\\n[tbl*caption-autolead]u
.                   ds tbl*caption " \\*[tbl*caption]
.                   nop \\*[tbl*caption]
.                \}
.             \}
.             el \{\
.                if !'\\*[tbl*label]'' \{\
.                   ie !\\n[tbl*caption-after-label] .nop \\*[tbl*label]
.                   el \{\
.                      nop \\*[tbl*label]\ \|\c
.                      tbl*caption-style
.                      vs \\n[.ps]u+\\n[tbl*caption-autolead]u
.                      ds tbl*caption " \\*[tbl*caption]
.                      nop \\*[tbl*caption]
.                   \}
.                \}
.             \}
.             if \\n[tbl*autolabel] \
.                ds tbl*label \\*[chapno]\\n[tbl*label-num]
.             br
.          \}
.          di
.          ev
.          nr pgnum \\n%+\\n[#PAGE_NUM_ADJ]
.          ie !'\\n[.z]'FLOAT*DIV' \{\
.             ie \\n[dn]>\\n[.t] \{\
.                tm1 "[mom]: '\\n[.F]', macro \\$0, line \\n[.c]:
.                tm1 "        Insufficient room for label, caption, and/or source after
.                tm1 "        table on page \\n[pgnum].  Omitting, but continuing to process.
.                if d tbl*header-div .rm tbl*header-div
.                rr tbl*caption-top-lead-diff
.                rr tbl*have-header
.                nr tbl*skip-source 1
.                nr tbl*skip-label 1
.                NEWPAGE
.             \}
.             el .print-label
.          \}
.          el .print-label
.       \}
.    \}
.    if !'\\*[tbl*caption-short]'' .ds short -short
.    ie !'\\*[tbl*label]'' \
.       TO_TABLES "\\*[tbl*label]" "\\*[tbl*caption\\*[short]]"
.    el .TO_TABLES "\\*[tbl*caption]\\*[short]]"
.    if !\\n[tbl*skip-source] \{\
.       if \\n[tbl*have-source] \{\
.          ds tbl*source \\$1
.          SIZESPECS
.          ev source
.          nh
.          ie \\n[#PRINT_STYLE]=1 \{\
.             TYPEWRITER
.             sp
.          \}
.          el \{\
.             tbl*source-style
.             vs \\n[.ps]u+\\n[tbl*source-autolead]u
.          \}
.          di tbl*source-div
.          TBL*SET_SOURCE_QUAD \\*[tbl*source-quad]
.          if \\n[#MLA] \{\
.             if '\\*[tbl*source-quad]'L' \{\
.                in \\n[ind-pre-tbl]u+\\n[tmp-ind]u
.                ti -\\n[tmp-ind]u
.             \}
.          \}
.          if (\\n[tbl*have-label]=0)&(\\n[#MLA]=0) \
.             if !\\n[tbl*autolabel] .sp \\n[#CAP_HEIGHT]u
.          if \\n[#MLA] \
.             sp \\n[#CAP_HEIGHT]u
.          if !'\\*[tbl*source-space]'' .sp \\*[tbl*source-space]
.          nop \\*[tbl*source]
.          br
.          if \\n[#MLA] .in
.          di
.          nf
.          tbl*source-div
.          ev
.       \}
.    \}
.    if '\\n[.z]'FLOAT*DIV' .nr bx-tbl-depth \\n[.d]-1v
.    if '\\n[.z]'tbl*header-div' \{\
.       @error .TS with 'H' flag but no corresponding .TH
.       ab Aborting.
.    \}
.    ev
.    if !\\n[tbl*plain] \{\
.       ie \\n[tbl*plain-boxed] .sp 1
.       el .sp .5v
.    \}
.    ll \\n[ll-pre-tbl]u
.    if !'\\*[tbl*space-adj]'' .sp -\\*[tbl*space-adj]u
.    if !\\n[tbl*no-shim] .SHIM
.    TBL*CLEANUP
.END
\#
\# Utility macros for tbl
\#
.MAC TBL*CAPTION END
.    if \\n[tbl*have-caption] \{\
.       vs \\n[.ps]u+\\n[tbl*caption-autolead]u
.       nr tbl*caption-lead-diff \\n[lead-pre-tbl]-\\n[.v]
.       nr tbl*caption-top-lead-diff \\n[tbl*caption-lead-diff]
.       ie !\\n[#MLA] \{\
.          if !\\n[tbl*caption-after-label] \{\
.             ie !'\\n[.z]'FLOAT*DIV' \{\
.                ie (\\n[nl]=\\n[#PAGE_TOP]):(\\n[nl]=\\n[dc]) \{\
.                   ie \\n[#COLUMNS] .sp |\\n[dc]u
.                   el .sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.                   sp \\n[tbl*caption-lead-diff]u
.                \}
.                el .sp .5v
.             \}
.             el .sp .5v
.          \}
.          ev caption
.          evc \\*[ev-current]
.          nh
.       \}
.       el \{\
.          if !\\n[tbl*autolabel] \{\
.             ie !\\n[tbl*have-label] \
.                mla@error caption label \\n[.F] \\$0 \\n[.c]
.             el .ev label
.          \}
.       \}
.       ie \\n[#PRINT_STYLE]=1 .nr tmp-ind 2m
.       el .nr tmp-ind 1.25m
.       ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.       el \{\
.          if !\\n[#MLA] \{\
.             tbl*caption-style
.             nr lead-current \\n[.v]
.          \}
.       \}
.       ie !\\n[#MLA] \{\
.          ie !\\n[tbl*caption-after-label] \{\
.             di tbl*caption-div
\!.           in -\\n[ind-pre-tbl]u
.             TBL*SET_CAPTION_QUAD \\*[tbl*caption-quad]
.             nop \\*[tbl*caption]
.             br
.             di
.             if !'\\n[.z]'FLOAT*DIV' \{\
.                nr caption-needs 2
.                if (\\n[dn]+(\\n[#DOC_LEAD]*(\\n[tbl*needs]*2)))>\\n[.t] \{\
.                   nr pgnum \\n%+\\n[#PAGE_NUM_ADJ] 1
.                   ie \\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.                      tm1 "[mom]: Table with caption at line \\n[.c] does not fit on page \\n[pgnum].
.                      tm1 "       Shifting table to page \\n+[pgnum].
.                      rr tbl*no-header
.                      NEWPAGE
.                   \}
.                   el \{\
.                      sp \\n[.t]u
.                      sp |\\n[#PAGE_TOP]u+\\n[tbl*caption-lead-diff]u
.                   \}
.                \}
.             \}
.             if \\n[.u] .nr fill 1
.             nf
.             if \\n[.ns] .RESTORE_SPACE
.             tbl*caption-div
.             if \\n[#PRINT_STYLE]=1 .sp .5v
.             if !'\\*[tbl*caption-space]'' \
.                sp \\*[tbl*caption-space]
.             if \\n[tbl*caption-lead-diff-adj] \{\
.                sp -\\n[tbl*caption-lead-diff]u
.                rr tbl*label-lead-diff-adj
.             \}
.             if \\n[fill] .fi
.             rr fill
.          \}
.          el \{\
.             if (\\n[tbl*have-label]=0) \{\
.                if !\\n[tbl*autolabel] \{\
.                   tm1 "[mom]: CAPTION_AFTER_LABEL enabled, but no label given
.                   tm1 "       for table at line \\n[.c].
.                   tm1 "       Skipping caption but continuing to process.
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          if (\\n[tbl*have-label]=1):(\\n[tbl*autolabel]=1) \{\
.             ie !\\n[tbl*have-caption] \
.                mla@error label caption \\n[.F] \\$0 \\n[.c]
.             el \{\
.                ie !'\\n[.z]'FLOAT*DIV' \{\
.                   ie (\\n[nl]=\\n[#PAGE_TOP]):(\\n[nl]=\\n[dc]) \{\
.                      ie !\\n[#COLUMNS] .sp |\\n[#PAGE_TOP]u+\\n[tbl*caption-lead-diff]u
.                      el .sp |\\n[dc]u+\\n[tbl*caption-lead-diff]u
.                   \}
.                   el .sp .5v
.                \}
.                el .sp .5v
.             \}
.             ev label
.             evc \\*[ev-current]
.             nh
.             ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.             el \{\
.                tbl*label-style
.                vs \\n[.ps]u+\\n[tbl*label-autolead]u
.                nr tbl*label-lead-diff \\n[lead-pre-tbl]-\\n[.v]
.             \}
.             if \\n[tbl*label-with-chapter] \
.                ds chapno \\n[#CH_NUM].
.             TBL*SET_LABEL_QUAD \\*[tbl*label-quad]
.             di tbl*mla-label-caption
.             ie '\\*[tbl*label-quad]'L' \{\
\!.              in -\\n[ind-pre-tbl]u
\!.              in \\n[tmp-ind]u
\!.              ti -\\n[tmp-ind]u
.             \}
.             el \{\
.                if \\n[tbl*label-quad-on-ll] \{\
.                   if '\\n[tbl*label-quad]'L' \
\!.                 in
.                \}
.             \}
.             ie \\n[tbl*autolabel] \
.                nop \
\\*[tbl*label-prfx]\\*[chapno]\\n+[tbl*label-num]\\*[tbl*label-sffx]
.             el .if !'\\*[tbl*label]'' .nop \\*[tbl*label]
.             if \\n[tbl*autolabel] \
.                ds tbl*label \\*[chapno]\\n[tbl*label-num]
.             br
.             di
.          \}
.          da tbl*mla-label-caption
.          ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.          el .tbl*caption-style
.          if '\\*[tbl*caption-quad]'L' \{\
\!.           ti -\\n[tmp-ind]u
\!.           fi
.          \}
.          nop \\*[tbl*caption]
.          br
\!.        in
.          da
.       \}
.       if !'\\n[.z]'FLOAT*DIV' \{\
.          ie \\n[#MLA] .nr caption-needs 3
.          el .nr caption-needs 2
.          if (\\n[dn]+(\\n[#DOC_LEAD]*(\\n[tbl*needs]+\\n[caption-needs])))>\\n[.t] \{\
.             nr pgnum \\n%+\\n[#PAGE_NUM_ADJ] 1
.             ie \\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.                tm1 "[mom]: Table with caption at line \\n[.c] does not fit on page \\n[pgnum].
.                tm1 "       Shifting table to page \\n+[pgnum].
.                rr tbl*no-header
.                if \\n[defer] .nr skip-th-warning 1
.                NEWPAGE
.             \}
.             el \{\
.                nr tbl*no-top-hook 1
.                sp \\n[.t]u
.                if (\\n[tbl*caption-after-label]=1):(\\n[tbl*plain]) \
.                   sp 1n-2p
.             \}
.          \}
.       \}
.       nf
.       if (\\n[nl]=\\n[#PAGE_TOP]):(\\n[nl]=\\n[dc]) \
.          nr tbl*label-lead-diff-adj 1
.       ie (\\n[.t]>1)&(\\n[@TOP]=0) \{\
.          sp \\n[tbl*label-lead-diff]u
.       \}
.       el \{\
.          if \\n[.t]=1 .sp \\n[.t]u
.          ie \\n[#COL_NUM]>1 \
.             ie (\\n[nl]=\\n[#PAGE_TOP]):(\\n[nl]=\\n[dc]) \
.                sp |\\n[dc]u+\\n[tbl*label-lead-diff]u
.             el .sp .5v
.       \}
.       tbl*mla-label-caption
.       ie \\n[#PRINT_STYLE]=1 .sp .5v
.       el .sp .5n
.       if \\n[tbl*label-lead-diff-adj] \{\
.          sp -\\n[tbl*label-lead-diff]u
.          rr tbl*label-lead-diff-adj
.       \}
.       br
.       if !'\\*[tbl*caption-space]'' .sp \\*[tbl*caption-space]
.    \}
.    if !'\\n[.ev]'0' .ev
.END
\#
.MAC TBL*CLEANUP END
.    if !'\\n[.z]'FLOAT*DIV' \{\
.       rr tbl*center
.       rm tbl*header-div
.       rr tbl*caption-top-lead-diff
.    \}
.    rr tbl*have-header
.    if !'\\n[.z]'FLOAT*DIV' \{\
.       rr tbl*have-caption
.       rr tbl*have-label
.    \}
.    rr tbl*label-warning
.    rr tbl*no-shim
.    rr tbl*skip-source
.    if !'\\n[.z]'FLOAT*DIV' \{\
.       rm short
.       rm tbl*caption
.       rm tbl*caption-short
.       rm tbl*label
.    \}
.    rm tbl*space-adj
.    rnn tbl*have-label tbl@label
.    rnn tbl*have-source tbl@source
.    rr tbl*have-label
.    rr tbl*plain
.    if '\\*[tbl*label-sffx-tmp]'.' .ds tbl*label-sffx .
.END
\#
.MAC print-label END
.    if \\n[.u] .nr fill 1
.    nf
.    if !\\n[tbl*skip-label] \{\
.       tbl*label-div
.    \}
.    if \\n[fill] .fi
.    rr fill
.END
\#
.MAC tbl@top-hook END
.    if \\n[tbl*have-header] \{\
.       nf
.       rr @TOP
.       ch RR_@TOP
.       ev top-hook
.       evc 0
.       rs
.       nop \&
.       ie !\\n[tbl*boxed] .sp -1
.       el .sp -1n
.       tbl*print-header
.       ev
.    \}
.END
\#
.MAC tbl*print-header END
.    if \\n[.u]=1 \{\
.       nf
.       nr fill 1
.    \}
.    if \\n[#COL_NUM]>1 \
.       sp 2p
.    ie d tbl*header-div:\\n[loop-count] \
.       tbl*header-div:\\n[loop-count]
.    el .tbl*header-div
.    if '\\n[.z]'FLOAT*DIV' \
.       if \\n[tbl*center] .ce 1000
.    mk #T
.    if !'\\n[.z]'FLOAT*DIV' \{\
.       nr pre-tbl-vfp 0+\\n[#VARIABLE_FOOTER_POS]
.       ch FOOTER \\n[#VARIABLE_FOOTER_POS]u+\\n[#DOC_LEAD]u
.       ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u+\\n[#DOC_LEAD]u
.    \}
.END
\#
.MAC tbl@bottom-hook END
.       if \\n[.ns] .rs
.       rr #DIVERTED
.       rr @TOP
.       ch RR_@TOP
.END
\#
.MAC tbl*float-warning END
.    tm1 "[mom]: Table in FLOAT, output page \\n[#PAGENUMBER], exceeds page vertical limits.
.    tm1 "       Multipage boxed tables cannot be contained within floats.
.    ab Aborting '\\n[.F]'.
.END
\#
.MAC ds@need END \" Move vertically until there is enough space for \$1
.    if '\\n(.z'' \{\
.       while \\n[.t]<=(\\$1)&(\\n[nl]>\\n[#PAGE_TOP]) \{\
.          rs
'          sp \\n[.t]u
.       \}
.    \}
.END
\#
\# ***eqn***
\#
\# EQ/EN macros borrowed from ms, mommified by Robin Haberkorn
\# <robin.haberkorn@googlemail.com>, expanded by Peter Schaffter.
\#
\# EQ [ -L | -C | -I <indent> ] [label]
\# EN [ CONT | CONTINUED | ... ]
\#
\# Equations are centered by default, but can be left-justified
\# (EQ -L), explicitly centered, or indented (EQ -I).
\#
\# Each eqn block for multi-line equations aligned with 'mark' and
\# 'lineup' should be terminated by passing 'CONT' or 'CONTINUED'
\# or '...' to EN.
\#
\# Note that geqn mark and lineup work correctly in centered equations.
\#
.MAC EQ END
.    if \\n[eqn*copy-in]=1 \{\
.       if !\\n[eqn-linenum] .nr eqn-linenum \\n[.c]
.       if !\\n[pgnum] .nr pgnum \\n%+\\n[#PAGE_NUM_ADJ]
.       br
.       if \\n[.u] .nr fill 1
.       rr float*eqn
.       if '\\n[.z]'FLOAT*DIV' .nr float*eqn 1
.       nr eqn*restore-adj \\n[.j]
.       if !\\n[continued] \{\
.          PDF_TARGET eqn:\\n+[lists*target]
.          rr eqn*type
.          nr loop-counter \\n[#NUM_ARGS]
.          nr loop-count 0 1
.          while \\n+[loop-count]<=\\n[loop-counter] \{\
.             if '\\$1'-L' \{\
.                nr eqn*left 1
.                nr eqn*type 1
.                shift
.             \}
.             if '\\$1'-I' \{\
.                nr eqn*ind  1
.                nr eqn*type 2
.                shift
.                ds DI \\$1
.                ds DI@cont \\*[DI]
.                shift
.             \}
.             if '\\$1'-C' \{\
.                nr eqn*center 1
.                nr eqn*type   3
.                shift
.             \}
.             if '\\$1'ADJUST' \{\
.                ds eqn*space-adj \\$2
.                shift 2
.             \}
.             if '\\$1'NO_SHIM' \{\
.                nr eqn*no-shim 1
.                shift 1
.             \}
.             if '\\$1'LABEL' \{\
.                ds eqn*label \\$2
.                ds label-type eqn
.                shift 2
.             \}
.             if '\\$1'SHIFT_LABEL' \{\
.                ds eqn*shift-label \\$2
.                shift 2
.             \}
.             if '\\$1'CAPTION' \{\
.                ds eqn*caption \\$2
.                shift 2
.             \}
.             if '\\$1'SHORT_CAPTION' \{\
.                ds eqn*caption-short \\$2
.                shift 2
.             \}
.          \}
.       \}
.       if '\\*[eqn*shift-label]'' .ds eqn*shift-label 0
.       if !\\n[eqn*type] \{\
.          nr eqn*center 1
.          nr eqn*type   3
.          shift
.       \}
.       if !'\\*[eqn*caption]'' \{\
.          if '\\*[caption-quad]'L' \{\
.             if \\n[default-left] .ds caption-quad R
.             rr default-left
.          \}
.       \}
.       if \\n[continued] \{\
.          rm continued
.          rr continued
.       \}
.       if \\n[eqn@left*cont] .nr eqn*type 1
.       if \\n[eqn@ind*cont]  \{\
.           nr eqn*type 2
.           ds DI \\*[DI@cont]
.       \}
.    \}
.    if \\n[eqn@center*cont] .nr eqn*type 3
.    ev EQN
.    evc 0
.    di eqn*div
.    in 0
.    nf
.END
\#
.MAC EN END
.    if !'\\n(.z'eqn*div' \{\
.       @error mismatched EN
.       return
.    \}
.    br
.    di
.    ev
.    if !'\\*[eqn*label]''   .nr eqn*have-label   1
.    if !'\\*[eqn*caption]'' .nr eqn*have-caption 1
.    if !'\\$1'' \{\
.       ie '\\$1'...' .ds continued CONT
.       el .ds continued \\$1
.       substring continued 0 3
.       ie '\\*[continued]'CONT' \{\
.          nr continued 1
.          rm continued
.          if \\n[eqn*ind]    .nr eqn@ind*cont    1
.          if \\n[eqn*left]   .nr eqn@left*cont   1
.          if \\n[eqn*center] .nr eqn@center*cont 1
.       \}
.       el \{\
.          tm1 "[mom]: Invalid argument \\$1 to \\$0.
.          tm1 "       Must be 'CONTINUED', 'CONT', or '...'
.          ab Aborting '\\n[.F]' at line \\n[.c].
.       \}
.    \}
.    if \\n[dl]:\\n[eqn*have-label] \{\
.       ds eqn*tabs \\n[.tabs]
.       if \\n[eqn*label-with-chapter] \
.          ds chapno \\n[#CH_NUM].
.       nf
.       ie \\n[dl] \{\
.          if !'\\n[.z]'FLOAT*DIV' \{\
.             ie \\n[eqn*have-caption] .ne \\n[dn]u-\\n[.V]
.             el .ne \\n[dn]u-1v-\\n[.V]
.          \}
.          chop eqn*div
.          if '\\*[DD]'' \{\
.             ds DD .5v
.             if !\\n[@TOP] \{\
.                sp \\*[DD]
.                if !'\\*[eqn*space-adj]'' .sp \\*[eqn*space-adj]u
.             \}
.          \}
.          if \\n[cutaround] .ll \\n[eqn*cutaround-width]u
.          ie \\n[eqn*type]=1 \{\
.             ta (u;\\n[.l]-\\n[.i])R
.             ie \\n[continued] .nop \\*[eqn*div]
.             el \{\
.                ie \\n[eqn*autolabel] \
.nop \
\\*[eqn*div]\
\\*[eqn*label-specs]\
\t\v'+\\*[eqn*shift-label]'\
\\*[eqn*label-prfx]\\*[chapno]\\n+[eqn*label-num]\\*[eqn*label-sffx]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]
.                el \
.nop \
\\*[eqn*div]\
\\*[eqn*label-specs]\
\t\v'+\\*[eqn*shift-label]'\
\\*[eqn*label]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]
.             \}
.             if \\n[eqn-cutaround] .ll
.             if !\\n[continued] \{\
.                if \\n[eqn*have-caption] \
.                   ADD_CAPTION
.             \}
.          \}
.          el \{\
.             ie \\n[eqn*type]=2 \{\
.                ie '\\*[eqn*label-quad]'L' \{\
.                   ta \\*[DI]
.                   ie \\n[continued] .nop \t\\*[eqn*div]
.                   el \{\
.                      ie \\n[eqn*autolabel] \
.nop \
\\*[eqn*label-specs]\
\v'+\\*[eqn*shift-label]'\
\\*[eqn*label-prfx]\\*[chapno]\\n+[eqn*label-num]\\*[eqn*label-sffx]\
\v'-\\*[eqn*shift-label]'\
\t\\*[eqn*div]\
\\*[revert-specs]
.                      el \
.nop \
\\*[eqn*label-specs]\
\v'+\\*[eqn*shift-label]'\
\\*[eqn*label]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]\
\t\\*[eqn*div]
.                   \}
.                \}
.                el \{\
.                   ta \\*[DI] (u;\\n[.l]-\\n[.i])R
.                   ie \\n[continued] .nop \t\\*[eqn*div]
.                   el \{\
.                      ie \\n[eqn*autolabel] \
.nop \
\t\\*[eqn*div]\
\\*[eqn*label-specs]\
\t\v'+\\*[eqn*shift-label]'\
\\*[eqn*label-prfx]\\*[chapno]\\n+[eqn*label-num]\\*[eqn*label-sffx]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]
.                      el \
.nop \
\t\\*[eqn*div]\
\\*[eqn*label-specs]\
\t\v'+\\*[eqn*shift-label]'\
\\*[eqn*label]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]
.                   \}
.                \}
.                if !\\n[continued] \{\
.                   if \\n[eqn*have-caption] \
.                      ADD_CAPTION
.                \}
.             \}
.             el \{\
.                ie '\\*[eqn*label-quad]'L' \{\
.                   ta (u;\\n[.l]-\\n[.i]/2)C
.                   ie \\n[continued] .nop \t\\*[eqn*div]
.                   el \{\
.                      ie \\n[eqn*autolabel] \
.nop \
\\*[eqn*label-specs]\
\v'+\\*[eqn*shift-label]'\
\\*[eqn*label-prfx]\\*[chapno]\\n+[eqn*label-num]\\*[eqn*label-sffx]\
\v'-\\*[eqn*shift-label]'\
\t\\*[eqn*div]\
\\*[revert-specs]
.                      el \
.nop \
\\*[eqn*label-specs]\
\v'+\\*[eqn*shift-label]'\
\\*[eqn*label]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]\
\t\\*[eqn*div]
.                   \}
.                \}
.                el \{\
.                   ta (u;\\n[.l]-\\n[.i]/2)C (u;\\n[.l]-\\n[.i])R
.                   ie \\n[continued] .nop \t\\*[eqn*div]
.                   el \{\
.                      ie \\n[eqn*autolabel] \
.nop \
\t\\*[eqn*div]\
\\*[eqn*label-specs]\
\t\v'+\\*[eqn*shift-label]'\
\\*[eqn*label-prfx]\\*[chapno]\\n+[eqn*label-num]\\*[eqn*label-sffx]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]
.                      el \
.nop \
\t\\*[eqn*div]\
\\*[eqn*label-specs]\
\t\v'+\\*[eqn*shift-label]'\
\\*[eqn*label]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]
.                   \}
.                \}
.                if !\\n[continued] \{\
.                   if \\n[eqn*have-caption] \
.                      ADD_CAPTION
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          ta (u;\\n[.l]-\\n[.i])R
.nop \
\\*[eqn*label-specs]\
\t\v'+\\*[eqn*shift-label]'\
\t\\*[eqn*label]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]
.       \}
.       ta \\*[eqn*tabs]
.\" if continuing (ie is a multi-line equation), don't space and SHIM
.       if !\\n[continued] \{\
.          sp \\*[DD]
.          if !'\\*[eqn*space-adj]'' .sp -\\*[eqn*space-adj]u
.          if !'\\n[.z]'FLOAT*DIV' \{\
.             if !\\n[eqn*no-shim] .SHIM
.          \}
.          if !'\\*[eqn*caption-short]'' .ds short -short
.          if \\n[eqn*autolabel] \
.             ds eqn*label \\*[chapno]\\n[eqn*label-num]
.          ie !'\\*[eqn*label]'' \
.             TO_EQUATIONS "\\*[eqn*label]" "\\*[eqn*caption\\*[short]]"
.          el .TO_EQUATIONS "\\*[eqn*caption\\*[short]]"
.          rm DD
.          rm eqn*caption
.          rm eqn*caption-short
.          rm eqn*label
.          rm short
.          rr eqn*copy-in
.       \}
.       rm DI@cont
.       rr eqn*center
.       rr eqn@center*cont
.       rr eqn*have-label
.       rr eqn*ind
.       rr eqn@ind*cont
.       rr eqn*left
.       rr eqn@left*cont
.       if !\\n[eqn-cutaround] .rm eqn*space-adj
.    \}
.    nr eqn*copy-in 1
.    if \\n[fill] .fi
.    ad \\n[eqn*restore-adj]
.    rr fill
.END
\#
.MAC ADD_CAPTION END
.    ie \\n[.t]<\\n[.v] \{\
.       if !'\\n[.z]'FLOAT*DIV' \{\
.          if \\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.             tm1 "[mom]: '\\n[.F]', macro EQ, line \\n[eqn-linenum]: Insufficient room for
.             tm1 "        equation caption on page \\n[pgnum].
.             tm1 "        Skipping caption, but continuing to process.
.             if !\\n[@TOP] \{\
.                if \\n[#COL_NUM]=\\n[#NUM_COLS] \
.                   NEWPAGE
.             \}
.             rr eqn-linenum
.             rr pgnum
.          \}
.       \}
.    \}
.    el \{\
.       if \\n[#PRINT_STYLE]=2 \{\
.          ps \\*[eqn*caption-size-change]
.          nr lead-curr \\n[.v]
.          sp .5v
.          vs \\n[.ps]u+\\n[eqn*caption-autolead]u
.          nr eqn*caption-lead-diff \\n[lead-curr]-\\n[.v]
.          sp \\n[eqn*caption-lead-diff]u
.          ps
.          if !'\\*[eqn*caption-space]'' \
.             sp \\*[eqn*caption-space]
.       \}
.       if '\\*[eqn*caption-quad]'L' \{\
.          fi
.          ad l
.          nop \
\\*[eqn*caption-specs]\
\\*[eqn*caption]\
\\*[revert-specs]
.          nf
.       \}
.       if '\\*[eqn*caption-quad]'C' \{\
.          fi
.          ad c
.          nop \
\\*[eqn*caption-specs]\
\\*[eqn*caption]\
\\*[revert-specs]
.          nf
.       \}
.       if '\\*[eqn*caption-quad]'R' \{\
.          fi
.          ad r
.          nop \
\\*[eqn*caption-specs]\
\\*[eqn*caption]\
\\*[revert-specs]
.          nf
.       \}
.       if !'\\*[eqn*caption-space]'' \
.          sp -\\*[eqn*caption-space]
.       vs
.    \}
.END
\#
\# ***pic***
\#
.MAC have-adjust END
.    nr #ARGS  0 1
.    nr #COUNT \\n[#NUM_ARGS]
.    while \\n+[#ARGS]<=\\n[#COUNT] \{\
.       if '\\$1'ADJUST' \{\
.          ds pic*space-adj \\$2
.          break
.       \}
.       shift
.    \}
.END
\#
\# User settable text style for pic
\#
\# PIC_TEXT_STYLE
\# --------------
\# *Argument:
\#   <offset from page left>
\# *Function:
\#   Stores user supplied page offset in register #L_MARGIN.
\#   Sets .po to user supplied offset.
\# *Notes:
\#   Requires unit of measure.
\#
.MAC PIC_TEXT_STYLE END
.    nr #ARGS  0 1
.    nr #COUNT \\n[#NUM_ARGS]
.    while \\n+[#ARGS]<=\\n[#COUNT] \{\
.       if '\\$1'FAMILY' \{\
.          shift
.          ds pic*text-family \\$1
.          shift
.       \}
.       if '\\$1'FONT' \{\
.          shift
.          ds pic*text-font \\$1
.          shift
.       \}
.       if '\\$1'SIZE' \{\
.          shift
.          ds pic*text-size-change \\$1
.          shift
.       \}
.       if '\\$1'AUTOLEAD' \{\
.          shift
.          nr pic*text-autolead \\$1
.          shift
.       \}
.    \}
.END
\#
\# Main macros
\#
.MAC PS END
.    br
.    have-adjust \\$@ \" Adjusting is handled by FLOAT
.    ds ev-current \\n[.ev]
.    rr float*pic
.    if !'\\n[.z]'FLOAT*DIV' .FLOAT ADJUST \\*[pic*space-adj]
.    PDF_TARGET fig:\\n+[lists*target]
.    nr float*pic 1
.    nr ind-pre-pic  \\n[.i]
.    nr ll-pre-pic   \\n[.l]
.    nr lead-pre-pic \\n[.v]
.    if \\n[#MLA] .sp .5v
.    in 0
.    ev PIC
.    evc \\n[ev-current]
.    nf
.    ie \\n[#NUM_ARGS]<2 .@error bad arguments to PS (not preprocessed with pic?)
.    el \{\
.       if \B'\\$1' \{\
.          ie !\B'\\$2' .ds pic*scale-width \\$1
.          el .ds pic*scale-width \\$2
.       \}
.    \}
. \" This is a bit confusing. pic is decorated with 2 args (width
. \" and height), which are read during pre-processing but have to be
. \" ignored when parsing args during main processing.  We shift pic's
. \" args out of the way, then pop them off the arg stack because
. \" they're not needed during macro processing.
.    while \B'\\$1' .shift
.    nr loop-counter \\n[#NUM_ARGS]
.    nr loop-count 0 1
.    while \\n+[loop-count]<=\\n[loop-counter] \{\
.       if '\\$1'NO_SHIM' \{\
.          nr float*no-shim 1
.          shift 1
.       \}
.       if '\\$1'LEFT' \{\
.          nr pic*left 1
.          shift 1
.       \}
.       if '\\$1'CAPTION' \{\
.          nr pic*have-caption 1
.          ds pic*caption \\$2
.          shift 2
.       \}
.       if '\\$1'SHORT_CAPTION' \{\
.          ds pic*caption-short \\$2
.          shift 2
.       \}
.       if '\\$1'LABEL' \{\
.          nr pic*have-label 1
.          ds pic*label \\$2
.          ds label-type pic
.          shift 2
.       \}
.    \}
.    ds pic*label-sffx-tmp \\*[pic*label-sffx]
.    substring pic*label-sffx-tmp -1
.    if '\\*[pic*label-sffx-tmp]'.' \
.       if \\n[pic*caption-after-label]=0 .chop pic*label-sffx
.    if \\n[#MLA] \{\
.       if (\\n[pic*have-label]=1):(\\n[pic*autolabel]=1) \{\
.          if !\\n[pic*have-caption] \
.             mla@error label caption \\n[.F] \\$0 \\n[.c]
.       \}
.       if \\n[pic*have-caption] \{\
.          if !\\n[pic*have-label] \{\
.             if !\\n[pic*autolabel] \
.                mla@error caption label \\n[.F] \\$0 \\n[.c]
.          \}
.       \}
.    \}
.    if !'\\*[pic*text-family]'' \
.       fam \\*[pic*text-family]
.    if !'\\*[pic*text-font]'' \
.       ft \\*[pic*text-font]
.    if !'\\*[pic*text-size-change]'' \
.       ps \\n[#DOC_PT_SIZE]u\\*[pic*text-size-change]
.    nr lead-current \\n[.v]
.    ie \\n[pic*text-autolead] \
.       vs \\n[.ps]u+(\\n[pic*text-autolead]u*1000u)
.    el .vs \\n[.ps]u
.    nr pic@text-lead \\n[.v]
.    nr pic@text-size \\n[.ps]
.    if !'\\*[pic*text-color]'' .gcolor \\*[pic*text-color]
.    if \\n[@TOP] \{\
.       RESTORE_SPACE
.       nr pic*top-lead-adj 1
.    \}
.    nr pic*top-lead-diff \\n[lead-pre-pic]u-\\n[.v]u
.    if (\\n[pic*have-caption]=0):(\\n[pic*caption-after-label]=1) \{\
.       ie \\n[pic*top-lead-adj] \{\
.          sp \\n[pic*top-lead-diff]u
.          rr pic*top-lead-adj
.       \}
.       el .if (\\n[pic*caption-after-label]=0):(\\n[#MLA]=0) .sp \\n[lead-pre-pic]u/2u
.    \}
.    di pic*div
.END
\#
.MAC PE END
.    di
.    nr pic*div-width \\n[dl]
.    if \\n[@TOP] \{\
.       RESTORE_SPACE
.    \}
.    sp \\n[lead-pre-pic]u/2u
.    if (\\n[pic*have-caption]=1)&(\\n[pic*caption-after-label]=0) \{\
.       sp .5v
.       ev caption
.       evc \\*[ev-current]
.       nh
.       ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.       el \{\
.          pic*caption-style
.          nr lead-current \\n[.v]
.          vs \\n[.ps]u+\\n[pic*caption-autolead]u
.          nr pic*caption-lead-diff \\n[lead-current]-\\n[.v]
.          in \\n[ind-pre-pic]u
.       \}
.       PIC*SET_CAPTION_QUAD \\*[pic*caption-quad]
.       if \\n[@TOP] .RESTORE_SPACE
\!.     in -\\n[ind-pre-pic]u
.       sp \\n[pic*caption-lead-diff]u
\!.     if \\\\n[.ns] .rs
.       nop \\*[pic*caption]
.       if \\n[#PRINT_STYLE]=1 .sp .5v
.       if !'\\*[pic*caption-space]'' \
.          sp \\*[pic*caption-space]
.       br
.       ev
.    \}
.    if !\\n[pic*left] .in \\n[ll-pre-pic]u-\\n[pic*div-width]u/2u
.    pic*div
.    sp
.    if (\\n[pic*have-label]=1):(\\n[pic*autolabel]=1):(\\n[pic*caption-after-label]=1) \{\
.       nr lead-pre-label \\n[.v]
.       ev label
.       evc \\*[ev-current]
.       ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.       el \{\
.          pic*label-style
.          nr lead-current \\n[.v]
.          vs \\n[.ps]u+\\n[pic*label-autolead]u
.          in \\n[ind-pre-pic]u
.          sp \\n[lead-current]u-\\n[.v]u
.       \}
.       if \\n[pic*label-with-chapter] \
.          ds chapno \\n[#CH_NUM].
.       PIC*SET_LABEL_QUAD \\*[pic*label-quad]
\!.     in -\\n[ind-pre-pic]u
.       sp \\n[lead-pre-label]u-\\n[.v]u
.       if !'\\*[pic*label-space]'' .sp \\*[pic*label-space]
.       if \\n[#PRINT_STYLE]=1 .sp .5v
.       ie \\n[pic*autolabel] \
.         nop \
\\*[pic*label-prfx]\\*[chapno]\\n+[fig*label-num]\\*[pic*label-sffx]\|
.       el .if !'\\*[pic*label]'' .nop \\*[pic*label]
.       if \\n[pic*autolabel] \
.          ds pic*label \\*[chapno]\\n[fig*label-num]
.       fam
.       ft
.       ps
.       gcolor
.       ie !\\n[pic*caption-after-label] .br
.       el \{\
.          if !'\\*[pic*caption]'' .nop \
\\*[pic*caption-specs]\\*[pic*caption]\\*[revert-specs]
.          br
.       \}
.       ev
.       in 0
.    \}
.    ev
.    sp .5v
.    FLOAT off
.    in \\n[ind-pre-pic]u
.    if !'\\*[pic*caption-short]'' .ds short -short
.    ie !'\\*[pic*label]'' \
.       TO_FIGURES "\\*[pic*label]" "\\*[pic*caption\\*[short]]"
.    el .TO_FIGURES "\\*[pic*caption\\*[short]]"
.    rm pic*caption
.    rm pic*label
.    rm pic*left
.    rm short
.    if !\\n[cutaround] .rm pic*space-adj
.    if !\\n[defer] .rr pic*have-caption
.    rr pic*have-label
.    rr float*pic
.    if '\\*[pic*label-sffx-tmp]'.' .ds pic*label-sffx .
.END
\#
\# ***refer***
\#
\# Footnote references
\# -------------------
\# *Function:
\#   Instruct REF to put references in footnotes.
\#
.MAC FOOTNOTE_REFS END
.    ie !'\\$1'' .rr #FN_REF
.    el \{\
.       if r #EN_REF .rr #EN_REF
.       nr #FN_REF 1
.    \}
.    REF_STYLE NOTE
.END
\#
\# Endnote references
\# ------------------
\# *Function:
\#   Instruct REF to collect references for endnotes output.
\#
.MAC ENDNOTE_REFS END
.    ie !'\\$1'' .rr #EN_REF
.    el \{\
.       if r #FN_REF .rr #FN_REF
.       nr #EN_REF 1
.       if !r#EN_MARKER_STYLE .ENDNOTE_MARKER_STYLE SUPERSCRIPT
.    \}
.    REF_STYLE NOTE
.END
\#
\# Prepare mom for a reference
\# ---------------------------
\# *Argument:
\#   <none> | INDENT  L|LEFT|R|RIGHT|B|BOTH  <indent value>
\# *Function:
\#   Calls FOOTNOTE or ENDNOTE, depending on whether #REF_FN or
\#   #REF_EN is set to 1.
\# *Notes:
\#   For convenience, REF is a toggle.
\#
\#   REF optionally takes the same arguments as FOOTNOTE, allowing
\#   users to indent references that go in footnotes when footnote
\#   indenting is required.  FOOTNOTE_REFS must be on for this.
\#
.MAC REF END
.    ie \\n[#FN_REF]+\\n[#EN_REF]=0 \{\
.       if !\\n[#REF_WARNING]=1 \{\
.          tm1 "[mom]: Before REF at line \\n[.c], neither FOOTNOTE_REFS nor ENDNOTE_REFS
.          tm1 "       has been selected.  If "sort" and "accumulate" are in your refer
.          tm1 "       commands, references will be collected for later output with $LIST$.
.          tm1 "       Otherwise, they will disappear.
.          nr #REF_WARNING 1
.       \}
.    \}
.    el \{\
.       ie \\n[#REF]=1 \{\
.          if \\n[#FN_REF]=1 .FOOTNOTE OFF
.          if \\n[#EN_REF]=1 .ENDNOTE OFF
.          rr #REF
.       \}
.       el \{\
.          rr #REF_WARNING
.          nr #REF 1
.          if \\n[#FN_REF]=1 .FOOTNOTE \\$1 \\$2 \\$3
.          if \\n[#EN_REF]=1 .ENDNOTE
.       \}
.    \}
.END
\#
\# Embedded references in text (with brackets)
\# -------------------------------------------
\#
.MAC REF_BRACKETS_NOTICE END
.    tm1 "[mom]: \\$1 has been removed from mom.  See the mom documentation 'refer.html'
.    tm1 "       for instructions on parenthetical insertions of references into text.
.    ie '\\$1'REF_STYLE' .tm1 "       Continuing to process '\\n[.F]' from line \\n[.c].
.    el .ab Aborting '\\n[.F]' at \\$1, line \\n[.c].
.END
\#
.MAC REF_BRACKETS_START END
.    REF_BRACKETS_NOTICE \\$0
.END
\#
.MAC REF_BRACKETS_END END
.    REF_BRACKETS_NOTICE \\$0
.END
\#
\# These four pairs of aliases allow users to embed references in
\# text and have them surrounded by (), [], {} or <>.
\#
.ALIAS REF( REF_BRACKETS_START
.ALIAS REF) REF_BRACKETS_END
\#
.ALIAS REF[ REF_BRACKETS_START
.ALIAS REF] REF_BRACKETS_END
\#
.ALIAS REF{ REF_BRACKETS_START
.ALIAS REF} REF_BRACKETS_END
\#
.ALIAS REF< REF_BRACKETS_START
.ALIAS REF> REF_BRACKETS_END
\#
.MAC REF_STYLE END
.    REF_BRACKETS_NOTICE \\$0
.END
\#
\# Refer indenting
\# ---------------
\# *Argument:
\#   FOOTNOTE | ENDNOTE | BIBLIO <indent for 2nd and subsequent lines of discrete reference entries>
\# *Function:
\#   Sets registers #REF_FN_INDENT, #REF_EN_INDENT or #REF_BIB_INDENT.
\# *Notes:
\#   Indent value requires a unit of measure.  If refs are going
\#   into footnotes or endnotes, first lines get indented; if going
\#   into a bibliography, second lines get indented
\#
.MAC INDENT_REFS END
.    if '\\$1'FOOTNOTE' .ds $REF_FN_INDENT  \\$2
.    if '\\$1'ENDNOTE'  .ds $REF_EN_INDENT  \\$2
.    if '\\$1'BIBLIO'   .ds $REF_BIB_INDENT \\$2
.END
\#
\# Hyphenation of references
\# -------------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Sets register #REF_HY
\#
.MAC HYPHENATE_REFS END
.    ie '\\$1'' .nr #REF_HY 1
.    el \{\
.       if r #REF_HY .rr #REF_HY
.    \}
.END
\#
\# The remainder of the definitions in this section are modified
\# versions of the definitions found in the refer module of s.tmac.
\#
.de @error
.tm [mom]: '\\n[.F]', line \\n[.c]: \\$*
..
\#
\# Underlining unavoidably turns off sentence spacing.
\#
.de ref*restore-ss
\c
.SS \\*[$SAVED_SS_VAR]
.if '\\n[.z]'END_NOTES' \{\
\c
\E*[PREV]\c
.\}
..
\# The following strings define the order of entries for different
\# types of references.  Each letter in the string refers to a database
\# field (A for author, T1/T2 for article and book titles, etc).
\#
.de ref*specs
.if \\n[#PRINT_STYLE]=1 \{\
.   char '     \[aq]
.   char \[oq] \[aq]
.\}
.\" Internet site - type 0
.ds ref*spec!0 i Q A m p T2 s o D c a u n
.\" Journal article - type 1
.ds ref*spec!1 i Q A m p T2 q O J V S N D P n
.\" Book - type 2
.ds ref*spec!2 i Q A m p T1 q b d l r E S e V O C I D P t n
.\" Article within book - type 3
.ds ref*spec!3 i Q A m p T2 B b d l r E S e V O C I D P t n
.\" Tech report - type 4
.ds ref*spec!4 i Q A m p T1 R G O C I D P n
.\" Magazine or newspaper article - type 5
.ds ref*spec!5 i Q A m p T2 O M V S N D P n
..
\#
\# Refer's "1st" macro.  Since it is possible to define database
\# fields using any single letter, we remove all possible string
\# definitions of the form [X and [x.  Also, reset ref*spec!<n>
\# strings to their defaults.
\#
.de ]-
.ref*specs
.rm [A [B [C [D [E [F [G [H [I [J [K [L [M \
    [N [O [P [Q [R [S [T [U [V [W [X [Y [Z \
    [a [b [c [d [e [f [g [h [i [j [k [l [m \
    [n [o [p [q [r [s [t [u [v [w [x [y [z
.if r [e .rr [e \" [e persists if %e field is last
.rr ref*type
.rm ref*string
..
\#
\# Refer's "2nd" macro; builds up a reference with ref*build, and
\# prints it with ref*print.
\#
.de ][
.nr ref*type \\$1
.if \\n[ref*type]=0 \{\
.   ie d [C \{\
.      if !d [I \{\
.         nr pre-1900 1 \" If pre-1900, MLA allows excluding publisher
.         nr ref*type 2
.      \}
.   \}
.   el .nr ref*type 2
.   if d [q .nr ref*type 2
.\}
.if \\n[ref*type]=3 \{\
.   if !'\\*([R'' \{\
.      nr ref*type 4
.      ds ref*spec!4 i Q A m p T2 B R O C I D P n
.   \}
.   if !'\\*([G'' \{\
.      nr ref*type 4
.      ds ref*spec!4 i A m p T2 B G O C I D P O n
.   \}
.\}
.if r [T \{\
.   als [T1 [T
.   als [T2 [T
.\}
.ie d ref*spec!\\n[ref*type] .ref*build \\*[ref*spec!\\n[ref*type]]
.el \{\
.   @error unknown reference type `\\n[ref*type]'
.   ref*build \\*[ref*spec!0]
.\}
.if !\\n[.hy]=0 \{\
.nr #RESTORE_HY \\n[.hy]
.if !r#REF_HY .nh
.\}
.ref*print
.if !\\n[#RESTORE_HY]=0 .hy \\n[#RESTORE_HY]
.rr #RESTORE_HY
.rm ref*string
.rm [F [T1 [T2
..
\#
\# Refer's "3rd" macros, which set up and terminate the output
\# of collected references
\#
.de ]<
.als ref*print ref*end-print
.nr #REF 1
.if \\n[#BIB_LIST]=1 \{\
.   nr #IN_BIB_LIST 1
.   LIST DIGIT \\*[$BIB_LIST_SEPARATOR] \\*[$BIB_LIST_PREFIX]
.\}
..
\#
.de ]>
.LIST OFF
.rr #REF
.rr #IN_BIB_LIST
.als ref*print ref*normal-print
..
\#
\# Output
\# ------
\#
\# Output normal, non-collected refs
\#
.de ref*normal-print
.nr #CURRENT_HY \\n[.hy]
\\*[ref*string]
..
\#
\# Output collected refs
\#
.de ref*end-print
.\" 10 is arbitrary
.nn 10
.nr #REF_BIB_INDENT (u;\\*[$REF_BIB_INDENT])
.ie \\n[#BIB_LIST]=0 \{\
.   in +\\n[#REF_BIB_INDENT]u
.   ti -\\n[#REF_BIB_INDENT]u
.\}
.el .ITEM
.\" Part of workaround for refer spitting out a blank page if the
.\" last ref falls on the bottom line.
\\*[ref*string]\R'ref*num*first-pass +1'\?\R'ref*num +1'\?
.sp \\n[#BIB_SPACE]u
.ie \\n[#BIB_LIST]=0 .in
.el .IL -\\n[#REF_BIB_INDENT]u
.nn 0
..
\#
.als ref*print ref*normal-print
\#
\# Build up the ref*string
\#
\# Correct MLA "typewritten" style (printstyle TYPEWRITE) demands
\# two spaces after each period.  The spaces are hardwired into the
\# string definitions (ref*add-<x>), so we have to make sure that there
\# aren't two spaces when the printstyle is TYPESET.  Since I find that
\# references look a bit crowded with 0 sentence space, I've bumped it
\# up to +4.  User's sentence spacing is reset in FOOTNOTES and ENDNOTES.
\#
.de ref*build
.if \\n[#PRINT_STYLE]=2 \{\
.   ds $RESTORE_SS_VAR \\*[$SS_VAR]
.   SS +8
.\}
.rm ref*string
.while \\n[.$] \{\
.   if d [\\$1 \{\
.      ie d ref*add-\\$1 .ref*add-\\$1
.      el .ref*add-dflt \\$1
.   \}
.   shift
.\}
.\" now add a final period
.ie d ref*string \{\
.   if !\\n[ref*suppress-period] .as ref*string .
.   if d ref*post-punct \{\
.      as ref*string "\\*[ref*post-punct]
.      rm ref*post-punct
.   \}
.\}
.el .ds ref*string
..
\#
\# The following macros determine how entries are formatted WRT
\# punctuation, type style, additional strings, etc.
\#
\# o First argument is the database field letter.
\# o Second argument is the punctuation character to use to separate this
\#   field from the previous field.
\# o Third argument is a string with which to prefix this field.
\# o Fourth argument is a string with which to postfix this field.
\# o Fifth argument is a string to add after the punctuation character
\#   supplied by the next field.
\#
\# %A Author(s)
.de ref*add-A
.ds eval*[A \\*([A
.substring eval*[A -1
.if '\\*[eval*[A]'.' \{\
.   if !'\\*[$REF_STYLE]'NOTE' .chop [A
.\}
.\" Per MLA, NOTE should not use idem, therefore if %i contains other than
.\" idem (eg. ed., trans.), transpose it to after author's name
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie !'\\*[idem]'' .ref*field A "" "" ", \\*[idem]"
.   el .ref*field A
.   rm idem
.el .ref*field A
.\}
.if \\n([A .nr ref*suppress-period 1
..
\# %i Idem.  BIBLIO: In all instances, removes %A field and replaces
\# it with a dash; if %i field contains other than the word, idem,
\# appends it to the dash
.de ref*add-i
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie '\\*([i'idem' .rm [i
.   el .ds idem \\*([i
.\}
.el \{\
.   ie '\\*([i'idem' \{\
.      rm [A
.      rm [i
.      ref*field i "" \[idem] "" " "
.   \}
.   el \{\
.      ds eval*[i \\*([i
.      substring eval*[i -1
.      if '\\*[eval*[i]'.' \{\
.         chop [i
.         ds idem \\*([i
.      \}
.      rm [i
.      rm [A
.      ref*field i "" \[idem] ", \\*[idem]" " "
.   \}
.\}
..
\# %m Multiple authors (et al.)
.de ref*add-m
.if !'\\*[$REF_STYLE]'NOTE' \{\
.   ds eval*[m \\*([m
.   substring eval*[m -1
.   if '\\*[eval*[m]'.' .chop [m
.\}
.ref*field m ,
..
\# %p Post-author string (eg. Preface, Foreword, etc)
.de ref*add-p
.\" Convert first letter to uppercase, per MLA, if BIBLIO
.if '\\*[$REF_STYLE]'BIBLIO' \{\
.   ds initial*cap \\*([p
.   substring initial*cap 0 0
.   ds [p*string \\*([p
.   substring [p*string 1
.   ds [p \E*[UC]\\*[initial*cap]\E*[LC]\\*[[p*string]
.\}
.ie '\\*[$REF_STYLE]'NOTE' .ref*field p ,
.el .ref*field p . " "
..
\# %Q Author(s) when author is not a person
.de ref*add-Q
.ie '\\*[$REF_STYLE]'NOTE' .ref*field Q
.el .ref*field Q
..
\# %T Title (generic)
.de ref*add-T1
.ie '\\*[$REF_STYLE]'NOTE' .ref*field T , \E*[IT] \E*[ref*restore-ss]
.el \{\
.   ie !'\\*([A'' .ref*field T . " \E*[IT]" \E*[ref*restore-ss]
.   el \{\
.      ie !'\\*([Q'' .ref*field T . " \E*[IT]" \E*[ref*restore-ss]
.      el .ref*field T . \E*[IT] \E*[ref*restore-ss]
.   \}
.\}
.if \\n([T .nr ref*suppress-period \\n([T
.
..
\# %T Title of a chapter or article
.de ref*add-T2
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ref*field T , \[lq] "" \[rq]
.\}
.el \{\
.   ie '\\*([A'' \{\
.      ref*field T . \[lq] "" \[rq]
.      if !'\\*([Q''.ref*field T . " \[lq]" "" \[rq]
.   \}
.   el .ref*field T . " \[lq]" "" \[rq]
.\}
.if \\n([T .nr ref*suppress-period \\n([T
..
\# %B Book title (when citing an article from a book)
.de ref*add-B
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie \\n([T .ref*field B "" \E*[IT] \E*[ref*restore-ss]
.   el .ref*field B , \E*[IT] \E*[ref*restore-ss]
.\}
.el \{\
.   ie \\n([T .ref*field B "" ".\E*[IT]" \E*[ref*restore-ss]
.   el .ref*field B . " \E*[IT]" \E*[ref*restore-ss]
.\}
\# refer doesn't set reg [T to 1 for these book titles, so we do it here
.ds eval*[B \\*([B
.substring eval*[B -1
.rr [T
.if '\\*[eval*[B]'!' .nr [T 1
.if '\\*[eval*[B]'?' .nr [T 1
.rm eval*[B
..
\# %q Titles that must go in quotes (e.g. an unpublished dissertation)
.de ref*add-q
.ie '\\*[$REF_STYLE]'NOTE' .ref*field q , \[lq] "" \[rq]
.el \{\
.   ie !'\\*([A'' .ref*field q . " \[lq]" "" \[rq]
.   el \{\
.      ie !'\\*([Q'' .ref*field q . " \[lq]" "" \[rq]
.      el .ref*field q . \[lq] "" \[rq]
.   \}
.\}
..
\# %R Report number for technical reports
.de ref*add-R
.ref*field R . " "
..
\# %J Journal name
.de ref*add-J
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie \\n([T .ref*field J "" "\E*[IT]" \E*[ref*restore-ss]
.   el .ref*field J , "\E*[IT]" \E*[ref*restore-ss]
.\}
.el \{\
.   ie \\n([T .ref*field J "" " \E*[IT]" \E*[ref*restore-ss]
.   el .ref*field J . " \E*[IT]" \E*[ref*restore-ss]
.\}
..
\# %M Magazine or newspaper name
.de ref*add-M
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie \\n([T .ref*field M "" "\E*[IT]" \E*[ref*restore-ss]
.   el .ref*field M , "\E*[IT]" \E*[ref*restore-ss]
.\}
.el \{\
.   ie \\n([T .ref*field M "" " \E*[IT]" \E*[ref*restore-ss]
.   el .ref*field M . " \E*[IT]" \E*[ref*restore-ss]
.\}
..
\# %E Editor(s)
.de ref*add-E
.ds eval*[E \\*([E
.substring eval*[E -1
.if '\\*[eval*[E]'.' \{\
.   if !\\n[#FN_REF]+\\n[#EN_REF] .chop [E
.   rm eval*[E
.\}
.\" Workaround for join-authors also joining editors.  MLA style
.\" requires a comma after first editor only if there are more than
.\" two, whereas join-authors always puts a comma after the first if
.\" there's more than one.
.rm eval*[E
.nr position 1 1
.nr counter 1 1
.while !'\\*[eval*[E]',' \{\
.   ds eval*[E \\*([E
.   substring eval*[E \\n+[position] \\n[position]
.   if \\n+[counter]>30 .break \" 30 is abitrary
.\}
.\" Check for " and"
.if '\\*[eval*[E]',' \{\
.   ds eval*[E \\*([E
.   nr and-check \\n[position]+4
.   substring eval*[E \\n+[position] \\n[and-check]
.\}
.if '\\*[eval*[E]' and' \{\
.   nr counter 1 1
.   nr start-range -1 1
.   nr end-range 3 1
.   while !'\\*[eval*[E]', and' \{\
.      ds eval*[E \\*([E
.      substring eval*[E \\n+[start-range] \\n+[end-range]
.      if \\n+[counter]>50 .break \" just in case; 50 is arbitrary
.   \}
.   if '\\*[eval*[E]', and' \{\
.      length len*[E \\*([E
.      nr rhs \\n[len*[E]-\\n[start-range]
.      ds lhs \\*([E
.      ds rhs \\*([E
.      substring lhs 0 \\n[start-range]-1
.      substring rhs -(\\n[rhs]-1)
.      ds [E \\*[lhs]\\*[rhs]
.   \}
.   rm lhs
.   rm rhs
.   rr and-check
.   rr counter
.   rr start-range
.   rr end-range
.   rr len*[E
.\}
.\" End workaround
.ie !\\n[ref*type]=0 \{\
.   ie \\n([E>0 \{\
.      ie '\\*[$REF_STYLE]'NOTE' \{\
.         ie \\n([T .ref*field E "" "ed. "
.         el .ref*field E , "ed. "
.      \}
.      el \{\
.         ie \\n([T .ref*field E "" " Eds. "
.         el .ref*field E . " Eds. "
.      \}
.   \}
.   el \{\
.      ie '\\*[$REF_STYLE]'NOTE' \{\
.         ie \\n([T .ref*field E "" "ed. "
.         el .ref*field E , "ed. "
.      \}
.      el \{\
.         ie \\n([T .ref*field E "" " Ed. "
.         el .ref*field E . " Ed. "
.      \}
.   \}
.\}
.el \{\
.   ie \\n([T .ref*field E "" " "
.   el .ref*field E . " "
.\}
.rr [T
.rr [E
..
\# %e Edition
.de ref*add-e
.ie \\n([T .ref*field e "" "" " ed."
.el \{\
.   ie '\\*[$REF_STYLE]'NOTE' .ref*field e , "" " ed."
.   el .ref*field e . " " " ed."
.\}
.nr ref*suppress-period 1
.nr [e 1
.rr [T
..
\# %V Volume (of a journal, or series of books); for journals, %N may be preferable
.de ref*add-V
.if \\n[ref*type]=1 \{\
.   ref*field V
.\}
.if \\n[ref*type]=2 \{\
.   ie '\\*[$REF_STYLE]'NOTE' .ref*field V , "vol. "
.   el \{\
.      ie \\n([T .ref*field V "" " Vol. "
.      el .ref*field V . " Vol. "
.   \}
.\}
.if \\n[ref*type]=3 \{\
.   ie \\n([T .ref*field V "" " "
.   el .ref*field V . " "
.\}
.rr [T
..
\# %N Journal number
.de ref*add-N
.ref*field N
..
\# %S Series (books or journals)
.de ref*add-S
.if \\n[ref*type]=1 \{\
.   ref*field S
.\}
.if \\n[ref*type]=2 \{\
.   ie '\\*[$REF_STYLE]'NOTE' \{\
.      ie \\n([T .ref*field S
.      el .ref*field S ,
.   \}
.   el \{\
.      ie \\n([T .ref*field S "" " "
.      el .ref*field S . " "
.   \}
.\}
.if \\n[ref*type]=3 \{\
.   ie \\n([T .ref*field S "" " "
.   el .ref*field S . " "
.\}
.rr [T
\# refer doesn't set reg [T to 1 for series titles, so we do it here
.ds eval*[S \\*([S
.substring eval*[S -1
.if '\\*[eval*[S]'!' .nr [T 1
.if '\\*[eval*[S]'?' .nr [T 1
.rm eval*[S
..
\# %C City
.de ref*add-C
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie r [d \{\
.      ref*field C
.      rr [d
.   \}
.   el \{\
.      ref*field C "" \*[FU 2](
.   \}
.   if \\n([T .nr ref*suppress-period \\n([T
.\}
.el \{\
.   ie \\n([T .ref*field C "" " "
.   el \{\
.      ie r [e .ref*field C "" " "
.      el .ref*field C . " "
.   \}
.\}
.rr [T
.rr [e
..
\# %I Publisher (I stands for Issuer)
.de ref*add-I
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie !'\\*([C'' .ref*field I :
.   el .ref*field I "" (
.\}
.el \{\
.   ie !'\\*([C'' .ref*field I :
.   el \{\
.      ie \\n([T .ref*field I "" " "
.      el .ref*field I . " "
.   \}
.\}
.rr [T
..
\# %D Date of publication
.de ref*add-D
.if \\n[ref*type]=0 \{\
.   ie '\\*[$REF_STYLE]'NOTE' .ref*field D ,
.   el .ref*field D . " "
.\}
.if \\n[ref*type]=1 \{\
.   ref*field D "" "(" ")"
.\}
.if \\n[ref*type]=2 \{\
.   ie '\\*[$REF_STYLE]'NOTE' .ref*field D , "" )
.   el .ref*field D ,
.\}
.if \\n[ref*type]=3 \{\
.   ie !'\\*([C'' \{\
.      ie '\\*[$REF_STYLE]'NOTE' .ref*field D , "" )
.      el .ref*field D ,
.   \}
.   el \{\
.      if '\\*([I'' \{\
.         ds eval*[D \\*([D
.         substring eval*[D 0 -4
.         ie '\\*[eval*[D]'1' .ds kern \*[BU3]
.         el .ds kern \*[BU2]
.         ie \\n[#PRINT_STYLE]=2 \{\
.           if '\\*[$REF_STYLE]'NOTE' .ref*field D "" (\\*[kern] )
.         \}
.         el .ref*field D
.      \}
.      rm eval*[D
.      rm kern
.   \}
.\}
.if \\n[ref*type]=4 .ref*field D ,
.if \\n[ref*type]=5 .ref*field D
.ds eval*[D \\*([D
.substring eval*[D -1
.if '\\*[eval*[D]'.' .nr ref*suppress-period 1
..
\# %P Page number(s)
.de ref*add-P
.if \\n[ref*type]=5 .nr ref*type 1
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie \\n[ref*type]=1 .ref*field P : "" .
.   el .ref*field P "" "\|"
.   if \\n[ref*type]=1 .nr ref*suppress-period 1
.\}
.el \{\
.   ie \\n[ref*type]=1 .ref*field P \|:
.   el \{\
.      ie d [n .ref*field P . \| .
.      el .ref*field P . " "
.   \}
.\}
..
\# %G Gov't. ordering number
.de ref*add-G
.ie '\\*[$REF_STYLE]'NOTE' ref*field G ,
.el .ref*field G . " "
..
\# %O Other (info that goes after %T [or %B] but is hard to categorize; eg a dissertation)
.de ref*add-O
.ds eval*[O \\*([O
.substring eval*[O -1
.if '\\*[eval*[O]'.' .nr [O 1
.ds initial*cap \\*([O
.substring initial*cap 0 0
.ds [O*string \\*([O
.substring [O*string 1
.if '\\*[$REF_STYLE]'BIBLIO' \{\
.   ds [O \E*[UC]\\*[initial*cap]\E*[LC]\\*[[O*string]
.\}
.ie '\\*[$REF_STYLE]'NOTE' .ref*field O ,
.el \{\
.   if \\n([O=1 .chop [O
.   ie r [e .ref*field O "" " "
.   el \{\
.      ie !d [A .ref*field O
.      el .ref*field O . " "
.   \}
.\}
.rr [O
.rr [e
..
\# %n Annotations (after ref)
.de ref*add-n
.ds eval*[n \\*([n
.substring eval*[n -1
.if '\\*[eval*[n]'.' .chop [n
.if '\\*[eval*[n]'?' .nr [n 1
.if '\\*[eval*[n]'!' .nr [n 1
.ie '\\*[$REF_STYLE]'NOTE' .ref*field n ,
.el \{\
.   ie !'\\*([P'' .ref*field n "" " "
.   el .ref*field n . " "
.\}
.if r [n .nr ref*suppress-period 1
.rr [n
..
\#
.de ref*add-dflt
.ref*field \\$1 ,
..
\#
\# Book reprints
\# -------------
\# %d date of publication (the orignal date of publication)
.de ref*add-d
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ref*field d "" ( ;
.   nr [d 1
.\}
.el \{\
.   ie \\n([T .ref*field d "" " "
.   el .ref*field d . " "
.\}
.rr [T
..
\# %b main author when citing from a preface, introduction, foreword
\# or afterword
.de ref*add-b
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie \\n([T .ref*field b "" "by"
.   el .ref*field b , "by "
.\}
.el \{\
.   ie \\n([T .ref*field b "" " By "
.   el .ref*field b . " By "
.\}
.rr [T
..
\# %t title, if different from original title (the T field, which s/b
\# the original title)
.de ref*add-t
.ie '\\*[$REF_STYLE]'NOTE' .ref*field t , "rpt. of \E*[IT] " \E*[ref*restore-ss]
.el \{\
.   ie \\n([T .ref*field t "" " Rpt. of \E*[IT] " \E*[ref*restore-ss]
.   el .ref*field t . " Rpt. of \E*[IT] " \E*[ref*restore-ss]
.\}
.rr [T
..
\#
\# Translated works
\# ----------------
\# %l Trans(l)ator
.de ref*add-l
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie \\n([T .ref*field l "" "trans. "
.   el .ref*field l , "trans. "
.\}
.el \{\
.   ie \\n([T .ref*field l "" " Trans. "
.   el .ref*field l . " Trans. "
.\}
.rr [T
..
\# %r Translato(r) and edito(r)
.de ref*add-r
.ie '\\*[$REF_STYLE]'NOTE' .ref*field r , "trans. and ed. "
.el \{\
.   ie \\n([T .ref*field r "" " Trans. and ed. "
.   el .ref*field r . " Trans. and ed. "
.\}
.rr [T
..
\#
\# Internet
\# --------
\# %s Site name
.de ref*add-s
.ie '\\*[$REF_STYLE]'NOTE' .ref*field s , \E*[IT] \E*[ref*restore-ss]
.el \{\
.ie \\n([s .ref*field s "" ".\E*[IT]" \E*[ref*restore-ss]
.el .ref*field s . " \E*[IT]" \E*[ref*restore-ss]
.\}
.\" refer doesn't set reg [T to 1 for these titles, so we do it here
.if !'\\*[$REF_STYLE]'NOTE' \{\
.   ds eval*[s \\*([s
.   substring eval*[s -1
.   rr [T
.   if '\\*[eval*[s]'.' .nr [T 1
.   if '\\*[eval*[s]'!' .nr [T 1
.   if '\\*[eval*[s]'?' .nr [T 1
.   rm eval*[s
.\}
..
\# %c content of site (ie. Web, Online posting, etc)
.de ref*add-c
.ie '\\*[$REF_STYLE]'NOTE' .ref*field c ,
.el \{\
.   ie \\n([T .ref*field c "" " "
.   el .ref*field c . " "
.\}
.rr [T
..
\# %o organization, group or sponsor of site
.de ref*add-o
.ie '\\*[$REF_STYLE]'NOTE' .ref*field o ,
.el \{\
.   ie \\n([T .ref*field o "" " "
.   el .ref*field o . " "
.\}
.rr [T
..
\# %a access date, i.e. the date you read it
.de ref*add-a
.ie '\\*[$REF_STYLE]'NOTE' .ref*field a ,
.el \{\
.   ie \\n([T .ref*field a "" " "
.   el .ref*field a . " "
.\}
.rr [T
..
\# %u URL
.de ref*add-u
.ref*field u "" < >
.rr [T
..
.de ref*add-z
.ref*field z
..
\#
\# Build up reference string from ref*add-<x> macros.
\#
\# First, a string to ensure next field's font is reset to roman
\# (TYPESET) or non-underlined (TYPEWRITE)
\#
.ie !n .ds ref*roman \f[R]\X'ps: exec decornone'\?\R'#UNDERLINE_ON 0'\?
.el .ds ref*roman \f[R]\?\R'#UNDERLINE_ON 0'\?
\#
.de ref*field
.if d ref*string \{\
.   ie d ref*post-punct \{\
.      as ref*string "\\$2\\*[ref*post-punct] \"
.      rm ref*post-punct
.   \}
.   el .as ref*string "\\$2 \"
.\}
.as ref*string "\\$3\\*([\\$1\\$4\E*[ref*roman]
.if \\n[.$]>4 .ds ref*post-punct "\\$5\E*[ref*roman]
.nr ref*suppress-period 0
..
\#
\# MARGIN NOTES
\# ------------
\#
\# Wrapper for MNinit.
\#
.MAC MN_INIT END
.    if \B'\\$2' \{\
.       tm1 "[mom]: 1.x-style \\$0 detected, but you are using v2.x.
.       tm1 "       v2.x requires flags before arguments to \\$0.
.       tm1 "       Please read docelement.html#mn-init and update your file.
.       ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.    \}
.    nr #ARGS  0 1
.    nr #COUNT 9
.    while \\n+[#ARGS]<=\\n[#COUNT] \{\
.      ds $MN-arg\\n[#ARGS] @
.    \}
.    nr #FLAG 0 1
.    nr #COUNT \\n[#NUM_ARGS]
.    while \\n+[#FLAG]<=\\n[#COUNT] \{\
.       if '\\$1'RAGGED' \{\
.          ds $MN-arg1 \\$1
.       shift
.       \}
.       if '\\$1'SYMMETRIC' \{\
.          ds $MN-arg1 \\$1
.          shift
.       \}
.       if '\\$1'L_WIDTH' \{\
.          shift
.          ds $MN-arg2 \\$1
.          shift
.       \}
.       if '\\$1'R_WIDTH' \{\
.          shift
.          ds $MN-arg3 \\$1
.          shift
.       \}
.       if '\\$1'GUTTER' \{\
.          shift
.          ds $MN-arg4 \\$1
.          shift
.       \}
.       if '\\$1'FONTSTYLE' \{\
.          shift
.          ds $MN-arg5 \\$1
.          shift
.       \}
.       if '\\$1'SIZE' \{\
.          shift
.          ds $MN-arg6 \\$1
.          shift
.       \}
.       if '\\$1'LEAD' \{\
.          shift
.          ds $MN-arg7 \\$1
.          shift
.       \}
.       if '\\$1'COLOR' \{\
.          shift
.          ds $MN-arg8 \\$1
.          shift
.       \}
.       if '\\$1'HY' \{\
.          shift
.          ds $MN-arg9 \\$1
.          shift
.       \}
.    \}
.    if '\\*[$MN-arg5]'@' .ds $MN-arg5 \E*[$DOC_FAM]R
.    MNinit \
\\*[$MN-arg1] \\*[$MN-arg2] \
\\*[$MN-arg3] \\*[$MN-arg4] \
\\*[$MN-arg5] \\*[$MN-arg6] \
\\*[$MN-arg7] \\*[$MN-arg8] \
\\*[$MN-arg9]
.END
\#
.MAC MN_OVERFLOW_TRAP END
.    if \\n[#OVERFLOW_LEFT]=1 \{\
.       nr #no-repeat-MN-left 1
.       di MN_OVERFLOW_LEFT
.    \}
.    if \\n[#OVERFLOW_RIGHT]=1 \{\
.       nr #no-repeat-MN-right 1
.       di MN_OVERFLOW_RIGHT
.    \}
.    rr #OVERFLOW_LEFT
.    rr #OVERFLOW_RIGHT
.END
\#
\# The remainder of the margin notes macros and routines are adapted
\# from Werner Lemberg's MN.tmac.
\#
\# MNinit
\# ------
\# Usage:
\# MNinit [ragged|symmetric] \
\#        left-width right-width separation \
\#        font fontsize vertical-spacing \
\#        color hyphenation-flags
\#
\# Initialize margin notes.  Empty arguments (denoted with "") set
\# default values.  If the first argument is the string `ragged',
\# left and right margin notes are printed ragged-right.  If it is
\# `symmetric', left margin notes are printed ragged-left and right
\# margin notes ragged-right.  If omitted, margin notes are left
\# and right adjusted.
\#
.de MNinit
.  nr #MNinit 1
.  ds MN-left-ad b\"
.  ds MN-right-ad b\"
.  if '\\$1'@' .shift
.  if '\\$1'RAGGED' \{\
.    ds MN-left-ad l\"
.    ds MN-right-ad l\"
.    shift
.  \}
.  if '\\$1'SYMMETRIC' \{\
.    ds MN-left-ad r\"
.    ds MN-right-ad l\"
.    shift
.  \}
.  ie \B'\\$3' .nr MN-sep (n;\\$3)
.  el .nr MN-sep 1m
.  if ((\\n[.o] - \\n[MN-sep]) < 1n) \
.    ab MN: Left margin too small (<1n) for requested margin notes separation.
.  ie \B'\\$1' \{\
.    nr MN-left-width (n;\\$1)
.    nr MN-left-start (\\n[.o] - \\n[MN-sep] - \\n[MN-left-width])
.  \}
.  el \{\
.    nr MN-left-width (\\n[.o] - \\n[MN-sep])
.    nr MN-left-start 0
.  \}
.  if (\\n[MN-left-start] < 0) \
.    ab MN: Left margin too small for requested margin notes settings.
.  if (\\n[MN-left-width] < 1n) \
.    ab MN: Left margin notes width too small (<1n).
.  ie \B'\\$2' \{\
.    nr MN-right-width (n;\\$2)
.    nr MN-right-start (\\n[.o] + \\n[.l] + \\n[MN-sep])
.    if \\n[#COLUMNS]=1 \{\
.      if !\\n[#NUM_COLS]=1 \{\
.        nr MN-right-start (\\n[#COL_2_L_MARGIN] + \\n[#COL_L_LENGTH] + \\n[MN-sep])
.      \}
.    \}
.  \}
.  el \{\
.    nr MN-right-width \\n[MN-left-width]
.    nr MN-right-start (\\n[.o] + \\n[.l] + \\n[MN-sep])
.    if \\n[#COLUMNS]=1 \{\
.      if !\\n[#NUM_COLS]=1 \{\
.        nr MN-right-start (\\n[#COL_2_L_MARGIN] + \\n[#COL_L_LENGTH] + \\n[MN-sep])
.      \}
.    \}
.  \}
.  ie \A'\\$4' \{\
.    ds MN-font \\$4\"
.    if \\n[#PRINT_STYLE]=1 .ds MN-font CR
.  \}
.  el \{\
.    ds MN-font \\*[$PP_FT]
.    if \\n[#PRINT_STYLE]=1 .ds MN-font CR
.  \}
.  ie \B'\\$5' \{\
.    ps \\$5
.    nr MN-size \\n[.ps]
.    ps
.    if \\n[#PRINT_STYLE]=1 \{\
.       ps \\*[$TYPEWRITER_PS]
.       nr MN-size \\n[.ps]
.       ps
.    \}
.  \}
.  el \
.    nr MN-size \\n[#DOC_PT_SIZE]
.  ie \B'\\$6' \{\
'    vs \\$6
.    nr MN-spacing \\n[.v]
'    vs
.    if \\n[#PRINT_STYLE]=1 \
.       nr MN-spacing \\n[#DOC_LEAD]
.  \}
.  el .nr MN-spacing \\n[#DOC_LEAD]
.  ie \A'\\$7' \
.    if !\\n[#PRINT_STYLE]=1 .ds MN-color \\$7\"
.  el \
.    if !\\n[#PRINT_STYLE]=1 .ds MN-color
.  ie \B'\\$8' .nr MN-hy \\$8
.  el .nr MN-hy \\n[.hy]
.  ev MNbottom-left-env
.  if \A'\\*[MN-font]' .ft \\*[MN-font]
.  if \\n[MN-size] .ps \\n[MN-size]u
.  if \\n[MN-spacing] .vs \\n[MN-spacing]u
.  ll \\n[MN-left-width]u
.  ad \\*[MN-left-ad]
.  hy \\n[MN-hy]
'  in 0
.  nop \m[\\*[MN-color]]\c
.  ev
.  ev MNbottom-right-env
.  if \A'\\*[MN-font]' .ft \\*[MN-font]
.  if \\n[MN-size] .ps \\n[MN-size]u
.  if \\n[MN-spacing] .vs \\n[MN-spacing]u
.  ll \\n[MN-right-width]u
.  ad \\*[MN-right-ad]
.  hy \\n[MN-hy]
'  in 0
.  nop \m[\\*[MN-color]]\c
.  ev
.  nr MN-active 0
..
\# MN
\# --
\# Usage:
\#
\#   MN LEFT|RIGHT
\#   margin note text
\#   MN
\#
\# With a parameter, start a margin note, otherwise end a margin note.
\# If the parameter is the string `left', define a left margin note,
\# otherwise define a right margin note.
\#
.de MN
.ds MN-dir \\$1
.if !'\\$1'LEFT' \{\
.  if !'\\$1'RIGHT' \{\
.    MN_QUIT
.    return
.  \}
.\}
.if \\n[#COLUMNS]=1 \{\
.  if \\n[#NUM_COLS]>2 \{\
.    tm [mom]: Macro MN: More than two columns.  Ignoring margin notes.
.    return
.  \}
.  if !\\n[#NUM_COLS]=1 \{\
.    ie \\n[#COL_NUM]=1 .ds MN-dir LEFT
.    el .ds MN-dir RIGHT
.  \}
.\}
.  if !\\n[#MNinit]=1 \{\
.    tm [mom]: Macro MN: You must set parameters with MN_INIT before using MN.
.    ab Aborting '\\n[.F]' at MN, line \\n[.c].
.  \}
.  ie !'\\$1'' \{\
.    if \\n[MN-active] \{\
.      tm [mom]: Macro MN: Can't handle nested margin notes, line \\n[.c].
.      return
.    \}
.    nr MN-active 1
.    ev MN-env
.    ie '\\*[MN-dir]'LEFT' \{\
.      nr MN-left +1
.      ds MN-curr l-\\n[MN-left]\"
.      evc MNbottom-left-env
.    \}
.    el \{\
.      nr MN-right +1
.      ds MN-curr r-\\n[MN-right]\"
.      evc MNbottom-right-env
.    \}
.    mk MN-mk-\\*[MN-curr]
.    di MN-div-\\*[MN-curr]
.  \}
.  el .MN_QUIT
..
\#
\# MN_QUIT
\# -------
\# Utility macro to handle .MN OFF | QUIT | X etc
\#
.de MN_QUIT
.   if \\n[MN-active] \{\
.      br
.      di
.      nr MN-div-\\*[MN-curr]-depth \\n[dn]
.      ev
.   \}
.   nr MN-active 0
..
\#
\# MNtop
\# -----
\# Resets these registers (called in HEADER)
.de MNtop
.  nr MN-left 0
.  nr MN-right 0
.  nr MN-active 0
.  rr MN-shifted
.  ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
..
\#
\# MNbottom-left
\# -------------
\# The "left" half of Werner's original MNbottom.
\#
.de MNbottom-left
.  nr MN-curr 0
.  nr MN-last-pos 0
.  nr MN-lead-adj \\n[#DOC_LEAD]-\\n[MN-spacing]
.  vpt 0
.  mk MN-curr-pos
.  if \\n[MN-active] \{\
.    di
.    tm [mom]: Macro MN: Margin note finished by new page.  Ignored.
.  \}
.  po \\n[MN-left-start]u
.  ev MNbottom-left-env
.  nr #P \\n%+\\n[#PAGE_NUM_ADJ]
.  while (\\n[MN-curr] < \\n[MN-left]) \{\
.    nr MN-curr +1
.    ie (\\n[MN-last-pos] < \\n[MN-mk-l-\\n[MN-curr]]) \
.      sp |\\n[MN-mk-l-\\n[MN-curr]]u+\\n[MN-lead-adj]u
.    el \{\
.      nr MN-shifted 1
.      sp 1v
.      SHIM
.      if \\n[#SHIM]>\\n[MN-spacing] .sp -(1v+\\n[MN-lead-adj]u)
.      tm \
[mom]: Macro MN: Warning: Left margin note #\\n[MN-curr] on page \\n[#P] shifted down.
.    \}
.\" If last margin note doesn't fit
.    if ( (\\n[nl]+\\n[MN-div-l-\\n[MN-curr]-depth]) > (\\n[.p]+\\n[#VARIABLE_FOOTER_POS]-1) ) \{\
.      if \\n[MN-shifted]=1 \{\
.        sp -(1v+\\n[#SHIM]u)
.        rm MN-div-l-\\n[MN-curr]
.        tm1 "[mom]: No room to start left margin note #\\n[MN-curr] on page \\n[#P].
.        tm1 "       Ignoring margin note.
.        rr MN-shifted
.      \}
.      nr #no-repeat-MN-left 1
.      nr #OVERFLOW_LEFT 1
.      ie \\n[#FN_COUNT]=0 \{\
.        ch FOOTER \\n[.p]u
.        wh \\n[#VARIABLE_FOOTER_POS]u+\\n[MN-lead-adj]u+1u MN_OVERFLOW_TRAP
.      \}
.      el \
.        wh \\n[.p]u+\\n[#VARIABLE_FOOTER_POS]u-1u MN_OVERFLOW_TRAP
.      vpt 1
.    \}
.    nf
.    MN-div-l-\\n[MN-curr]
.    fi
.    br
.    nr MN-last-pos \\n[nl]
.  \}
.  ev
.  po
.  if !\\n[#no-repeat-MN-left]=1 \
.     if \\n[MN-right]=0 .vpt 1
..
\#
\# MNbottom-right
\# --------------
\# The "right" half of Werner's original MNbottom.
\#
.de MNbottom-right
.   nr MN-curr 0
.   nr MN-last-pos 0
.   nr MN-lead-adj \\n[#DOC_LEAD]-\\n[MN-spacing]
.   vpt 0
.   po \\n[MN-right-start]u
.   ev MNbottom-right-env
.   nr #P \\n%+\\n[#PAGE_NUM_ADJ]
.   while (\\n[MN-curr] < \\n[MN-right]) \{\
.      nr MN-curr +1
.      ie (\\n[MN-last-pos] < \\n[MN-mk-r-\\n[MN-curr]]) \
.         sp |\\n[MN-mk-r-\\n[MN-curr]]u+\\n[MN-lead-adj]u
.      el \{\
.         nr MN-shifted 1
.         sp 1v
.         SHIM
.         if \\n[#SHIM]>\\n[MN-spacing] .sp -(1v+\\n[MN-lead-adj]u)
.         tm [mom]: \
Macro MN: Warning: Right margin note #\\n[MN-curr] on page \\n[#P] shifted down.
.      \}
.\" If last margin note doesn't fit
.      if ( (\\n[nl]+\\n[MN-div-r-\\n[MN-curr]-depth]) > (\\n[.p]+\\n[#VARIABLE_FOOTER_POS]-1) ) \{\
.         if \\n[MN-shifted]=1 \{\
.            sp -(1v+\\n[#SHIM]u)
.            rm MN-div-r-\\n[MN-curr]
.            tm1 \
[mom]: No room to start right margin note #\\n[MN-curr] on page \\n[#P] on page \\n[#P].
.            tm1 "       Ignoring margin note.
.            rr MN-shifted
.         \}
.         nr #no-repeat-MN-right 1
.         nr #OVERFLOW_RIGHT 1
.         ie \\n[#FN_COUNT]=0 \{\
.            ch FOOTER \\n[.p]u
.            wh \\n[#VARIABLE_FOOTER_POS]u+\\n[MN-lead-adj]u+1u MN_OVERFLOW_TRAP
.         \}
.         el \
.            wh \\n[.p]u+\\n[#VARIABLE_FOOTER_POS]u-1u MN_OVERFLOW_TRAP
.         vpt 1
.      \}
.      nf
.      MN-div-r-\\n[MN-curr]
.      fi
.      br
.      nr MN-last-pos \\n[nl]
.   \}
.   ev
.   po
.   if !\\n[#no-repeat-MN-right]=1 .vpt 1
..
\#
\# PDF SUPPORT
\# ===========
\#
\# Initial setup
\#
.nr CURRENT_LEVEL 0
.nr VIRTUAL_LEVEL 0
.nr #PDF_BOOKMARKS 1
.nr #PDF_BOOKMARKS_OPEN 1
.pdfview /PageMode /UseOutlines
\#
\# TOC_BEFORE_HERE
\# ---------------
\#
\# Call this and the TOC will be placed preceding this page
\#
.MAC TOC_BEFORE_HERE END
.    nr TOC_BH 1
.    pdfpagename MOM:TOC
.END
\#
\# TOC_AFTER_HERE
\# ---------------
\#
\# Call this and the TOC will be placed after this page
\#
.MAC TOC_AFTER_HERE END
.    nr TOC_BH 2
.    pdfpagename MOM:TOC
.END
\#
\# PDF_LINK_COLOR
\# -----------------
\#
\# Arguments:-
\#   <name defined by previous call to XCOLOR or NEWCOLOR> or
\#   <red> <green> <blue> all 0.0 -> 1.0
\# Notes
\#   Should be called before START but can also be called at any time to change colour
\#   The colour assigned at the end of the document is used for all links in the TOC
\#
.MAC PDF_LINK_COLOR END
.    ie \\n[.$]==3 \{\
.       ds PDFHREF.COLOUR \\$*
.       if !(\B'\\$1' & \B'\\$2' & \B'\\$3') \{\
.          tm1 "[mom]: All three arguments to \\$0 at line \\n[.c] must be decimal.
.          tm1 "       Continuing to process using default link color.
.          ds PDFHREF.COLOUR 0.0 0.3 0.9
.       \}
.       defcolor pdf:href.colour rgb \\*[PDFHREF.COLOUR]
.       ds PDFHREF.TEXT.COLOUR pdf:href.colour
.    \}
.    el \{\
.       ie \\n[.$]==0 \{\
.          if dPDFHREF.TEXTCOL.DEFAULT \
.             PDF_LINK_COLOR \\*[PDFHREF.TEXTCOL.DEFAULT]
.       \}
.       el \{\
.          ds ARG_1 \\$1
.          substring ARG_1 0 0
.          ie '\\*[ARG_1]'#' \{\
.             defcolor pdf:href.colour rgb \\$1
.             ds PDFHREF.TEXT.COLOUR pdf:href.colour
.          \}
.          el \{\
.             ie dCOLAL_\\$1 .ds PDFHREF.TEXT.COLOUR \\*[COLAL_\\$1]
.             el .ds PDFHREF.TEXT.COLOUR \\$1
.          \}
.       \}
.    \}
.    if !\\n[PDFHREF_COLOR_SET]=1 \{\
.       nr PDFHREF_COLOR_SET 1
.    \}
.END
\#
\# AUTO_RELOCATE_TOC
\# -----------------
\#
\# Call before START to have TOC automatically relocated to after the
\# DOC COVER (if there is one) or the COVER if there isn't
\#
.MAC AUTO_RELOCATE_TOC END
.    if '\\$1''                .nr TOC.RELOCATE 1
.    if '\\$1'TOP'             .nr TOC.RELOCATE 2
.    if '\\$1'BEFORE_DOCCOVER' .nr TOC.RELOCATE 3 \" Same as TOP unless no DOCCOVER
.    if '\\$1'AFTER_DOCCOVER'  .nr TOC.RELOCATE 4
.    if '\\$1'BEFORE_COVER'    .nr TOC.RELOCATE 5
.    if '\\$1'AFTER_COVER'     .nr TOC.RELOCATE 6
.END
\#
\# PDF_BOOKMARK
\# ------------
\# *Argument:
\#   Hierarchy Level
\#   Bookmark Text
\# *Function:
\#   Creates a bookmark using the given text
\#   The level controls the hierarchy of the bookmarks
\# *Notes
\#   Bookmarks can be turned off (will not be added to document outline) by calling
\#   "PDF_BOOKMARKS NO" and turned on with "PDF_BOOKMARKS".
\#
\#   Bookmarks can be open or closed by calling PDF_BOOKMARKS_OPEN
\#
.MAC PDF_BOOKMARK END
.    if \\n[#PDF_BOOKMARKS] \{\
.       ie '\\$1'NAMED' \{\
.          ds PDF_NM -T \\$2
.          ds PDF_NM2 \\$2
.          shift 2
.       \}
.       el .ds PDF_NM
.       nr LEVEL_REQ \\$1
.       shift
.       ie \\n[LEVEL_REQ]>\\n[VIRTUAL_LEVEL] \{\
.          nr VIRTUAL_LEVEL \\n[LEVEL_REQ]
.          nr LEVEL_REQ \\n[CURRENT_LEVEL]+1
.       \}
.       el \{\
.          ie \\n[LEVEL_REQ]<\\n[VIRTUAL_LEVEL] \{\
.             nr VIRTUAL_DIFF \\n[VIRTUAL_LEVEL]-\\n[LEVEL_REQ]
.             nr VIRTUAL_LEVEL \\n[LEVEL_REQ]
.             nr LEVEL_REQ (\\n[CURRENT_LEVEL]-\\n[VIRTUAL_DIFF])>?1
.          \}
.          el .nr LEVEL_REQ \\n[CURRENT_LEVEL]
.       \}
.       ds PDF_TX \\$*
.       pdfmomclean PDF_TX
.\" .   ev protect
.       nr PDF_LEV (\\n[LEVEL_REQ]*\\n[#PDF_BOOKMARKS_OPEN])
.       ie '\\*[.T]'ps' \{\
.           if !'\\*[PDF_NM]'' \{\
.              pdfhref M -N \\*[PDF_NM2] -- \\*[PDF_TX]
.              if !dpdf:href.map .tm gropdf-info:href \\*[PDF_NM2] \\*[PDF_TX]
.           \}
.           pdfbookmark \\n[PDF_LEV] \\*[PDF_TX]
.       \}
.       el .pdfbookmark \\*[PDF_NM] \\n[PDF_LEV] \\$*
.\" .   ev
.       nr CURRENT_LEVEL \\n[LEVEL_REQ]
.       rr LEVEL_REQ
.       rr PDF_LEV
.       rr VIRTUAL_DIFF
.       rm PDF_NM
.    \}
.END
\#
\# PDF_TITLE
\# ---------
\# *Argument:
\#   Title Text
\# *Function
\#   Set the PDF title (this is often used by PDF readers to title the main window)
\#
.MAC PDF_TITLE END
.    ds pdftitle \\$*
.    pdfmomclean pdftitle
.    nop \!x X ps:exec [/Title (\\*[pdftitle]) /DOCINFO pdfmark
.END
\#
\# PDF_BOOKMARKS
\# -------------
\# *Argument:
\#   <nothing> | <anything>
\# *Function:
\#   With no parameter turns on outline bookmarks
\#   With any parameter turns off outline bookmarks
\#
.MAC PDF_BOOKMARKS END
.    ie '\\$1'' .nr #PDF_BOOKMARKS 1
.    el .nr #PDF_BOOKMARKS 0
.END
\#
\# PDF_BOOKMARKS_OPEN
\# ------------------
\# *Argument:
\#   <number> | <nothing> | <text>
\# *Function:
\#   If arg is numeric all Bookmark levels > arg are closed
\#   If arg is empty all bookmarks are open
\#   If arg is any text then any following bookmarks are closed
\#
.MAC PDF_BOOKMARKS_OPEN END
.    ie \B'\\$1' \{\
.       nr PDFOUTLINE.FOLDLEVEL \\$1
.       nr #PDF_BOOKMARKS_OPEN 1
.    \}
.    el .if '\\*[.T]'pdf' \{\
.       nr PDFOUTLINE.FOLDLEVEL 10000
.       ie '\\$1'' .nr #PDF_BOOKMARKS_OPEN 1
.       el .nr #PDF_BOOKMARKS_OPEN 0-1
.    \}
.END
\#
\# PDF_LINK
\# --------
\# *Arguments:
\#    $1 = named link
\#    [PREFIX text] : text to prefix link
\#    [SUFFIX text] : text after link
\#    text
\#
\# *Notes
\#    Text is output as a hotspot link to named destination.
\#    If text has final '*' it is replaced with the text associated with the link
\#
.MAC PDF_LINK END
.    ds PDF_NM \\$1
.    shift
.    ie '\\$1'PREFIX' \{\
.       ds PDF_PRE -P "\&\\$2"
.       shift 2
.    \}
.    el .ds PDF_PRE
.    ie '\\$1'SUFFIX' \{\
.       ds PDF_POST -A "\\$2"
.       shift 2
.    \}
.    el .ds PDF_POST
.    ds PDF_AST_Q
.    ds PDF_TXT \&\\$1
.    ds PDF_AST \\*[PDF_TXT]
.    substring PDF_AST -1 -1
.    if '\\*[PDF_AST]'+' \{\
.       ds PDF_AST *
.       ds PDF_AST_Q ""
.    \}
.    if '\\*[PDF_AST]'*' \{\
.        chop PDF_TXT
.        ie '\\*[.T]'pdf' \{\
.           ie d pdf:look(\\*[PDF_NM]) \
.               as PDF_TXT \&\\*[PDF_AST_Q]\\*[pdf:look(\\*[PDF_NM])]\\*[PDF_AST_Q]
.           el \{\
.               as PDF_TXT Unknown
.               if !rPDF_UNKNOWN .tm \
\\n[.F]:\\n[.c]: forward reference detected (please run using 'pdfmom')
.               nr PDF_UNKNOWN 1
.           \}
.        \}
.        el \{\
.            ie d pdf:href(\\*[PDF_NM]).info \
.               as PDF_TXT \&\\*[PDF_AST_Q]\\*[pdf:href(\\*[PDF_NM]).info]\\*[PDF_AST_Q]
.            el .as PDF_TXT Unknown
.       \}
.    \}
.    pdfhref L \\*[PDF_PRE] \\*[PDF_POST] -D \\*[PDF_NM] -- \\*[PDF_TXT]
.    rm PDF_NM
.    rm PDF_PRE
.    rm PDF_POST
.    rm PDF_TXT
.    rm PDF_AST
.    rm PDF_AST_Q
.END
\#
.MAC PDF_WWW_LINK END
.    ds PDF_NM \\$1
.    shift
.    ie '\\$1'PREFIX' \{\
.       ds PDF_PRE -P "\\$2"
.       shift 2
.    \}
.    el .ds PDF_PRE
.    ie '\\$1'SUFFIX' \{\
.       ds PDF_POST -A "\\$2"
.       shift 2
.    \}
.    el .ds PDF_POST
.    ds PDF_AST_Q
.    ds PDF_TXT \\$1
.    ie !'\\*[PDF_TXT]'' \{\
.       ds PDF_AST \\*[PDF_TXT]
.       substring PDF_AST -1 -1
.       if '\\*[PDF_AST]'+' \{\
.          ds PDF_AST *
.          ds PDF_AST_Q ""
.       \}
.       if '\\*[PDF_AST]'*' \{\
.          chop PDF_TXT
.          as PDF_TXT \&\\*[PDF_AST_Q]\\*[PDF_NM]\\*[PDF_AST_Q]
.       \}
.    \}
.    el .ds PDF_TXT \\*[PDF_NM]
.    pdfhref W -D "\\*[PDF_NM]" \\*[PDF_PRE] \\*[PDF_POST] -- \\*[PDF_TXT]
.    rm PDF_NM
.    rm PDF_PRE
.    rm PDF_POST
.    rm PDF_TXT
.    rm PDF_AST PDF_AST_Q
.END
\#
.MAC PDF_TARGET END
.    ds ARG_1 \\$1
.    shift
.    pdfhref M -N \\*[ARG_1] -- \\$*
.    if '\\*[.T]'ps' .if !dpdf:href.map .tm gropdf-info:href \\*[ARG_1] \\$*
.END
\#
\# PDF_IMAGE
\# ---------
\# *Arguments:
\#   [ -L -| -R | -C | -I <indent> ] \
\#     <image file> <width> <height> \
\#     [ SCALE <factor> ] [ ADJUST +|-<vertical shift> ]
\# *Function:
\#   Allows embedding of PDF images with the same arguments as PSPIC
\#   plus SCALE and ADJUST options.
\# *Notes:
\#   <image file> <width> <height> are required.
\#
.MAC PDF_IMAGE END
.    rr float*img
.    if !'\\n[.z]'FLOAT*DIV' .FLOAT
.    nr float*img 1
.    ds ev-current \\n[.ev]
.    ev IMG
.    evc \\*[ev-current]
.    if \\n[#HYPHENATE] .nh
.    nr ind-pre-img \\n[.i]
.    nr ll-pre-img  \\n[.l]
.    in 0
.    ds pos:tmp \\$1
.    substring pos:tmp 0 0
.    ie !'\\*[pos:tmp]'-' .ds pdf-img:pos -C
.    el \{\
.       ds pdf-img:pos \\$1
.       shift
.    \}
.    if '\\*[pdf-img:pos]'-I' \{\
.       nr pdf-img:ind \\$1
.       shift
.    \}
.    ds pdf-img:file \\$1
.    ds pdf-img@file \\$1
.    substring pdf-img@file -1 -3
.    if !'\\*[pdf-img@file]'pdf' \{\
.       tm1 "[mom]: Image file '\\*[pdf-img:file]' at line \\n[.c] not found, or not a PDF image.
.       ab Aborting '\\n[.F]' at \\$0, line \\n[.c].
.    \}
.    nr pdf-img:width \\$2
.    nr pdf-img:depth \\$3
.    shift 3
.    nr loop-counter \\n[#NUM_ARGS]
.    nr loop-count 0 1
.    while \\n+[loop-count]<=\\n[loop-counter] \{\
.       if '\\$1'SCALE' \{\
.          shift
.          nr pdf-img:scale \\$1
.          shift
.          nr pdf-img:width \\n[pdf-img:width]*\\n[pdf-img:scale]/100
.          nr pdf-img:depth \\n[pdf-img:depth]*\\n[pdf-img:scale]/100
.       \}
.       if '\\$1'ADJUST' \{\
.         shift
.         ds pdf-img:adj \\$1
.         shift
.       \}
.       if '\\$1'FRAME' \{\
.          nr pdf-img:frame 1
.          if !r pdf-img:frame-inset .nr pdf-img:frame-inset 6p
.          shift
.       \}
.       if '\\$1'CAPTION' \{\
.          nr pdf-img*have-caption 1
.          ds pdf-img*caption \\$2
.          shift 2
.       \}
.       if '\\$1'SHORT_CAPTION' \{\
.          ds pdf-img*caption-short \\$2
.          shift 2
.       \}
.       if '\\$1'LABEL' \{\
.          nr pdf-img*have-label 1
.          ds pdf-img*label \\$2
.          ds label-type pdf-img
.          shift 2
.       \}
.       if '\\$1'NO_SHIM' \{\
.          nr float*no-shim 1
.       \}
.    \}
.    ds pdf-img*label-sffx-tmp \\*[pdf-img*label-sffx]
.    substring pdf-img*label-sffx-tmp -1
.    if '\\*[pdf-img*label-sffx-tmp]'.' \
.       if \\n[pdf-img*caption-after-label]=0 .chop pdf-img*label-sffx
.    PDF_TARGET fig:\\n+[lists*target]
.    if '\\*[pdf-img:pos]'-C' \
.       nr pdf-img:ind (\\n[.ll]-\\n[ind-pre-img]-\\n[pdf-img:width])/2
.    if '\\*[pdf-img:pos]'-R' \{\
.       nr pdf-img:ind \\n[.ll]-\\n[pdf-img:width]-\\n[ind-pre-img]
.    \}
.    di PDF*IMAGE
.    if \\n[@TOP] \{\
.       ch RR_@TOP
.       rs
.       nop \&
.       sp -1v
.    \}
.    if \\n[pdf-img*have-caption] \{\
.       if !\\n[pdf-img*autolabel] \{\
.          if !\\n[pdf-img*have-label] \{\
.             if \\n[#MLA] \
.                mla@error caption label \\n[.F] \\$0 \\n[.c]
.          \}
.       \}
.       if !\\n[pdf-img*caption-after-label] \{\
.          if !\\n[@TOP] .sp .5v
.          nr lead-pre-caption \\n[.v]
.          ev caption
.          evc IMG
.          ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.          el \{\
.             img*caption-style
.             vs \\n[.ps]u+\\n[pdf-img*caption-autolead]u
.          \}
.          PDF_IMG*SET_CAPTION_QUAD \\*[pdf-img*caption-quad]
.          sp \\n[lead-pre-caption]u-\\n[.v]u
.          nop \\*[pdf-img*caption]
.          br
.          if !'\\*[pdf-img*caption-space]'' .sp \\*[pdf-img*caption-space]
.          ev
.          in 0
.          sp -.5v
.       \}
.    \}
.    nf
.    if \\n[pdf-img:frame] \{\
.       nr frame-width \\n[pdf-img:width]+(\\n[pdf-img:frame-inset]*2)
.       nr frame-depth \\n[pdf-img:depth]+(\\n[pdf-img:frame-inset]*2)
.       if '\\*[pdf-img:pos]'-L' \{\
.          nr pdf-img:ind \\n[pdf-img:frame-inset]
.          nr pdf-img:dbx-ind 0
.       \}
.       if '\\*[pdf-img:pos]'-C' \{\
.          nr pdf-img:dbx-ind \
\\n[.ll]-\\n[ind-pre-img]-\\n[pdf-img:width]/2-\\n[pdf-img:frame-inset]
.       \}
.       if '\\*[pdf-img:pos]'-R' \{\
.          nr pdf-img:ind -\\n[pdf-img:frame-inset]
.          nr pdf-img:dbx-ind \
\\n[.l]u-(\\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u)+\\n[ind-pre-img]u)
.       \}
.       if '\\*[pdf-img:pos]'-I' \{\
.          nr pdf-img:ind +\\n[pdf-img:frame-inset]
.          nr pdf-img:dbx-ind \\n[pdf-img:ind]-\\n[pdf-img:frame-inset]
.       \}
.       DBX \\*[pdf-img:frame-weight] \
            \\n[pdf-img:dbx-ind]u \
            \\n[frame-width]u \
            \\n[frame-depth]u \
            \\*[pdf-img:frame-color]
.       sp \\n[pdf-img:frame-inset]u
.       nr pdf-img:ind -\\n[pdf-img:frame-inset]
.    \}
.    ti \\n[pdf-img:ind]u+\\n[pdf-img:frame-inset]u
.    nop \X'pdf: pdfpic \\*[pdf-img:file] -L \\n[pdf-img:width]z \\n[pdf-img:depth]z'
.    if '\\*[pdf-img:pos]'-C' .nr pdf-img:ind +\\n[pdf-img:frame-inset]
.    sp \\n[pdf-img:depth]u
.    if \\n[pdf-img:frame] .sp \\n[pdf-img:frame-inset]u
.    if (\\n[pdf-img*have-label]=1):(\\n[pdf-img*autolabel]=1):(\\n[pdf-img*caption-after-label]=1) \{\
.       if \\n[#MLA] \{\
.          if (\\n[pdf-img*have-label]=1):(\\n[pdf-img*autolabel]=1) \{\
.             if !\\n[pdf-img*have-caption] \
.                mla@error label caption \\n[.F] \\$0 \\n[.c]
.          \}
.       \}
.       nr lead-pre-label \\n[.v]
.       ev label
.       evc IMG
.       ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.       el \{\
.          img*label-style
.          vs \\n[.ps]u+\\n[pdf-img*label-autolead]u
.       \}
.       if \\n[pdf-img*label-with-chapter] \
.          ds chapno \\n[#CH_NUM].
.       PDF_IMG*SET_LABEL_QUAD \\*[pdf-img*label-quad]
.       sp \\n[lead-pre-label]u-\\n[.v]u
.       if !'\\*[pdf-img*label-space]'' .sp \\*[pdf-img*label-space]
.       ie \\n[pdf-img*autolabel] \
.          nop \
\\*[pdf-img*label-prfx]\\*[chapno]\\n+[fig*label-num]\\*[pdf-img*label-sffx]\|
.       el .if !'\\*[pdf-img*label]'' .nop \\*[pdf-img*label]
.       if \\n[pdf-img*autolabel] \
.          ds pdf-img*label \\*[chapno]\\n[fig*label-num]
.       fam
.       ft
.       ps
.       gcolor
.       if !'\\*[pdf-img*caption]'' \{\
.          if \\n[pdf-img*caption-after-label] \{\
.             ds pdf-img*caption " \\*[pdf-img*caption]
.             nop \\*[pdf-img*caption-specs]\\*[pdf-img*caption]\\*[revert-specs]
.          \}
.       \}
.       sp .5v
.       ev
.       in 0
.    \}
\!.  in
.    di
.    nf
.    vpt 0
.    if !'\\*[pdf-img:adj]'' \{\
.       if \\n[@TOP] \
.          if \\n[#COLUMNS]>1 \
\!.           rs
\!.     sp \\*[pdf-img:adj]
.    \}
.    PDF*IMAGE
.    if !'\\*[pdf-img:adj]'' \
.       if !\\n[@TOP] \!.sp -\\*[pdf-img:adj]
.    vpt
.    ev
.    FLOAT off
.    nr dl \\n[pdf-img:width]
.    if !'\\*[pdf-img*caption-short]'' .ds short -short
.    ie !'\\*[pdf-img*label]'' \
.       TO_FIGURES "\\*[pdf-img*label]" "\\*[pdf-img*caption\\*[short]]"
.    el .TO_FIGURES "\\*[pdf-img*caption\\*[short]]"
.    PDF_IMAGE_CLEAN 
.END
\#
\# PDF_IMAGE_FRAME
\# ---------------
\# *Arguments:
\#   [ <inset> ] [ <rule weight> ] [ <color> ]
\# *Function:
\#   Sets parameters for pdf image frames.
\# *Notes:
\#   Defaults are '6p' '.5' 'black'.  Arguments to be left at default
\#   must be entered as "".
\#
.MAC PDF_IMAGE_FRAME END
.    if !'\\$1''\{\
.       ds frame-arg \\$1
.       substring frame-arg -1
.       ie \B'\\*[frame-arg]' \{\
.          tm1 "[mom]: \\$0 inset argument at line \\n[.c]
.          tm1 "       of '\\n[.F]' requires a unit of measure.
.          tm1 "       Default 6 point inset will be used instead.
.       \}
.       el .nr pdf-img:frame-inset \\$1
.    \}
.    shift
.    if !'\\$1'' \{\
.       ds frame-arg \\$1
.       substring frame-arg -1
.       ie \B'\\*[frame-arg]' \{\
.          ds pdf-img:frame-weight \\$1
.          shift
.       \}
.       el \{\
.          ds frame-arg \\$1
.          substring frame-arg -1 
.          length arg-len \\*[frame-arg]
.          if \\n[arg-len]=1 \{\
.             tm1 "[mom]: \\$0 rule weight argument at line \\n[.c]
.             tm1 "       of '\\n[.F]' must not have a unit of measure appended.
.             tm1 "       Default .5 rule weight will be used instead.
.             shift
.          \}
.       \}
.    \}
.    if !'\\$1'' \{\
.       ie m \\$1 .ds pdf-img:frame-color \\$1
.       el \{\
.          tm1 "[mom]: \\$0 color argument '\\$1' at line \\n[.c]
.          tm1 "       of '\\n[.F]' is not a valid color.
.          tm1 "       Default black will be used instead.
.       \}
.    \}
.END
\#
.MAC PDF_IMAGE_CLEAN END
.    rm PDF*IMAGE
.    rm pdf-img:adj
.    rm pdf-img*caption
.    rm pdf-img*caption-short
.    rm pdf-img*caption-space
.    rm pdf-img:file
.    rm pdf-img*label
.    rm pdf-img*label-space
.    rm pdf-img:pos
.    rm short
.    rr ind-pre-img
.    rr pdf-img:depth
.    rr pdf-img:float
.    rr pdf-img:frame
.    rr pdf-img:ind
.    rr pdf-img:no-shim
.    rr pdf-img:scale
.\" Cutarounds not yet implemented
.    if !\\n[defer] \
.       if !\\n[cutaround] \
.          rr pdf-img*have-caption
.    if !\\n[cutaround] \{\
.       rr pdf-img:frame-inset
.       rr pdf-img:width
.    \}
.    if '\\*[pdf-img*label-sffx-tmp]'.' .ds pdf-img*label-sffx .
.END
\#
.de pdfmomclean
.   ie '\\n[.z]'' \{\
.      ds pdfcleaned \\$*
.      ev pdfcln
.      tr \[em]-
.      nf
.      box pdf:clean
.      nop \\*[\\*[pdfcleaned]]
.      fl
.      box
.      chop pdf:clean
.      asciify pdf:clean
.      ev
.      ds \\*[pdfcleaned] "\\*[pdf:clean]
.      rm pdf:clean
.      tr \[em]\[em]
.    \}
.    el .nop \!.pdfmomclean \\$@
..
\# vim: ft=groff: encoding=latin1: fileencoding=latin1: nomodified:
